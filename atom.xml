<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Twe1ve&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-21T17:16:06.190Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>post_name</title>
    <link href="http://yoursite.com/2020/02/22/post-name/"/>
    <id>http://yoursite.com/2020/02/22/post-name/</id>
    <published>2020-02-21T17:16:06.000Z</published>
    <updated>2020-02-21T17:16:06.190Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PDO&amp;&amp;InjectionBypass</title>
    <link href="http://yoursite.com/2020/02/21/PDO&amp;&amp;InjectionBypass/"/>
    <id>http://yoursite.com/2020/02/21/PDO&amp;&amp;InjectionBypass/</id>
    <published>2020-02-21T11:34:45.899Z</published>
    <updated>2020-02-21T17:28:39.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP-PDO-amp-Injection-Bypass"><a href="#PHP-PDO-amp-Injection-Bypass" class="headerlink" title="PHP PDO &amp; Injection Bypass"></a><strong>PHP PDO &amp; Injection Bypass</strong></h1><p>PDO：PHP 数据对象<br>  PHP访问数据库定义了一个轻量级的一致接口。<br>  PDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。<br>  使用预处理和存储过程</p><p>PDO连接MySql数据库：</p><pre><code>&lt;?php$dbms=&apos;mysql&apos;; //数据库类型$host=&apos;127.0.0.1&apos;; //数据库主机名$port=&apos;3306&apos;;  //数据库端口$dbName=&apos;test&apos;;//使用的数据库$user=&apos;root&apos;;  //数据库连接用户名$pass=&apos;root&apos;;  //对应的密码$dsn=&quot;$dbms:host=$host;port=$port;dbname=$dbName&quot;;   try { $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象 echo &quot;连接成功&lt;br/&gt;&quot;;/*你还可以进行一次搜索操作foreach ($dbh-&gt;query(&apos;SELECT * from FOO&apos;) as $row) {print_r($row); //你可以用 echo($GLOBAL); 来看到这些值}*/$dbh = null;} catch (PDOException $e) {die (&quot;Error!: &quot; . $e-&gt;getMessage() . &quot;&lt;br/&gt;&quot;);}//默认这个不是长连接，如果需要数据库长连接，需要最后加一个参数：array(PDO::ATTR_PERSISTENT =&gt; true) 变成这样：$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT =&gt; true));?&gt;</code></pre><p>PDO多语句安全问题：<br>使用PDO中query()函数同数据库交互：</p><pre><code>&lt;?php$dbms=&apos;mysql&apos;;$host=&apos;127.0.0.1&apos;;$dbName=&apos;test&apos;;$user=&apos;root&apos;;$pass=&apos;root&apos;;$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;;try { $pdo = new PDO($dsn, $user, $pass);} catch (PDOException $e) { echo $e;}$sql = &quot;select * from user where id=1;&quot;;$sql .= &quot;create table test2 like user&quot;;$stmt = $pdo-&gt;query($sql);while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC)){var_dump($row);echo &quot;&quot;;}</code></pre><p>PDO默认支持多语句查询，如果php版本小于5.5.21或者创建PDO实例时未设置PDO::MYSQL_ATTR_MULTI_STATEMENTS为false时可能会造成堆叠注入</p><pre><code>&lt;?php$dbms=&apos;mysql&apos;;$host=&apos;127.0.0.1&apos;;$dbName=&apos;test&apos;;$user=&apos;root&apos;;$pass=&apos;root&apos;;$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;;try { $pdo = new PDO($dsn, $user, $pass);} catch (PDOException $e) { echo $e;}$id = $_GET[&apos;id&apos;];$sql = &quot;SELECT * from user where id =&quot;.$id;$stmt = $pdo-&gt;query($sql);while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC)){var_dump($row);echo &quot;&quot;;}?&gt;</code></pre><p>$id变量可控，以形成堆叠注入</p><p><img src="PDO&&InjectionBypass/01.png" alt=""></p><p>禁止多语句执行：</p><pre><code>new PDO($dsn, $user, $pass, array( PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; false))</code></pre><p>PDO预处理安全问题<br>    PDO分为模拟预处理和非模拟预处理。<br>    模拟预处理是防止某些数据库不支持预处理而设置的，在初始化PDO驱动时，可以设置一项参数,PDO::ATTR_EMULATE_PREPARES，作用是打开模拟预处理(true)或者关闭(false),默认为true。PDO内部会模拟参数绑定的过程，SQL语句是在最后execute()的时候才发送给数据库执行。<br>    非模拟预处理则是通过数据库服务器来进行预处理动作，主要分为两步：第一步是prepare阶段，发送SQL语句模板到数据库服务器；第二步通过execute()函数发送占位符参数给数据库服务器进行执行。</p><p>[1]模拟预处理动态拼接形成多语句执行（PHP&lt;5.3.6）</p><pre><code>&lt;?php$dbms=&apos;mysql&apos;;$host=&apos;127.0.0.1&apos;;$dbName=&apos;test&apos;;$user=&apos;root&apos;;$pass=&apos;root&apos;;$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;;try {$pdo = new PDO($dsn, $user, $pass);} catch (PDOException $e) {echo $e;}//$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);$username = $_GET[&apos;username&apos;];$sql = &quot;select id,&quot;.$_GET[&apos;field&apos;].&quot; from user where username = ?&quot;;$stmt = $pdo-&gt;prepare($sql);$stmt-&gt;bindParam(1,$username);$stmt-&gt;execute();while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC)){var_dump($row);echo &quot;&quot;;}?&gt;   </code></pre><p>可以看到sql语句field字段可控，这样我们构造field，达到多语句执行的效果。</p><p><img src="PDO&&InjectionBypass/02.png" alt=""></p><p>数据库中语句为：</p><pre><code>select id,username from user;create table sss like user;select id from user where username=Z</code></pre><p>[2]模拟预处理报错注入(PHP&lt;5.3.6)<br>   上述代码，设置$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); //打印报错信息<br>   同样可以达到报错注入效果<br><img src="PDO&&InjectionBypass/03.png" alt=""></p><p>在数据库中语句为：</p><pre><code>select id,updatexml(1,concat(user(),0x7e,version()),1) from user;select id from user where username=Z</code></pre><p>[3]非模拟预处理报错注入<br>   设置pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); //表示是否使用PHP本地模拟prepare<br>   ：php对sql语句发送采用了prepare–execute方式，php对sql语句发送采用了prepare–execute方式<br>   此时转义处理交由mysql server来执行，变量和SQL模板是分两次发送的<br>   因此虽然field字段依旧可控，但是多语句不可执行<br>   当设置$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);时，仍然可以进行报错注入<br><img src="PDO&&InjectionBypass/04.png" alt=""><br>在数据库中语句为：<br>    select id,updatexml(1,concat(user(),0x7e),1) from user where username=Y;<br>这里可进行报错注入是因为MySQL服务端prepare时报错，然后通过设置PDO::ATTR_ERRMODE将MySQL错误信息打印<br>在MySQL中执行prepare语句<br>    prepare statm from “select id,updatexml(0x7e,concat(0x7e,user(),0x7e),0x7e) from user where username=?”;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP-PDO-amp-Injection-Bypass&quot;&gt;&lt;a href=&quot;#PHP-PDO-amp-Injection-Bypass&quot; class=&quot;headerlink&quot; title=&quot;PHP PDO &amp;amp; Injection Bypass&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
